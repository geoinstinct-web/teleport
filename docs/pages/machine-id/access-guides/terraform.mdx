---
title: Machine ID with the Teleport Terraform Provider
description: How to use Machine ID with the Teleport Terraform provider to manage your Teleport configuration as IaC
---

The Teleport Terraform provider can be used to configure your Teleport cluster
using Terraform. This Terraform provider requires a way to authenticate with
Teleport and Machine ID credentials can be used for this purpose.

In this guide, you will configure `tbot` to produce credentials for the Teleport
Terraform Provider and use Terraform to configure a Teleport role.

## Prerequisites

(!docs/pages/includes/edition-prereqs-tabs.mdx!)

- (!docs/pages/includes/tctl.mdx!)

- [Terraform >= (=terraform.version=)+](https://learn.hashicorp.com/tutorials/terraform/install-cli)

  ```code
  $ terraform version
  # Terraform v(=terraform.version=)
  ```

- `tbot` must already be installed and configured on the machine that will
  run Terraform. For more information, see the
  [deployment guides](../deployment.mdx).

## Step 1/3. Configure RBAC

First, Teleport must be configured to allow the credentials produced by `tbot`
to modify the Teleport configuration.

If you have followed a platform guide, you will have created a role and granted
the bot the ability to impersonate it already. This role just needs to have the
additional privileges added to it.

Use `tctl edit role/example-bot` to add the following rule to the role:

```yaml
spec:
  allow:
    rules:
    - resources:
      # These currently represent all the resources that can be configured by
      # Terraform. You may wish to remove resources that you do not intend to
      # configure with Terraform from this list to reduce blast radius.
      - app
      - cluster_auth_preference
      - cluster_networking_config
      - db
      - device
      - github
      - login_rule
      - oidc
      - okta_import_rule
      - role
      - saml
      - session_recording_config
      - token
      - trusted_cluster
      - user
      verbs:
      - create
      - read
      - update
      - delete
      - list
```

## Step 2/3. Configure `tbot` output

Now, `tbot` needs to be configured with an output that will produce the
credentials needed by the Terraform provider. As the Terraform provider will be
accessing the Teleport API, the correct output type to use is `identity`.

For this guide, the `directory` destination will be used. This will write these
credentials to a specified directory on disk. Ensure that this directory can
be written to by the Linux user that `tbot` runs as, and that it can be read by
the Linux user that Terraform will run as.

Modify your `tbot` configuration to add an `identity` output:

```yaml
outputs:
- type: identity
  destination:
    type: directory
    # For this guide, /opt/machine-id is used as the destination directory.
    # You may wish to customize this. Multiple outputs cannot share the same
    # destination.
    path: /opt/machine-id
```

If operating `tbot` as a background service, restart it. If running `tbot` in
[one-shot mode](../../includes/machine-id/daemon-or-oneshot.mdx), it must be executed
before you attempt to execute the Terraform plan later.

You should now see an `identity` file under `/opt/machine-id`. This contains
the private key and signed certificates needed by the Terraform provider to
authenticate with the Teleport Auth Server.

## Step 3/3. Use Terraform with the identity output

Start by creating a new Terraform working directory:

```code
$ mkdir ./my-terraform && cd ./my-terraform
$ terraform init
```

In order to configure the Teleport Terraform provider to use the credentials
output by Machine ID, we use the `identity_file_path` option. Whilst is is
possible to configure the Terraform provider using the TLS certificate, the
identity file provides support across more Teleport configurations.

This example creates a simple role for demonstrative purposes, this role is
unlikely to be useful within your Teleport Cluster. Therefore, once you have
confirmed that you have configured Terraform correctly, this resource should be
modified to suit your needs.

In this directory, create `main.tf`:

```hcl
terraform {
  required_providers {
    teleport = {
      version = "(=teleport.version=)"
      source  = "terraform.releases.teleport.dev/gravitational/teleport"
    }
  }
}

provider "teleport" {
  # Replace with the address of your Teleport Proxy or Auth Server.
  addr               = "teleport.example.com:443"
  # Replace with the directory configured in the identity output in the
  # previous step.
  identity_file_path = "/opt/machine-id/identity"
}

# This is an example. Replace this with the resource you wish to be managed
# with Terraform. See the following reference for supported options:
# https://goteleport.com/docs/reference/terraform-provider/
resource "teleport_role" "terraform-test" {
  version = "v7"
  metadata = {
    name        = "terraform-test"
    description = "Example role created by Terraform"
  }

  spec = {
    # This role does nothing as it is an example role.
    allow = {}
  }
}
```

Replace `teleport.example.com:443` with the address of your Teleport Proxy or
Auth Server. If you modified the destination directory from `/opt/machine-id`,
then this should also be replaced.

Now, execute Terraform to test the configuration:

```code
$ terraform apply
```

Check your Teleport cluster, ensuring the role has been created:

```code
$ tctl get role/terraform-test
```

## Example: Github Actions

Let's look at this in a concrete example of running Terraform in CI using GitHub Actions.

First we'll create a token and bot that allow jobs running in Actions in a specific organization,
in a specific repository where we keep all our Terraform code, to use the Terraform role:

```yaml
---
kind: token
version: v2
metadata:
  name: github-actions-bot
  description: Token for GitHub Actions bot for CI Terraform runs
spec: 
  roles:
  - Bot
  bot_name: github-actions
  join_method: github
  github:
    allow:
    - repository: <your org>/<your terraform repo>
---
kind: bot
version: v2
metadata:
  name: github-actions
spec:
  token_id: github-actions-bot
  roles:
  - terraform
```

Now we'll combine the available `teleport-actions` and `hashicorp` Actions to run Terraform in CI, using
tbot to authenticate with the Teleport cluster. The Actions `teleport-actions/setup` and `teleport-actions/auth`
perform the steps we did in Step 2 above, configuring `tbot` and then starting it up in
[one-shot mode](../../includes/machine-id/daemon-or-oneshot.mdx).

```yaml
on:
 push:
   branches:
   - main
   paths:
   - terraform/**
 pull_request:
   branches:
   - main
   paths:
   - terraform/**
 
env:
 # verbosity setting for Terraform logs
 TF_LOG: INFO
 # Credentials for deployment to AWS
 AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
 AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
 # S3 bucket for the Terraform state
 BUCKET_TF_STATE: ${{ secrets.BUCKET_TF_STATE}}

jobs:
  terraform:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - name: Install Teleport
        uses: teleport-actions/setup@v1
        with:
          version: 15.0.1
      - name: Authorize against Teleport
        id: auth
        uses: teleport-actions/auth@v2
        with:
          # Specify the publically accessible address of your Teleport proxy.
          proxy: tele.example.com:443
          # Specify the name of the join token for your bot.
          token: github-actions-bot
          # Specify the length of time that the generated credentials should be
          # valid for. This is optional and defaults to "1h"
          certificate-ttl: 30m
          # Enable submission of anonymous usage telemetry to Teleport.
          # See https://goteleport.com/docs/machine-id/reference/telemetry/ for
          # more information.
          anonymous-telemetry: 1
      - name: Checkout the repository to the runner
        uses: actions/checkout@v3
  
      - name: Setup Terraform with specified version on the runner
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.7.3
      
      - name: Terraform init
        id: init
        run: terraform init -backend-config="bucket=$BUCKET_TF_STATE"
  
      - name: Terraform format
        id: fmt
        run: terraform fmt -check
      
      - name: Terraform validate
        id: validate
        run: terraform validate
  
      - name: Terraform plan
        id: plan
        if: github.event_name == 'pull_request'
        run: terraform plan -no-color -input=false
        continue-on-error: true
      
      - uses: actions/github-script@v6
        if: github.event_name == 'pull_request'
        env:
          PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
        with:
          script: |
            const output = `#### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
            #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`
            #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`
  
            <details><summary>Show Plan</summary>
  
            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`
  
            </details>
            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
  
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })
  
      - name: Terraform Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1
  
      - name: Terraform Apply
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: terraform apply -auto-approve -input=false
```

## Next steps

- Explore the
  [Terraform provider resource reference](../../reference/terraform-provider.mdx)
  to discover what can be configured with the Teleport Terraform provider.
- Read the [configuration reference](../reference/configuration.mdx) to explore
  all the available `tbot` configuration options.
