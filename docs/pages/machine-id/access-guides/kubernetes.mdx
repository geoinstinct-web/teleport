---
title: Machine ID with Kubernetes Access
description: How to use Machine ID to access Kubernetes clusters
---

(!docs/pages/includes/machine-id/v2-config-warning.mdx!)

Teleport Kubernetes Access protects and controls access to Kubernetes
clusters. Machine ID can be used to grant machines secure, short-lived
access to these clusters.

In this guide, you will configure `tbot` to produce credentials that can be
used to access a cluster configured in Teleport Kubernetes Access.

## Prerequisites

(!docs/pages/includes/edition-prereqs-tabs.mdx!)

- If you have not already connected your Kubernetes cluster to Teleport, follow
  the [Kubernetes Access Getting Started Guide](../../kubernetes-access/getting-started.mdx).

(!docs/pages/includes/machine-id/kubernetes-machineidnote.mdx!)

- (!docs/pages/includes/tctl.mdx!)
- To interact with the connected Kubernetes cluster, your client system
  will need to have `kubectl` installed. See the
  [Kubernetes documentation](https://kubernetes.io/docs/tasks/tools/) for
  installation instructions.
- `tbot` must already be installed and configured on the machine that will
  access Kubernetes clusters. For more information, see the
  [platform guides](../platform-guides.mdx).

## Step 1/3. Configure Teleport and Kubernetes RBAC

First, Teleport must be configured to allow the credentials produced by the bot
to access the Kubernetes cluster.

If you have followed an access guide, you will have created a role and granted
the bot the ability to impersonate it already. This role just needs to have the
additional privileges added to it.

Use `tctl edit role/example-bot` to add the following rule to the role:

```yaml
spec:
  allow:
    kubernetes_labels:
      '*': '*'
    kubernetes_resources:
    - kind: pod
      namespace: "*"
      name: "*"
    kubernetes_groups:
    - editor
```

Be sure to configure the `allow` fields to match your environment:
 - `kubernetes_labels` must be specified to allow access to a matching
   Kubernetes cluster in your Teleport environment.

 - Each item in `kubernetes_resources` must match the namespace and name of a
   Kubernetes resource that you would like users with `machine-id-kube-role` to
   access. Currently, Teleport only supports the `pod` kind. In the
   configuration above, this role can access all pods in all namespaces.

 - One (or both) of `kubernetes_groups` and `kubernetes_users` must be specified
   to so that the bot user may be mapped to a Kubernetes user and/or group.

   If only `kubernetes_groups` is set, `kubernetes_users` will be set to the
   bot's username by default.

   The user and group values entered here are relayed directly to the Kubernetes
   cluster as incoming user and group names. Kubernetes users and groups do not
   need to be created in advance, but do need to match one or more
   `RoleBindings` for the bot user to have any permissions on the target
   Kubernetes cluster.

<Details
title="Create a Kubernetes Role and RoleBinding"
opened={true}
>
If you don't have an existing Kubernetes `Role` or `RoleBinding` to grant your
Machine ID bot, create one as follows.

Kubernetes clusters often come with pre-made roles which may meet the needs of
your application, such as `view` and `edit`. You may view these preexisting
rules by running the following:
```code
$ kubectl get clusterrole
```

If you'd prefer to create a role of your own, the following command can be used
to create a rule with narrow access to certain resources types in the
`example-namespace` namespace:
```code
## This creates a role allowing `get` and `list` on pods and deployments.
$ kubectl create role example-role \
  --namespace=example-namespace \
  --verb=get,list \
  --resource=pods,deployments
```

Next, create a role binding to connect the bot to your role. You may bind either
the bot's mapped `User` or mapped `Group` to a role, however it must have been
granted the matching `User` or `Group` via a Teleport role above:

```code
## This binds the new role to the group `example`
$ kubectl create rolebinding example-rolebinding-group \
  --namespace=demo \
  --role=example-role \
  --group=example
## Alternatively, this binds the new role to the user `alice`
$ kubectl create rolebinding example-rolebinding-user \
  --namespace=demo \
  --role=example-role \
  --user=alice
## If binding to a ClusterRole like `view`, instead run the following:
$ kubectl create rolebinding example-rolebinding-user \
  --namespace=demo \
  --clusterrole=view \
  --user=alice
```

You can grant cluster-wide access to your bot user by instead creating `ClusterRole` and
`ClusterRoleBinding` resources, which are not namespaced and use an otherwise
identical syntax.
</Details>

## Step 2/3. Configure the `tbot` output

On a node with `tctl` access, such as your local machine, create a new Machine ID bot using the
Teleport role created in the previous step:

```code
$ tctl bots add example --roles=machine-id-kube-role
```

The creates a bot named `example` with the necessary Kubernetes role. Be sure to
note the bot join token and CA PIN.

Next, on the bot node, create a Machine ID configuration file at
`/etc/tbot.yaml`:

```yaml
version: v2
auth_server: "example.teleport.sh:443"
onboarding:
  join_method: "token"
  token: "00000000000000000000000000000000"
  ca_pins:
  - "sha256:1111111111111111111111111111111111111111111111111111111111111111"
storage:
  type: directory
  path: /var/lib/teleport/bot
outputs:
  - type: kubernetes
    destination:
      type: directory
      path: /opt/machine-id
    kubernetes_cluster: example-k8s-cluster
```

Be sure to configure the `token` and `ca_pins` fields to match the output from
`tctl bots add ...`, and set `kubernetes_cluster` to match the cluster name as
shown in `tsh kube ls`. For this example, we'll be connecting to the
`example-k8s-cluster` cluster.

Machine ID also allows you to use Linux ACLs to control access to certificates
on disk. You will use this to ensure only your application has access to the
short-lived certificates Machine ID uses.

We'll work with the assumption you will be running Machine ID as the Linux user
`teleport` and your automated service as the Linux user `app`. Create and
initialize the destination directory by running this `tbot init` command either
as `root` or as the `teleport` user:

```code
$ tbot init \
    -c /etc/tbot.yaml \
    --init-dir=/opt/machine-id \
    --bot-user=teleport \
    --owner=teleport:teleport \
    --reader-user=app
```

(!docs/pages/includes/machine-id/machine-id-init-bot-data.mdx!)

Next, you will use systemd to run Machine ID in the background on your
bot node. Create a systemd.unit file at
`/etc/systemd/system/machine-id.service`:

```systemd
[Unit]
Description=Teleport Machine ID Service
After=network.target

[Service]
Type=simple
User=teleport
Group=teleport
Restart=on-failure
Environment="TELEPORT_ANONYMOUS_TELEMETRY=1"
ExecStart=/usr/local/bin/tbot start -c /etc/tbot.yaml
ExecReload=/bin/kill -HUP $MAINPID
PIDFile=/run/machine-id.pid
LimitNOFILE=524288

[Install]
WantedBy=multi-user.target
```

Finally, run the following commands to start Machine ID:

(!docs/pages/includes/machine-id/machine-id-service.mdx!)

## Step 3/3. Connect to your Kubernetes cluster with the Machine ID identity

With Machine ID up and running, you should now have Kubernetes certificates
written to `/opt/machine-id`. This can be verified in a few ways:

```code
## A `kubeconfig.yaml` should exist in the destination directory:
$ ls /opt/machine-id/kubeconfig.yaml
/opt/machine-id/kubeconfig.yaml

## Additionally, the log should mention the Kubernetes certificates:
$ journalctl -u machine-id | grep -i kubernetes
Jul 13 20:46:42 example tbot[29177]: INFO [TBOT]      Generated identity for Kubernetes cluster {"example-k8s-cluster"} tbot/renew.go:406
```

You can now use the generated `kubeconfig.yaml` to connect to the cluster with
`kubectl`:

```code
$ kubectl --kubeconfig /opt/machine-id/kubeconfig.yaml get pods -n demo
```

This `kubeconfig.yaml` can also be passed to any other Kubernetes API clients
that support credential provider plugins, including those built with
[`kubernetes/client-go`](https://github.com/kubernetes/client-go) and most other
language libraries.

## Next steps

[More information about `TELEPORT_ANONYMOUS_TELEMETRY`.](../reference/telemetry.mdx)
