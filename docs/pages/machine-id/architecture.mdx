---
title: Machine ID Architecture
description: How Teleport Machine ID works.
---

This section provides an overview of Teleport Machine ID's inner workings.

A more in-depth specification of the workings of Machine ID can be found in
[the Request For Discussion.](https://github.com/gravitational/teleport/blob/master/rfd/0064-bot-for-cert-renewals.md)

## Bot creation

When creating a bot via `tctl`, up to three resources are created:

- Bot user: this will be the user that the Machine ID agent authenticates as.
- Bot role: the bot user is assigned the bot role, and the bot role contains
  various permissions that the bot will need to function. For example, the
  ability to watch the certificate authorities and the ability to 
  [impersonate roles](#role-impersonation).
- Token: for [onboarding](#onboarding), a token must exist that allows the
  Machine ID agent to initially authenticate as the bot user. If an existing
  token is not specified, then a static single-use token will be created by the
  Auth Server.

## `tbot`

`tbot` is the binary that acts as the agent for Machine ID.

On initial load, `tbot` uses the [configured join method](#onboarding) to obtain
a set of credentials for the bot user from the Teleport Auth Service. It can 
then use these credentials to communicate with the Teleport Auth Service as the 
bot.

On a configured regular period `tbot` then:

1. Renews these bot user credentials
2. For each destination provided in `tbot`'s configuration:
   1. Obtains [role impersonated](#role-impersonation) credentials for the roles
      specified in the destination configuration from the Auth Service using the
      bot user credentials.
   2. Outputs these role impersonated credentials in various formats.

Concurrently to this, `tbot` monitors the Teleport certificate authorities to
detect certificate rotations. When this occurs, it triggers additional renewals
to ensure that `tbot` has certificates signed by the newly rotated certificate
authority.

## Role Impersonation

At the core of Machine ID is the concept of role impersonation.

Role Impersonation allows a user to generate credentials with a set of requested
roles. The user does not have to hold these roles, but must have been granted 
permission to impersonate them. The impersonated credentials still include
the username of the user that generated them, so actions can be attributed to 
the user.

These credentials can then be used to complete any action that is allowed by the
role's configured permissions. 

In the case of Machine ID, the bot user is assigned a bot role, which includes 
permissions to impersonate the roles that the user has configured.

## Onboarding

Onboarding is the process by which `tbot` initially authenticates with the 
Teleport auth service in order to receive credentials.

Machine ID leverages the existing Token resource within Teleport, with the
token containing an additional `botName` field that identifies the bot user
associated with the token. 

Machine ID currently supports two methods of joining that have some key
differences.

Static Token:

- The name of the token is used as an opaque secret needed to join the Teleport 
  cluster. This means it must be stored and communicated securely.
- Once used, the token resource self-destructs. This means it can only be used 
  to join a single bot to a Teleport cluster.
- The certificates exchanged for the token are 
  [renewable](#renewable-certificates).


Dynamic join tokens (e.g AWS IAM):

- These tokens rely on some kind of external system that allows the bot to
  prove it is allowed to join the cluster. The name of the token identifies the
  Token resource in Teleport that contains the configuration.
- The token can be used to join as many bots as you want, and do not self
  destruct in the same way that static tokens do.
- The certificates exchanged for the token are not renewable. When the bot wants
  to renew its certificates, it simply repeats the original join steps.

Where possible, you should prefer to use a dynamic join token over a static
token as this eliminates the need to handle a secret.

## Renewable certificates

Human Teleport users are not able to renew their credentials without
re-authenticating. As Machine ID must work without manual human intervention,
bots that have joined using static tokens are granted credentials that are
marked as renewable. This means that the bot can use these credentials to
fetch a new set of credentials with an expiry date further in the future.

In order to mitigate the risk of bot user credentials being stolen, and then
continually renewed by a malicious actor, renewable bot user certificates
include a **generation counter**.

The generation counter is stored against the user in the database and within the
certificate. This counter is incremented each time the user renews their 
certificate. When a bot attempts to renew, the Auth Server ensures that the 
value within the certificate and in the database match. If they do not match,
then the bot user is automatically locked. This means that if certificates are
stolen, and attempted to be renewed whilst the bot is still running, the next
renewal will render them useless.

## File permissions

There are two types of folder in use by `tbot`:

- The bot's own files: these store credentials belonging to the `tbot` process
  itself. As this credentials are potentially renewable, and will allow the
  impersonation of any roles you have allowed for the bot user, they should be
  treated as exceptionally senstive. This is by default stored at 
  `/var/lib/teleport/bot/`.
- Directory destinations: when a directory destination is configured, the bot 
  outputs the role impersonated credentials as files in the specified directory.

It is important that we ensure that these files can only be accessed by the
fewest number of Linux processes and users on the system as is necessary.

In the case of the bot's own files, it is best practice to create a Linux user
specifically for running `tbot` as and to ensure that only this user has access
to this directory.

In the case of directory destinations, the process the bot runs as requires read
and write permissions, and processes that will need the credentials output by 
the bot require read permissions. We recommend that you create a Linux user 
specific to the process that needs to access these files. When using 
`tbot init`, specify this Linux user as the "reader" to grant it access to the
destination.

In addition to basic POSIX filesystem permissions, `tbot init` also sets up
Linux ACLs if the system supports it. This allows more granular control by
granting individual users access.

Finally, on systems that support it, `tbot` will by default attempt to prevent 
the resolution of symbolic links when reading and writing files. This prevents a 
class of attacks sometimes known as 
[symlink attacks](https://capec.mitre.org/data/definitions/132.html). This 
behaviour can be disabled using the `insecure` symlink option when configuring 
your destination.