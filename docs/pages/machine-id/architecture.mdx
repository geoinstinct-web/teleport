---
title: Machine ID Architecture
description: How Teleport Machine ID works.
---

This section provides an overview of Teleport Machine ID's inner workings.

A more in-depth specification of the workings of Machine ID can be found in
[the Request For Discussion.](https://github.com/gravitational/teleport/blob/master/rfd/0064-bot-for-cert-renewals.md)

## Bot creation

When creating a bot via `tctl`, up to three resources are created:

- Bot user: this will be the user that the Machine ID agent authenticates as.
- Bot role: the bot user is assigned the bot role, and the bot role contains
  various permissions that the bot will need to function. For example, the
  ability to watch the certificate authorities and the ability to 
  [impersonate roles](#role-impersonation).
- Token: for [onboarding](#onboarding), a token must exist that allows the
  Machine ID agent to initially authenticate as the bot user. If an existing
  token is not specified, then a static single-use token will be created by the
  Auth Server.

## `tbot`

`tbot` is the binary that acts as the agent for Machine ID.

On initial load, `tbot` uses the [configured join method](#onboarding) to obtain
a set of credentials for the bot user from the Teleport Auth Service. It can 
then use these credentials to communicate with the Teleport Auth Service as the 
bot.

On a configured regular period `tbot` then:

1. Renews these bot user credentials
2. For each destination provided in `tbot`'s configuration:
   1. Obtains [role impersonated](#role-impersonation) credentials for the roles
      specified in the destination configuration from the Auth Service using the
      bot user credentials.
   2. Outputs these role impersonated credentials in various formats.

Concurrently to this, `tbot` monitors the Teleport certificate authorities to
detect certificate rotations. When this occurs, it triggers additional renewals
to ensure that `tbot` has certificates signed by the newly rotated certificate
authority.

## Role Impersonation

At the core of Machine ID is the concept of role impersonation.

Role Impersonation allows a user to generate credentials with a set of requested
roles. The user does not have to hold these roles, but must have been granted 
permission to impersonate them. The impersonated credentials still include
the username of the user that generated them, so actions can be attributed to 
the user.

These credentials can then be used to complete any action that is allowed by the
role's configured permissions. 

In the case of Machine ID, the bot user is assigned a bot role, which includes 
permissions to impersonate the roles that the user has configured.

## Onboarding

Onboarding is the process by which `tbot` initially authenticates with the 
Teleport auth service in order to receive credentials.

Machine ID leverages the existing Token resource within Teleport, with the
token containing an additional `botName` field that identifies the bot user
associated with the token. 

Machine ID currently supports two methods of joining that have some key
differences.

Static Token:

- The name of the token is the only value needed to join. This value is a
  secret and must be handled securely.
- Once used, the token resource self-destructs. This means it can only be used 
  to join a single bot to a Teleport cluster.
- The certificates exchanged for the token are 
  [renewable](#renewable-certificates).


Dynamic join tokens (e.g AWS IAM):

- These tokens rely on some kind of external system that allows the bot to
  prove it is allowed to join the cluster. The name of the token identifies the
  Token resource in Teleport that contains the configuration.
- The token can be used to join as many bots as you want.
- The certificates exchanged for the token are not renewable. When the bot wants
  to renew its certificates, it simply repeats the original join steps.

Where possible, you should prefer to use a dynamic join token over a static
token as this eliminates the need to handle a secret.

## Renewable certificates

Human Teleport users are not able to renew their credentials without
re-authenticating. As Machine ID must work without manual human intervention,
bots that have joined using static tokens are granted credentials that are
marked as renewable. This means that the bot can use these credentials to
fetch a new set of credentials with an expiry date further in the future.

In order to mitigate the risk of bot user credentials being stolen, and then
continually renewed by a malicious actor, renewable bot user certificates
include a **generation counter**.

The generation counter is stored against the user in the database and within the
certificate. This counter is incremented each time the user renews their 
certificate. When a bot attempts to renew, the Auth Server ensures that the 
value within the certificate and in the database match. If they do not match,
then the bot user is automatically locked. This means that if certificates are
stolen, and attempted to be renewed whilst the bot is still running, the next
renewal will render them useless.

## File permissions

There are two types of folder in use by `tbot`:

- The bot's own files: these store sensitive credentials belonging to the bot
  user itself. This is by default stored at `/var/lib/teleport/bot/`.
- Directory destinations: when a directory destination is configured, the bot 
  outputs the role impersonated credentials as files in the specified directory.

It is important that we ensure that these files can only be accessed by the
fewest number of users on the system as is necessary.

In the case of the bot's own files, this should only be the user that the bot
runs as. Running `tbot init` as shown in the documentation should create and
correctly configure the permissions for this.

In the case of directory destinations, the user the bot runs as requires read
and write permissions, and users that will need to use the credentials output
by the bot require read permissions. In most cases, this user that needs to read
the credentials should be specifically created for your application to run as.

In addition to basic POSIX filesystem permissions, `tbot` also sets up Linux
ACLs if the system supports it. This allows more granular control by granting
individual users access.
// TODO: Explain more

Finally, on systems that support it, `tbot` will by default attempt to prevent 
the resolution of symbolic links when reading and writing files. This prevents a 
class of attacks sometimes known as 
[symlink attacks](https://capec.mitre.org/data/definitions/132.html). This 
behaviour can be disabled using the `insecure` symlink option when configuring 
your destination.