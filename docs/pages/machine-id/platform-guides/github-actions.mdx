---
title: Deploying Machine ID on GitHub Actions
description: How to install and configure Machine ID on GitHub Actions
---

GitHub Actions is a popular CI/CD platform that works as a part of the larger
GitHub ecosystem. Teleport Machine ID allows GitHub Actions to securely interact
with Teleport protected resources without the need for long-lived credentials.

Teleport supports secure joining on both GitHub-hosted and self-hosted GitHub
Actions runners as well as GitHub Enterprise Server.

## Prerequisites

(!docs/pages/includes/edition-prereqs-tabs.mdx!)

- (!docs/pages/includes/tctl.mdx!)
- Your user should have the privileges to create token resources.
- A GitHub repository with GitHub Actions enabled. This guide uses the example
`gravitational/example` repo, however this value should be replaced with
your own unique repo.

## Step 1/3. Create a join token for GitHub Actions

In order to allow your GitHub Actions workflow to authenticate with your
Teleport cluster, you'll first need to create a join token. These tokens set out
criteria by which the Auth Server decides whether to allow a bot or node
to join.

Create a file named `bot-token.yaml` and insert the following contents:

```yaml
kind: token
version: v2
metadata:
  name: example-bot
spec:
  roles: [Bot]
  join_method: github
  bot_name: example
  github:
    allow:
    - repository: gravitational/example
```

<Admonition type="note" title="GitHub Enterprise Server">
From Teleport 11.1.4, users with Teleport Enterprise are able to permit
workflows within GitHub Enterprise Server instances to authenticate using the
GitHub join method.

To configure this, set `spec.github.enterprise_server_host` to the hostname of
the GHES instance.

For example:
```yaml
spec:
  github:
    enterprise_server_host: ghes.example.com
```
</Admonition>

Let's go over the token resource YAML's fields in more detail:

- `metadata.name` defines the name of the token. Note that this value will need
to be used in other parts of the configuration later.
- `spec.bot_name` is the name of the Machine ID bot that this token will grant
access to. Note that this value will need to be used in other parts of the
configuration later.
- `spec.roles` defines which roles that this token will grant access to. The
value of `[Bot]` states that this token grants access to a Machine ID bot.
- `spec.join_method` defines the join method the token is applicable for. Since
this guide only focuses on GitHub Actions, we will set this to `github`.
- `spec.github.allow` is used to set rules for what GitHub Actions will be able
to authenticate by using the token. In this example, the `gravitational/example`
repository is used, and this example repository should be replaced with your own
repo.

You can find a full list of the token configuration options for GitHub Actions
joining on the
[GitHub Actions reference page.](../reference/github-actions.mdx#github-join-token)

Once the resource file has been written, create the token with `tctl`:

```code
$ tctl create -f bot-token.yaml
```

Check that token `example-bot` has been created with the following
command:

```code
$ tctl tokens ls
Token       Type Labels Expiry Time (UTC)
----------- ---- ------ ----------------------------------------------
example-bot Bot         01 Jan 00 00:00 UTC (2562047h47m16.854775807s)
```

## Step 2/3. Create your Machine ID bot

(!docs/pages/includes/machine-id/blank-role.mdx!)

Create the bot, specifying the role and token that you have created:

```code
$ tctl bots add example --roles=example-bot --token=example-bot
```

## Step 3/3. Configure GitHub Actions

Now that the bot has been successfully created, GitHub Actions can authenticate
with the Teleport cluster using their GitHub-provided identity.

You now need to configure your GitHub Action workflow. Teleport publishes
several GitHub Actions that can be used within your workflow to assist you.

It is also possible to manually configure `tbot` rather than using one of the
Teleport GitHub Actions. This involves more configuration but allows for
precise control of `tbot` and allows for implementations that are not possible
with the actions.

What follows is examples demonstrating two of the GitHub Actions available as
well as showing how to manually configure `tbot` for use with GitHub Actions.

### Example: `teleport-actions/auth`

In this example, the `teleport-actions/auth` action is used to connect to
Teleport and then used to access servers via SSH, using both `tsh` and the
OpenSSH configuration.

Create `.github/workflows/example.yaml`:

```yaml
# This is a basic workflow to help you get started.
# It will take the following action whenever a push is made to the "main" branch.
on:
  push:
    branches:
    - main
jobs:
  demo:
    permissions:
      # The "id-token: write" permission is required or Machine ID will not be
      # able to authenticate with the cluster.
      id-token: write
      contents: read
    # The name of the workflow, and the Linux distro to be used to perform the
    # required steps.
    name: example
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    - name: Fetch Teleport binaries
      uses: teleport-actions/setup@v1
      with:
        version: (=teleport.version=)
    - name: Fetch credentials using Machine ID
      id: auth
      uses: teleport-actions/auth@v2
      with:
        # Use the address of the auth/proxy server for your own cluster.
        proxy: example.teleport.sh:443
        # Use the name of the join token resource you created in step 1.
        token: example-bot
        # Specify the length of time that the generated credentials should be
        # valid for. This is optional and defaults to "1h"
        certificate-ttl: 1h
        # Enable the submission of anonymous usage telemetry. This
        # helps us shape the future development of `tbot`. You can disable this
        # by omitting this.
        anonymous-telemetry: 1
    - name: Use tsh to list the nodes
      # Enters a command from the cluster, in this case "tsh ls" using Machine
      # ID credentials to list remote SSH nodes.
      run: tsh ls
    - name: Use tsh to connect
      # Enters a command from the cluster, in this case "tsh ssh" using Machine ID credentials to gain SSH access to an SSH node, and then write the commit hash to the "github_run_log" file.
      # Ensure that `root` matches the username of a remote SSH username, and that hostname matches an SSH host name that is a part of the Teleport cluster configured for access.
      run: tsh ssh root@example-node hostname
    - name: Use OpenSSH to connect
      run: ssh -F ${{ steps.auth.outputs.ssh-config }} root@example-node.example.teleport.sh hostname
```

Replace:

- `example.teleport.sh:443` with the address of your Teleport Proxy or cloud
  tenant.
- `example-bot` with the name of the token you created in a previous step.
- `example-node` with the name of a Teleport SSH node that you wish to connect
  to.
- `root` with the name of a user on the node that you are connecting to and that
  you have granted the bot access to.

Add, commit, and push your changes to the `main` branch of the repository.

Navigate to the **Actions** tab of your GitHub repository in your web browser.
Select the **Workflow** that has now been created and triggered by the change,
and select the `example` job. The GitHub Actions workflow may take some time
to complete, and will resemble the following once successful.

![GitHub Actions](../../../img/machine-id/github-actions.png)

Expand the **List nodes** step of the action, and the output will
list all nodes in the cluster, from the perspective of the
Machine ID bot using the command `tsh ls`.

### Example: `teleport-actions/auth-k8s`

In this example, the `teleport-actions/auth-k8s` action will be used to list
all the pods contained within the cluster, but this could just as easily be
modified to deploy to a Kubernetes cluster with `kubectl` or `helm`.

Create `.github/workflows/example.yaml`:

```yaml
# This is a basic workflow to help you get started, modify it for your needs.
on:
  push:
    branches:
    - main
jobs:
  demo:
    permissions:
      # The "id-token: write" permission is required or Machine ID will not be
      # able to authenticate with the cluster.
      id-token: write
      contents: read
    name: example
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    - name: Fetch kubectl
      uses: azure/setup-kubectl@v3
    - name: Fetch Teleport binaries
      uses: teleport-actions/setup@v1
      with:
        version: (=teleport.version=)
    - name: Fetch credentials using Machine ID
      uses: teleport-actions/auth-k8s@v2
      with:
        # Use the address of the auth/proxy server for your own cluster.
        proxy: example.teleport.sh:443
        # Use the name of the join token resource you created in step 1.
        token: example-bot
        # Use the name of your Kubernetes cluster
        kubernetes-cluster: my-kubernetes-cluster
        # Enable the submission of anonymous usage telemetry. This helps us
        # shape the future development of `tbot`. You can disable this by
        # omitting this.
        anonymous-telemetry: 1
    - name: List pods
      run: kubectl get pods -A
```

Replace:

- `example.teleport.sh:443` with the address of your Teleport Proxy or cloud
  tenant.
- `example-bot` with the name of the token you created in a previous step.
- `my-kubernetes-cluster` with the name of your Kubernetes cluster.

The `auth-k8s` action sets the `KUBECONFIG` for future steps to the credentials
it has fetched from Teleport. This means that most existing tooling for
Kubernetes (e.g `kubectl` and `helm`) can use your cluster with no additional
configuration.

Add, commit, and push this new workflow file to the default branch of your
repository.

Navigate to the **Actions** tab of your GitHub repository in your web browser.
Select the **Workflow** that has now been created and triggered by the change,
and select the `example` job.

Expand the **List pods** step of the action, where you can then confirm that the
output shows a list of all the pods within your Kubernetes cluster.

### Example: Manual configuration

To configure `tbot` manually, a YAML file will be used. In this example we'll
commit this to the repository, but this could be generated or created by the
CI pipeline itself.

Create `tbot.yaml` within your repository:

```yaml
version: v2
auth_server: example.teleport.sh:443
onboarding:
  join_method: github
  token: example-bot
oneshot: true
storage:
  type: memory
# outputs will be filled in during the completion of an access guide.
outputs: []
```

Replace:

- `example.teleport.sh:443` with the address of your Teleport Proxy or
  Auth Server. Prefer using the address of a Teleport Proxy.
- `example-bot` with the name of the token you created in the first step.

Now you can define a GitHub Actions workflow that will start `tbot` with this
configuration.

Create `.github/workflows/example-action.yaml`:

```yaml
# This is a basic workflow to help you get started.
# It will take the following action whenever a push is made to the "main" branch.
on:
  push:
    branches:
    - main
jobs:
  demo:
    permissions:
      # The "id-token: write" permission is required or Machine ID will not be
      # able to authenticate with the cluster.
      id-token: write
      contents: read
    # The name of the workflow, and the Linux distro to be used to perform the
    # required steps.
    name: guide-demo
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    - name: Fetch Teleport binaries
      uses: teleport-actions/setup@v1
      with:
        version: (=teleport.version=)
    - name: Execute Machine ID
      env:
        # TELEPORT_ANONYMOUS_TELEMETRY enables the submission of anonymous
        # usage telemetry. This helps us shape the future development of
        # tbot. You can disable this by omitting this.
        TELEPORT_ANONYMOUS_TELEMETRY: 1
      run: tbot -c ./tbot.yaml
```

Add, commit, and push these two files to the repository. Check the GitHub
Actions UI to ensure that the workflow has succeeded.

(!docs/pages/includes/machine-id/configure-outputs.mdx!)

## A note on security implications and risk

Once `teleport-actions/auth` has been used in a workflow job, all successive
steps in that job will have access to the credentials which grant access to your
Teleport cluster as the bot. Where possible, run as few steps as necessary after
this action has been used. It may be a good idea to break your workflow up into
multiple jobs in order to segregate these credentials from other code running in
your CI/CD pipeline.

Most importantly, ensure that the role you assign to your GitHub Actions bot has
access to only the resources in your Teleport cluster that your CI/CD needs to
interact with.

## Next steps

- Check out the GitHub Actions for more usage information:
  - [teleport-actions/setup](https://github.com/teleport-actions/setup)
  - [teleport-actions/auth](https://github.com/teleport-actions/auth)
  - [teleport-actions/auth-k8s](https://github.com/teleport-actions/auth-k8s)
  - [teleport-actions/auth-application](https://github.com/teleport-actions/auth-application)
- For more information about the `github` join method, read the [GitHub Actions
  reference page](../reference/github-actions.mdx#github-join-token)
- Find out more about GitHub Actions itself, read
  [their documentation](https://docs.github.com/en/actions).
- [More information about `anonymous-telemetry`.](../reference/telemetry.mdx)

