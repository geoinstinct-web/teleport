---
title: Deploying Machine ID on Kubernetes
description: How to install and configure Machine ID on Kubernetes
---

Kubernetes is a popular container workload orchestrator. This document covers
deploying Machine ID as a Kubernetes workload in order to provide credentials
to other workloads running in the same Kubernetes namespace.

## Background

There are typically two deployment styles when it comes to workloads such as
`tbot` which provide a service to other workloads in your cluster.

**Standalone Deployment**: `tbot` runs as a Kubernetes deployment, writing the
output credentials to a Kubernetes secret, which can then be mounted in the pods
that need to use the credentials.

**Sidecar**: `tbot` runs as a second container within the same pod as the
service that needs to use the credentials. The credentials are written to a
directory which is mounted within both the containers.

Due to the current limited support in Kubernetes for sidecars, we recommend that
the Standalone Deployment style is used. This style will be covered later in
this guide.

## Before you start

This guide will deploy the resources to the `default` Kubernetes Namespace.
Modify this value to deploy Machine ID into a Namespace of your choosing.

## Step 1/4. Prepare Kubernetes RBAC

In order to prepare the Kubernetes cluster for Machine ID, several Kubernetes
RBAC resources must be created.

A ServiceAccount will be created and later assigned to the Pod that will run
`tbot`. This creates a static identity that we can allow access to join the
Teleport Cluster and also provides an identity to which we can assign Kubernetes
privileges.

A Role granting the ability to read and write to secrets in the Namespace will
be created and then assigned to the ServiceAccount using a RoleBinding. This
will allow the `tbot` Pod to read and write credentials to a Secret.

Create a file called `k8s-rbac.yaml`:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tbot
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tbot-secrets-admin
  namespace: default
subjects:
  - kind: ServiceAccount
    name: tbot
roleRef:
  kind: Role
  name:  secrets-admin
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secrets-admin
  namespace: default
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["*"]
```

Apply this file to your Kubernetes Cluster:

```code
$ kubectl apply -f ./k8s-rbac.yaml
```

## Step 2/4. Create a join token and bot user

```code
$ kubectl proxy -p 8080
$ curl http://localhost:8080/openid/v1/jwks
```

```yaml
kind: token
version: v2
metadata:
  name: bot-kubernetes
spec:
  roles: [Bot]
  bot_name: docker-desktop
  join_method: kubernetes
  kubernetes:
    type: static_jwks
    static_jwks:
      jwks: |
        # Place the data returned by the curl command here
    allow:
    - service_account: "default:tbot" # In the format of `namespace:service_account_name`
```

## Step 3/4. Create a `tbot` deployment

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: tbot-config
  namespace: default
data:
  tbot.yaml: |
    version: v2
    onboarding:
      join_method: kubernetes
      token: bot-kubernetes
    storage:
      type: memory
    auth_server: example.teleport.sh:443
    outputs: [] # This section will be filled later in the guide.
```

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tbot
  namespace: default
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app.kubernetes.io/name: tbot
  template:
    metadata:
      labels:
        app.kubernetes.io/name: tbot
    spec:
      containers:
        - name: tbot
          image: public.ecr.aws/gravitational/teleport:(=teleport.version=)
          command:
            - tbot
          args:
            - start
            - -c
            - /config/tbot.yaml
          env:
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: KUBERNETES_TOKEN_PATH
              value: /var/run/secrets/tokens/join-sa-token
          volumeMounts:
            - mountPath: /config
              name: config
            - mountPath: /var/run/secrets/tokens
              name: join-sa-token
      serviceAccountName: tbot
      volumes:
        - name: config
          configMap:
            name: tbot-config
        - name: join-sa-token
          projected:
            sources:
              - serviceAccountToken:
                  path: join-sa-token
                  expirationSeconds: 600
                  audience: example.teleport.sh
```

```code
$ kubectl apply -f ./k8s-deployment-config.yaml
$ kubectl apply -f ./k8s-deployment.yaml
```

## Step 4/4. Configure Outputs

Follow one of the access guides to configure an output that produces the type
of credentials.

When configuring the outputs, use a Kubernetes secret destination (e.g):

```yaml
outputs:
  - type: identity
    destination:
      type: kubernetes_secret
      secret_name: identity-output
```

The output can then be consumed by mounting this secret within another pod:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: tsh
  namespace: default
spec:
  containers:
    - name: tsh
      image: public.ecr.aws/gravitational/teleport:(=teleport.version=)
      command:
        - tsh
      args:
       - -i
       - /identity-output/identity
       - --proxy
       - example.teleport.sh:443
       - ls
      volumeMounts:
        - name: identity-output
          mountPath: /identity-output
  volumes:
    - name: identity-output
      secret:
        secretName: identity-output
```

## Further steps