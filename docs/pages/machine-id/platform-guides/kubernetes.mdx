---
title: Deploying Machine ID on Kubernetes
description: How to install and configure Machine ID on Kubernetes
---

This page contains relevant background information and specific steps for
deploying Machine ID on Kubernetes.

## Background

### Deployment vs Sidecar

When deploying `tbot` into your Kubernetes cluster, there are two main options:

**Deployment**: `tbot` runs as a Kubernetes deployment, writing the
output credentials to a Kubernetes secret, which can then be mounted in the pods
that need to use the credentials.

**Sidecar**: `tbot` runs as a second container within the same pod as the
service that needs to use the credentials. The credentials are written to a
directory which is mounted within both the containers.

Due to the current limited support in Kubernetes for sidecars, we recommend that
the Standalone Deployment style is used. The guide will demonstrate this
recommendation.

### The `kubernetes` join method

The `kubernetes` join method, used by `tbot` to prove its identity to the
Teleport Auth Server, identifies the bot using the Kubernetes Service Account
that is associated with the Pod that `tbot` is running within.

The Pod receives a JWT signed by the Kubernetes API server. This JWT contains
claims that identify the service account, the pod and the namespace.

In order to validate a presented JWT is legitimate, the Teleport Auth Server
checks the signature of the JWT against the Kubernetes cluster's public signing
key.

### Using a non-`kubernetes` join method

When deploying `tbot` to a Teleport cluster, it is generally recommended to use
the `kubernetes` join method. This will work with most Kubernetes clusters.
The guide that follows will demonstrate configuring this join method.

However, when using certain cloud Kubernetes services, it is possible to use the
join method associated with that platform rather than the `kubernetes` join
method. This may be beneficial if you wish to manage the joining of `tbot`
within the Kubernetes clusters and on standard VMs on the same platform with
a single join token. These services are:

- Google Kubernetes Engine: Where
  [GCP Workload Identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
  is configured for the cluster, it is possible to use the `gcp` join method.
  See the [GCP Platform Guide](./gcp.mdx) for further information.
- AWS Elastic Kubernetes Service: Where
  [IAM Roles for Service Accounts (IRSA)](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html)
  is configured for the cluster, it is possible to use the `iam` join method.
  See the [AWS Platform Guide](./aws.mdx) for further information.

## Guide

This guide will demonstrate installing `tbot` into a Kubernetes cluster as a
Deployment. The `kubernetes` join method will be used to authenticate the bot
to the Teleport cluster.

<Admonition type="tip" title="Namespace">
The examples in this guide will install a `tbot` deployment in the `default`
Namespace of the Kubernetes cluster. Adjust references to `default` to the
Namespace you wish to use.
</Admonition>

### Prerequisites

(!docs/pages/includes/edition-prereqs-tabs.mdx!)
- A Kubernetes cluster with support for Token Volume Projection (enabled by
  default in Kubernetes 1.20).
- `kubectl` authenticated with the ability to create resources in the cluster
  you wish to deploy `tbot` into.
- TODO: Rest of prerequisites

### Step 1/4. Prepare Kubernetes RBAC

In order to prepare the Kubernetes cluster for Machine ID, several Kubernetes
RBAC resources must be created.

A ServiceAccount will be created and later assigned to the Pod that will run
`tbot`. This creates a static identity that we can allow access to join the
Teleport Cluster and also provides an identity to which we can assign Kubernetes
privileges.

A Role granting the ability to read and write to secrets in the Namespace will
be created and then assigned to the ServiceAccount using a RoleBinding. This
will allow the `tbot` Pod to read and write credentials to a Secret.

Create a file called `k8s-rbac.yaml`:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tbot
  namespace: default
---
# This role grants the ability to manage secrets within the namespace.
# You may wish to add the `resourceNames` field to the role to further restrict
# this access in sensitive environments.
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secrets-admin
  namespace: default
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["*"]
---
# Bind the role to the service account created for tbot.
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tbot-secrets-admin
  namespace: default
subjects:
  - kind: ServiceAccount
    name: tbot
roleRef:
  kind: Role
  name:  secrets-admin
  apiGroup: rbac.authorization.k8s.io
```

Apply this file to your Kubernetes Cluster:

```code
$ kubectl apply -f ./k8s-rbac.yaml
```

### Step 2/4. Create a join token, role and bot user

(!docs/pages/includes/machine-id/blank-role.mdx!)

Next, a join token needs to be configured. This will be used by `tbot` to join
the cluster. As the `kubernetes` join method will be used, the JWKS of the
Kubernetes Cluster must first be determined. This will allow the Teleport
Auth Server to verify that the Service Account token presented by `tbot` is
signed legitimately by the Kubernetes cluster.

Run the following commands to determine the JWKS:

```code
$ kubectl proxy -p 8080
$ curl http://localhost:8080/openid/v1/jwks
{"keys":[--snip--]}%
```

Create `bot-token.yaml`, ensuring you insert the value from the JWKS endpoint
in `spec.kubernetes.static_jwks.jwks`:

```yaml
kind: token
version: v2
metadata:
  name: example-bot
spec:
  roles: [Bot]
  bot_name: example
  join_method: kubernetes
  kubernetes:
    type: static_jwks
    static_jwks:
      jwks: |
        {"keys":[--snip--]} # Place the data returned by the curl command here
    allow:
    - service_account: "default:tbot" # In the format of `namespace:service_account_name`
```

Create the bot, specifying the token and role that you have created:

```code
$ tctl bots add example --token example-bot --roles example-bot
```

### Step 3/4. Create a `tbot` deployment

TODO: Explain these

The configuration for `tbot` will be stored inside a Kubernetes ConfigMap.
This can then be mapped into the pod.

Create `k8s-deployment-config.yaml`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: tbot-config
  namespace: default
data:
  tbot.yaml: |
    version: v2
    onboarding:
      join_method: kubernetes
      token: bot-kubernetes
    storage:
      type: memory
    auth_server: example.teleport.sh:443
    # outputs will be filled in during the completion of an access guide.
    outputs: []
```

Apply this file to your Kubernetes Cluster:

```code
$ kubectl apply -f k8s-deployment-config.yaml
```

With the ConfigMap created, you can now create the `tbot` deployment itself.

Create `k8s-deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tbot
  namespace: default
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app.kubernetes.io/name: tbot
  template:
    metadata:
      labels:
        app.kubernetes.io/name: tbot
    spec:
      containers:
        - name: tbot
          image: public.ecr.aws/gravitational/teleport:(=teleport.version=)
          command:
            - tbot
          args:
            - start
            - -c
            - /config/tbot.yaml
          env:
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: KUBERNETES_TOKEN_PATH
              value: /var/run/secrets/tokens/join-sa-token
          volumeMounts:
            - mountPath: /config
              name: config
            - mountPath: /var/run/secrets/tokens
              name: join-sa-token
      serviceAccountName: tbot
      volumes:
        - name: config
          configMap:
            name: tbot-config
        - name: join-sa-token
          projected:
            sources:
              - serviceAccountToken:
                  path: join-sa-token
                  expirationSeconds: 600
                  audience: example.teleport.sh
```

Apply this file to your Kubernetes Cluster:

```code
$ kubectl apply -f ./k8s-deployment.yaml
```

TODO: How to check it's running happily

```code
$ kubectl describe deployment/tbot
$ kubectl logs deployment/tbot
```

TODO: Explain at this point that its not doing much.

### Step 4/4. Configure Outputs

Follow one of the [access guides](../access-guides.mdx) to configure an output
that meets your access needs.

In order to adjust the access guides to work well with Kubernetes, use the
Kubernetes Secret destination type. This will write the generated artifacts
to a specified Kubernetes Secret, for example:

```yaml
outputs:
  - type: identity
    destination:
      type: kubernetes_secret
      secret_name: identity-output
```

The output can then be consumed by mounting this secret within another pod:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: tsh
  namespace: default
spec:
  containers:
    - name: tsh
      image: public.ecr.aws/gravitational/teleport:(=teleport.version=)
      command:
        - tsh
      args:
       - -i
       - /identity-output/identity
       - --proxy
       - example.teleport.sh:443
       - ls
      volumeMounts:
        - name: identity-output
          mountPath: /identity-output
  volumes:
    - name: identity-output
      secret:
        secretName: identity-output
```

## Next steps

- Follow the [access guides](../access-guides.mdx) to finish configuring `tbot` for
  your environment.
- Read the [configuration reference](../reference/configuration.mdx) to explore
  all the available configuration options.