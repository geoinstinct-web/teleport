---
title: Deploying Machine ID on Kubernetes
description: How to install and configure Machine ID on Kubernetes
---

Kubernetes is a popular container workload orchestrator. This document covers
deploying Machine ID as a Kubernetes workload in order to provide credentials
to other workloads running in the same Kubernetes namespace.

## Background

### Deployment vs Sidecar

When deploying `tbot` into your Kubernetes cluster, there are two main options:

**Deployment**: `tbot` runs as a Kubernetes deployment, writing the
output credentials to a Kubernetes secret, which can then be mounted in the pods
that need to use the credentials.

**Sidecar**: `tbot` runs as a second container within the same pod as the
service that needs to use the credentials. The credentials are written to a
directory which is mounted within both the containers.

Due to the current limited support in Kubernetes for sidecars, we recommend that
the Standalone Deployment style is used. This style will be covered later in
this guide.

### Join method

In order for `tbot` to join your Teleport cluster, a join token must be
configured. A join token is configured with a join method that specifies how
`tbot` can perform the initial authentication. These join methods are platform
specific in order to leverage forms of identity available on that platform.

When deploying `tbot` to a Teleport cluster, it is generally recommended to use
the `kubernetes` join method. This will work with most Kubernetes clusters.
The guide that follows will demonstrate configuring this join method.

However, when using certain cloud Kubernetes services, it is possible to use the
join method associated with that platform rather than the `kubernetes` join
method. This may be beneficial if you wish to manage the joining of `tbot`
within the Kubernetes clusters and on standard VMs on the same platform with
a single join token. These services are:

- Google Kubernetes Engine: Where
  [GCP Workload Identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
  is configured for the cluster, it is possible to use the `gcp` join method.
  See the [GCP Platform Guide](./gcp.mdx) for further information.
- AWS Elastic Kubernetes Service: Where
  [IAM Roles for Service Accounts (IRSA)](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html)
  is configured for the cluster, it is possible to use the `iam` join method.
  See the [AWS Platform Guide](./aws.mdx) for further information.

## Guide

This guide will demonstrate installing `tbot` into a Kubernetes cluster as a
Deployment. The `kubernetes` join method will be used to authenticate the bot
to the Teleport cluster.

<Admonition type="tip" title="Namespace">
The examples in this guide will install a `tbot` deployment in the `default`
Namespace of the Kubernetes cluster. Adjust references to `default` to the
Namespace you wish to use.
</Admonition>

### Prerequisites

(!docs/pages/includes/edition-prereqs-tabs.mdx!)
- A Kubernetes cluster with support for Token Volume Projection (enabled by
  default in Kubernetes 1.20).
- `kubectl` authenticated with the ability to create resources in the cluster
  you wish to deploy `tbot` into.

### Step 1/4. Prepare Kubernetes RBAC

In order to prepare the Kubernetes cluster for Machine ID, several Kubernetes
RBAC resources must be created.

A ServiceAccount will be created and later assigned to the Pod that will run
`tbot`. This creates a static identity that we can allow access to join the
Teleport Cluster and also provides an identity to which we can assign Kubernetes
privileges.

A Role granting the ability to read and write to secrets in the Namespace will
be created and then assigned to the ServiceAccount using a RoleBinding. This
will allow the `tbot` Pod to read and write credentials to a Secret.

Create a file called `k8s-rbac.yaml`:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tbot
  namespace: default
---
# This role grants the ability to manage secrets within the namespace.
# You may wish to add the `resourceNames` field to the role to further restrict
# this access in sensitive environments.
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secrets-admin
  namespace: default
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["*"]
---
# Bind the role to the service account created for tbot.
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tbot-secrets-admin
  namespace: default
subjects:
  - kind: ServiceAccount
    name: tbot
roleRef:
  kind: Role
  name:  secrets-admin
  apiGroup: rbac.authorization.k8s.io
```

Apply this file to your Kubernetes Cluster:

```code
$ kubectl apply -f ./k8s-rbac.yaml
```

### Step 2/4. Create a join token, role and bot user

TODO: Improve this description to make it clear this is the role the bot
TODO: attaches to generated credentials and not the role the bot uses itself
TODO: We need to do a better job at distinguishing this.
TODO: As each guide will do this, let's pull this into a include

First, a role must be created that the bot will use when outputting credentials.
For now, an empty role will be created, but in the access guides, you will add
privileges to this role.

Create `bot-role.yaml`:

```yaml
kind: role
version: v5
metadata:
  name: example-bot
spec:
  allow: {}
  deny: {}
  options: {}
```

Use `tctl` to apply this file:

```code
$ tctl create -f bot-role.yaml
```

Now the join token must be created. Before we can create it, we need to
determine the JWKS of the Kubernetes Cluster.
TODO: Explain why we need to fetch the jwks

```code
$ kubectl proxy -p 8080
$ curl http://localhost:8080/openid/v1/jwks
```

Create `bot-token.yaml`, ensuring you insert the value from the JWKS endpoint
in `spec.kubernetes.static_jwks.jwks`:

```yaml
kind: token
version: v2
metadata:
  name: example-bot
spec:
  roles: [Bot]
  bot_name: example
  join_method: kubernetes
  kubernetes:
    type: static_jwks
    static_jwks:
      jwks: |
        # Place the data returned by the curl command here
    allow:
    - service_account: "default:tbot" # In the format of `namespace:service_account_name`
```

Create the bot, specifying the token and role that you have created:

```code
$ tctl bots add example --token example-bot --roles example-bot
```

### Step 3/4. Create a `tbot` deployment

TODO: Explain these

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: tbot-config
  namespace: default
data:
  tbot.yaml: |
    version: v2
    onboarding:
      join_method: kubernetes
      token: bot-kubernetes
    storage:
      type: memory
    auth_server: example.teleport.sh:443
    # outputs will be filled in during the completion of an access guide.
    outputs: []
```

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tbot
  namespace: default
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app.kubernetes.io/name: tbot
  template:
    metadata:
      labels:
        app.kubernetes.io/name: tbot
    spec:
      containers:
        - name: tbot
          image: public.ecr.aws/gravitational/teleport:(=teleport.version=)
          command:
            - tbot
          args:
            - start
            - -c
            - /config/tbot.yaml
          env:
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: KUBERNETES_TOKEN_PATH
              value: /var/run/secrets/tokens/join-sa-token
          volumeMounts:
            - mountPath: /config
              name: config
            - mountPath: /var/run/secrets/tokens
              name: join-sa-token
      serviceAccountName: tbot
      volumes:
        - name: config
          configMap:
            name: tbot-config
        - name: join-sa-token
          projected:
            sources:
              - serviceAccountToken:
                  path: join-sa-token
                  expirationSeconds: 600
                  audience: example.teleport.sh
```

```code
$ kubectl apply -f ./k8s-deployment-config.yaml
$ kubectl apply -f ./k8s-deployment.yaml
```

TODO: VERIFY IT WORKS!!

### Step 4/4. Configure Outputs

Follow one of the [access guides](../access-guides.mdx) to configure an output
that meets your access needs.

In order to adjust the access guides to work well with Kubernetes, use the
Kubernetes Secret destination type. This will write the generated artifacts
to a specified Kubernetes Secret, for example:

```yaml
outputs:
  - type: identity
    destination:
      type: kubernetes_secret
      secret_name: identity-output
```

The output can then be consumed by mounting this secret within another pod:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: tsh
  namespace: default
spec:
  containers:
    - name: tsh
      image: public.ecr.aws/gravitational/teleport:(=teleport.version=)
      command:
        - tsh
      args:
       - -i
       - /identity-output/identity
       - --proxy
       - example.teleport.sh:443
       - ls
      volumeMounts:
        - name: identity-output
          mountPath: /identity-output
  volumes:
    - name: identity-output
      secret:
        secretName: identity-output
```

## Next steps

- Follow the [access guides](../access-guides.mdx) to finish configuring `tbot` for
  your environment.
- Read the [configuration reference](../reference/configuration.mdx) to explore
  all the available configuration options.