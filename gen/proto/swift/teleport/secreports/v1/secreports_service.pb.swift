// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/secreports/v1/secreports_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GetAuditQueryResultRequest is a request for GetAuditQueryResult.
struct Teleport_Secreports_V1_GetAuditQueryResultRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// result_id is a unique id of the result.
  var resultID: String = String()

  /// next_token is a token for pagination.
  var nextToken: String = String()

  /// max_results is a maximum number of results to return.
  var maxResults: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryResultColumnInfo is a column info.
struct Teleport_Secreports_V1_QueryResultColumnInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is name of the column.
  var name: String = String()

  /// type is type of the column.
  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryRowResult is a row result.
struct Teleport_Secreports_V1_QueryRowResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// data is a list of values.
  var data: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryResultSet is a result set.
struct Teleport_Secreports_V1_QueryResultSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// column_info contains information about columns.
  var columnInfo: [Teleport_Secreports_V1_QueryResultColumnInfo] = []

  /// rows  is a list of rows containing values.
  var rows: [Teleport_Secreports_V1_QueryRowResult] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAuditQueryResultResponse contains an audit query result.
struct Teleport_Secreports_V1_GetAuditQueryResultResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// result is a result set.
  var result: Teleport_Secreports_V1_QueryResultSet {
    get {return _result ?? Teleport_Secreports_V1_QueryResultSet()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  /// next_token is a token for pagination.
  var nextToken: String = String()

  /// result_id is a unique id of the result.
  var resultID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Teleport_Secreports_V1_QueryResultSet? = nil
}

/// RunReportRequest is a request for RunReport.
struct Teleport_Secreports_V1_RunReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is a name of the security report.
  var name: String = String()

  /// days is a time range is days.
  var days: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetStateRequest is a request for GetReportState.
struct Teleport_Secreports_V1_GetReportStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is a name of the security report.
  var name: String = String()

  /// days is a time range is days.
  var days: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteAuditQueryRequest is audit query delete request.
struct Teleport_Secreports_V1_DeleteAuditQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the audit query to delete.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteReportRequest is security report delete request.
struct Teleport_Secreports_V1_DeleteReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the security report to delete.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RunAuditQueryRequest is audit query run request.
struct Teleport_Secreports_V1_RunAuditQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the audit query to run.
  var query: String = String()

  /// days is a time range is days.
  var days: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertAuditQueryRequest is audit query upsert request.
struct Teleport_Secreports_V1_UpsertAuditQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// audit_query is the audit query to upsert.
  var auditQuery: Teleport_Secreports_V1_AuditQuery {
    get {return _auditQuery ?? Teleport_Secreports_V1_AuditQuery()}
    set {_auditQuery = newValue}
  }
  /// Returns true if `auditQuery` has been explicitly set.
  var hasAuditQuery: Bool {return self._auditQuery != nil}
  /// Clears the value of `auditQuery`. Subsequent reads from it will return its default value.
  mutating func clearAuditQuery() {self._auditQuery = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _auditQuery: Teleport_Secreports_V1_AuditQuery? = nil
}

/// UpsertReportRequest is security report upsert request.
struct Teleport_Secreports_V1_UpsertReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// report is the security report to upsert.
  var report: Teleport_Secreports_V1_Report {
    get {return _report ?? Teleport_Secreports_V1_Report()}
    set {_report = newValue}
  }
  /// Returns true if `report` has been explicitly set.
  var hasReport: Bool {return self._report != nil}
  /// Clears the value of `report`. Subsequent reads from it will return its default value.
  mutating func clearReport() {self._report = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _report: Teleport_Secreports_V1_Report? = nil
}

/// GetAuditQueryRequest is audit query get request.
struct Teleport_Secreports_V1_GetAuditQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the audit query to get.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetReportRequest is security report get request.
struct Teleport_Secreports_V1_GetReportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the security report to get.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetReportResultRequest is report get request.
struct Teleport_Secreports_V1_GetReportResultRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the security report to get.
  var name: String = String()

  /// days is a time range is days.
  var days: UInt32 = 0

  /// execution_id is a unique id of the execution.
  var executionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAuditQueriesRequest is audit query list request.
struct Teleport_Secreports_V1_ListAuditQueriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// page_size is the number of results to return.
  var pageSize: Int32 = 0

  /// page_token is the next_token value returned from a previous List request if any.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAuditQueryResponse is audit query list response.
struct Teleport_Secreports_V1_ListReportsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// page_size is the number of results to return.
  var pageSize: Int32 = 0

  /// page_token is the next_token value returned from a previous List request if any.
  var pageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAuditQueriesResponse is audit query list response.
struct Teleport_Secreports_V1_ListAuditQueriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// queries is a list of audit queries.
  var queries: [Teleport_Secreports_V1_AuditQuery] = []

  /// next_page_token is the next page token. If there are no more results, it will be empty.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSchemaRequest is a request for GetSchema.
struct Teleport_Secreports_V1_GetSchemaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSchemaResponse is a response for GetSchema.
struct Teleport_Secreports_V1_GetSchemaResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// views is the list of views.
  var views: [Teleport_Secreports_V1_GetSchemaResponse.ViewDesc] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ViewDesc is a description of view.
  struct ViewDesc {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// name is the name of the view.
    var name: String = String()

    /// desc is the description of the view.
    var desc: String = String()

    /// columns is the list of columns.
    var columns: [Teleport_Secreports_V1_GetSchemaResponse.ViewDesc.ColumnDesc] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// ColumnDesc is a description of column.
    struct ColumnDesc {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// name is the name of the column.
      var name: String = String()

      /// type is the type of the column.
      var type: String = String()

      /// desc is the description of the column.
      var desc: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}
}

/// RunAuditQueryResponse is audit query run response.
struct Teleport_Secreports_V1_RunAuditQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// result_id is a unique id of the result.
  var resultID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListReportResponse is security report list response.
struct Teleport_Secreports_V1_ListReportsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// reports is a list of security reports.
  var reports: [Teleport_Secreports_V1_Report] = []

  /// next_page_token is the next page token. If there are no more results, it will be empty.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetReportResultResponse is report result get response.
struct Teleport_Secreports_V1_GetReportResultResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// result is a report execution result.
  var result: Teleport_Secreports_V1_ReportResult {
    get {return _result ?? Teleport_Secreports_V1_ReportResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Teleport_Secreports_V1_ReportResult? = nil
}

/// Report is the result of security report.
struct Teleport_Secreports_V1_ReportResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is a name of the security report.
  var name: String = String()

  /// description is a description of the security report.
  var description_p: String = String()

  /// audit_query_results is a list of audit query results.
  var auditQueryResults: [Teleport_Secreports_V1_ReportResult.AuditQueryResult] = []

  /// updated_at is a time when the security report was updated.
  var updatedAt: String = String()

  /// total_execution_time_in_millis is a time in milliseconds when the security report was executed.
  var totalExecutionTimeInMillis: Int64 = 0

  /// total_data_scanned_in_bytes is a number of bytes scanned.
  var totalDataScannedInBytes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// AuditQueryResult is a result of audit query.
  struct AuditQueryResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// audit_query is the audit query spec containing information about audit query.
    var auditQuery: Teleport_Secreports_V1_AuditQuerySpec {
      get {return _auditQuery ?? Teleport_Secreports_V1_AuditQuerySpec()}
      set {_auditQuery = newValue}
    }
    /// Returns true if `auditQuery` has been explicitly set.
    var hasAuditQuery: Bool {return self._auditQuery != nil}
    /// Clears the value of `auditQuery`. Subsequent reads from it will return its default value.
    mutating func clearAuditQuery() {self._auditQuery = nil}

    /// result is the result set.
    var result: Teleport_Secreports_V1_QueryResultSet {
      get {return _result ?? Teleport_Secreports_V1_QueryResultSet()}
      set {_result = newValue}
    }
    /// Returns true if `result` has been explicitly set.
    var hasResult: Bool {return self._result != nil}
    /// Clears the value of `result`. Subsequent reads from it will return its default value.
    mutating func clearResult() {self._result = nil}

    /// result_id is a unique id of the result.
    var resultID: String = String()

    /// execution_time_in_millis is a time in milliseconds when the audit query was executed.
    var executionTimeInMillis: Int64 = 0

    /// data_scanned_in_bytes is a number of bytes scanned.
    var dataScannedInBytes: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _auditQuery: Teleport_Secreports_V1_AuditQuerySpec? = nil
    fileprivate var _result: Teleport_Secreports_V1_QueryResultSet? = nil
  }

  init() {}
}

/// Report is a security report.
struct Teleport_Secreports_V1_ReportSate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// header is a resource header.
  var header: Teleport_Header_V1_ResourceHeader {
    get {return _header ?? Teleport_Header_V1_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// state is a state of the security report.
  var state: Teleport_Secreports_V1_ReportSate.State = .unspecified

  /// updated_at is a time when the security report state was updated.
  var updatedAt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// name is a name of the security report.
  enum State: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// STATE_UNSPECIFIED is an unspecified state.
    case unspecified // = 0

    /// STATE_ERROR is an error state.
    case error // = 1

    /// STATE_SUCCESS is a success state.
    case success // = 2

    /// STATE_RUNNING is a running state.
    case running // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .error
      case 2: self = .success
      case 3: self = .running
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .error: return 1
      case .success: return 2
      case .running: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _header: Teleport_Header_V1_ResourceHeader? = nil
}

#if swift(>=4.2)

extension Teleport_Secreports_V1_ReportSate.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Secreports_V1_ReportSate.State] = [
    .unspecified,
    .error,
    .success,
    .running,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Teleport_Secreports_V1_GetAuditQueryResultRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_QueryResultColumnInfo: @unchecked Sendable {}
extension Teleport_Secreports_V1_QueryRowResult: @unchecked Sendable {}
extension Teleport_Secreports_V1_QueryResultSet: @unchecked Sendable {}
extension Teleport_Secreports_V1_GetAuditQueryResultResponse: @unchecked Sendable {}
extension Teleport_Secreports_V1_RunReportRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_GetReportStateRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_DeleteAuditQueryRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_DeleteReportRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_RunAuditQueryRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_UpsertAuditQueryRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_UpsertReportRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_GetAuditQueryRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_GetReportRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_GetReportResultRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_ListAuditQueriesRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_ListReportsRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_ListAuditQueriesResponse: @unchecked Sendable {}
extension Teleport_Secreports_V1_GetSchemaRequest: @unchecked Sendable {}
extension Teleport_Secreports_V1_GetSchemaResponse: @unchecked Sendable {}
extension Teleport_Secreports_V1_GetSchemaResponse.ViewDesc: @unchecked Sendable {}
extension Teleport_Secreports_V1_GetSchemaResponse.ViewDesc.ColumnDesc: @unchecked Sendable {}
extension Teleport_Secreports_V1_RunAuditQueryResponse: @unchecked Sendable {}
extension Teleport_Secreports_V1_ListReportsResponse: @unchecked Sendable {}
extension Teleport_Secreports_V1_GetReportResultResponse: @unchecked Sendable {}
extension Teleport_Secreports_V1_ReportResult: @unchecked Sendable {}
extension Teleport_Secreports_V1_ReportResult.AuditQueryResult: @unchecked Sendable {}
extension Teleport_Secreports_V1_ReportSate: @unchecked Sendable {}
extension Teleport_Secreports_V1_ReportSate.State: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.secreports.v1"

extension Teleport_Secreports_V1_GetAuditQueryResultRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAuditQueryResultRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "result_id"),
    2: .standard(proto: "next_token"),
    3: .standard(proto: "max_results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resultID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxResults) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resultID.isEmpty {
      try visitor.visitSingularStringField(value: self.resultID, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    if self.maxResults != 0 {
      try visitor.visitSingularInt32Field(value: self.maxResults, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetAuditQueryResultRequest, rhs: Teleport_Secreports_V1_GetAuditQueryResultRequest) -> Bool {
    if lhs.resultID != rhs.resultID {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.maxResults != rhs.maxResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_QueryResultColumnInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResultColumnInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_QueryResultColumnInfo, rhs: Teleport_Secreports_V1_QueryResultColumnInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_QueryRowResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRowResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_QueryRowResult, rhs: Teleport_Secreports_V1_QueryRowResult) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_QueryResultSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResultSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "column_info"),
    2: .same(proto: "rows"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.columnInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.columnInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columnInfo, fieldNumber: 1)
    }
    if !self.rows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rows, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_QueryResultSet, rhs: Teleport_Secreports_V1_QueryResultSet) -> Bool {
    if lhs.columnInfo != rhs.columnInfo {return false}
    if lhs.rows != rhs.rows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_GetAuditQueryResultResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAuditQueryResultResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "next_token"),
    3: .standard(proto: "result_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resultID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    if !self.resultID.isEmpty {
      try visitor.visitSingularStringField(value: self.resultID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetAuditQueryResultResponse, rhs: Teleport_Secreports_V1_GetAuditQueryResultResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.resultID != rhs.resultID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_RunReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunReportRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "days"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.days) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.days != 0 {
      try visitor.visitSingularUInt32Field(value: self.days, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_RunReportRequest, rhs: Teleport_Secreports_V1_RunReportRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.days != rhs.days {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_GetReportStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetReportStateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "days"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.days) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.days != 0 {
      try visitor.visitSingularUInt32Field(value: self.days, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetReportStateRequest, rhs: Teleport_Secreports_V1_GetReportStateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.days != rhs.days {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_DeleteAuditQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAuditQueryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_DeleteAuditQueryRequest, rhs: Teleport_Secreports_V1_DeleteAuditQueryRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_DeleteReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteReportRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_DeleteReportRequest, rhs: Teleport_Secreports_V1_DeleteReportRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_RunAuditQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunAuditQueryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    2: .same(proto: "days"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.days) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    if self.days != 0 {
      try visitor.visitSingularInt32Field(value: self.days, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_RunAuditQueryRequest, rhs: Teleport_Secreports_V1_RunAuditQueryRequest) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.days != rhs.days {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_UpsertAuditQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertAuditQueryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audit_query"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auditQuery) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auditQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_UpsertAuditQueryRequest, rhs: Teleport_Secreports_V1_UpsertAuditQueryRequest) -> Bool {
    if lhs._auditQuery != rhs._auditQuery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_UpsertReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertReportRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "report"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._report) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._report {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_UpsertReportRequest, rhs: Teleport_Secreports_V1_UpsertReportRequest) -> Bool {
    if lhs._report != rhs._report {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_GetAuditQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAuditQueryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetAuditQueryRequest, rhs: Teleport_Secreports_V1_GetAuditQueryRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_GetReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetReportRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetReportRequest, rhs: Teleport_Secreports_V1_GetReportRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_GetReportResultRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetReportResultRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "days"),
    3: .standard(proto: "execution_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.days) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.executionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.days != 0 {
      try visitor.visitSingularUInt32Field(value: self.days, fieldNumber: 2)
    }
    if !self.executionID.isEmpty {
      try visitor.visitSingularStringField(value: self.executionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetReportResultRequest, rhs: Teleport_Secreports_V1_GetReportResultRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.days != rhs.days {return false}
    if lhs.executionID != rhs.executionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_ListAuditQueriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAuditQueriesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_ListAuditQueriesRequest, rhs: Teleport_Secreports_V1_ListAuditQueriesRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_ListReportsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListReportsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_ListReportsRequest, rhs: Teleport_Secreports_V1_ListReportsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_ListAuditQueriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAuditQueriesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queries"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_ListAuditQueriesResponse, rhs: Teleport_Secreports_V1_ListAuditQueriesResponse) -> Bool {
    if lhs.queries != rhs.queries {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_GetSchemaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSchemaRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetSchemaRequest, rhs: Teleport_Secreports_V1_GetSchemaRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_GetSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSchemaResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "views"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.views) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.views.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.views, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetSchemaResponse, rhs: Teleport_Secreports_V1_GetSchemaResponse) -> Bool {
    if lhs.views != rhs.views {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_GetSchemaResponse.ViewDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Teleport_Secreports_V1_GetSchemaResponse.protoMessageName + ".ViewDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "desc"),
    3: .same(proto: "columns"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.columns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 2)
    }
    if !self.columns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columns, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetSchemaResponse.ViewDesc, rhs: Teleport_Secreports_V1_GetSchemaResponse.ViewDesc) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.columns != rhs.columns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_GetSchemaResponse.ViewDesc.ColumnDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Teleport_Secreports_V1_GetSchemaResponse.ViewDesc.protoMessageName + ".ColumnDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "desc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetSchemaResponse.ViewDesc.ColumnDesc, rhs: Teleport_Secreports_V1_GetSchemaResponse.ViewDesc.ColumnDesc) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_RunAuditQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunAuditQueryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "result_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resultID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resultID.isEmpty {
      try visitor.visitSingularStringField(value: self.resultID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_RunAuditQueryResponse, rhs: Teleport_Secreports_V1_RunAuditQueryResponse) -> Bool {
    if lhs.resultID != rhs.resultID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_ListReportsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListReportsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reports"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.reports) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reports, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_ListReportsResponse, rhs: Teleport_Secreports_V1_ListReportsResponse) -> Bool {
    if lhs.reports != rhs.reports {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_GetReportResultResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetReportResultResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_GetReportResultResponse, rhs: Teleport_Secreports_V1_GetReportResultResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_ReportResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReportResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "audit_query_results"),
    4: .standard(proto: "updated_at"),
    5: .standard(proto: "total_execution_time_in_millis"),
    6: .standard(proto: "total_data_scanned_in_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.auditQueryResults) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalExecutionTimeInMillis) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.totalDataScannedInBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.auditQueryResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auditQueryResults, fieldNumber: 3)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 4)
    }
    if self.totalExecutionTimeInMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.totalExecutionTimeInMillis, fieldNumber: 5)
    }
    if self.totalDataScannedInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.totalDataScannedInBytes, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_ReportResult, rhs: Teleport_Secreports_V1_ReportResult) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.auditQueryResults != rhs.auditQueryResults {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.totalExecutionTimeInMillis != rhs.totalExecutionTimeInMillis {return false}
    if lhs.totalDataScannedInBytes != rhs.totalDataScannedInBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_ReportResult.AuditQueryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Teleport_Secreports_V1_ReportResult.protoMessageName + ".AuditQueryResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audit_query"),
    2: .same(proto: "result"),
    3: .standard(proto: "result_id"),
    4: .standard(proto: "execution_time_in_millis"),
    5: .standard(proto: "data_scanned_in_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auditQuery) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resultID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.executionTimeInMillis) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.dataScannedInBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auditQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resultID.isEmpty {
      try visitor.visitSingularStringField(value: self.resultID, fieldNumber: 3)
    }
    if self.executionTimeInMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.executionTimeInMillis, fieldNumber: 4)
    }
    if self.dataScannedInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.dataScannedInBytes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_ReportResult.AuditQueryResult, rhs: Teleport_Secreports_V1_ReportResult.AuditQueryResult) -> Bool {
    if lhs._auditQuery != rhs._auditQuery {return false}
    if lhs._result != rhs._result {return false}
    if lhs.resultID != rhs.resultID {return false}
    if lhs.executionTimeInMillis != rhs.executionTimeInMillis {return false}
    if lhs.dataScannedInBytes != rhs.dataScannedInBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_ReportSate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReportSate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "state"),
    3: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.updatedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    if !self.updatedAt.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedAt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Secreports_V1_ReportSate, rhs: Teleport_Secreports_V1_ReportSate) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.state != rhs.state {return false}
    if lhs.updatedAt != rhs.updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Secreports_V1_ReportSate.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "STATE_ERROR"),
    2: .same(proto: "STATE_SUCCESS"),
    3: .same(proto: "STATE_RUNNING"),
  ]
}
