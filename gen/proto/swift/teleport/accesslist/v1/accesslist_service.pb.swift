// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/accesslist/v1/accesslist_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// GetAccessListsRequest is the request for getting all access lists.
struct Teleport_Accesslist_V1_GetAccessListsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccessListsResponse is the response for getting all access lists.
struct Teleport_Accesslist_V1_GetAccessListsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_lists is the list of access lists.
  var accessLists: [Teleport_Accesslist_V1_AccessList] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListsRequest is the request for getting paginated access lists.
struct Teleport_Accesslist_V1_ListAccessListsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// page_size is the size of the page to request.
  var pageSize: Int32 = 0

  /// next_token is the page token.
  var nextToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListsResponse is the response for getting paginated access lists.
struct Teleport_Accesslist_V1_ListAccessListsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_lists is the list of access lists.
  var accessLists: [Teleport_Accesslist_V1_AccessList] = []

  /// next_token is the next page token.
  var nextToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccessListRequest is the request for retrieving an access list.
struct Teleport_Accesslist_V1_GetAccessListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the access list to retrieve.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertAccessListRequest is the request for upserting an access list.
struct Teleport_Accesslist_V1_UpsertAccessListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the access list to upsert.
  var accessList: Teleport_Accesslist_V1_AccessList {
    get {return _accessList ?? Teleport_Accesslist_V1_AccessList()}
    set {_accessList = newValue}
  }
  /// Returns true if `accessList` has been explicitly set.
  var hasAccessList: Bool {return self._accessList != nil}
  /// Clears the value of `accessList`. Subsequent reads from it will return its default value.
  mutating func clearAccessList() {self._accessList = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessList: Teleport_Accesslist_V1_AccessList? = nil
}

/// DeleteAccessListRequest is the request for deleting an access list.
struct Teleport_Accesslist_V1_DeleteAccessListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the name of the access list to delete.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteAllAccessListsRequest is the request for deleting all access lists.
struct Teleport_Accesslist_V1_DeleteAllAccessListsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccessListsToReviewRequest is the request for getting access lists that the current user needs to review.
struct Teleport_Accesslist_V1_GetAccessListsToReviewRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccessListsToReviewResponse is the response for getting access lists that the current user needs to review.
struct Teleport_Accesslist_V1_GetAccessListsToReviewResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accessLists: [Teleport_Accesslist_V1_AccessList] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListMembersRequest is the request for getting paginated access list members.
struct Teleport_Accesslist_V1_ListAccessListMembersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// page_size is the size of the page to request.
  var pageSize: Int32 = 0

  /// page_token is the page token.
  var pageToken: String = String()

  /// access_list is the name of the access list that the member belongs to.
  var accessList: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListMembersResponse is the response for getting paginated access list members.
struct Teleport_Accesslist_V1_ListAccessListMembersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// members is the list of access list members.
  var members: [Teleport_Accesslist_V1_Member] = []

  /// next_page_token is the next page token.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertAccessListWithMembers is the request for upserting an access list with members.
struct Teleport_Accesslist_V1_UpsertAccessListWithMembersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the access list to upsert.
  var accessList: Teleport_Accesslist_V1_AccessList {
    get {return _accessList ?? Teleport_Accesslist_V1_AccessList()}
    set {_accessList = newValue}
  }
  /// Returns true if `accessList` has been explicitly set.
  var hasAccessList: Bool {return self._accessList != nil}
  /// Clears the value of `accessList`. Subsequent reads from it will return its default value.
  mutating func clearAccessList() {self._accessList = nil}

  /// members is the list of access list members.
  var members: [Teleport_Accesslist_V1_Member] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessList: Teleport_Accesslist_V1_AccessList? = nil
}

/// UpsertAccessListWithMembersResponse is the response for upserting an access list with members.
struct Teleport_Accesslist_V1_UpsertAccessListWithMembersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the access list that was upserted.
  var accessList: Teleport_Accesslist_V1_AccessList {
    get {return _accessList ?? Teleport_Accesslist_V1_AccessList()}
    set {_accessList = newValue}
  }
  /// Returns true if `accessList` has been explicitly set.
  var hasAccessList: Bool {return self._accessList != nil}
  /// Clears the value of `accessList`. Subsequent reads from it will return its default value.
  mutating func clearAccessList() {self._accessList = nil}

  /// members is the list of access list members that were upserted.
  var members: [Teleport_Accesslist_V1_Member] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessList: Teleport_Accesslist_V1_AccessList? = nil
}

/// GetAccessListMemberRequest is the request for retrieving an access list member.
struct Teleport_Accesslist_V1_GetAccessListMemberRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of the access list that the member belongs to.
  var accessList: String = String()

  /// member_name is the name of the user that belongs to the access list.
  var memberName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertAccessListMemberRequest is the request for upserting an access list member.
struct Teleport_Accesslist_V1_UpsertAccessListMemberRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// member is the access list member to upsert.
  var member: Teleport_Accesslist_V1_Member {
    get {return _member ?? Teleport_Accesslist_V1_Member()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  mutating func clearMember() {self._member = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _member: Teleport_Accesslist_V1_Member? = nil
}

/// DeleteAccessListMemberRequest is the request for deleting a member from an access list.
struct Teleport_Accesslist_V1_DeleteAccessListMemberRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of access list.
  var accessList: String = String()

  /// member_name is the name of the user to delete.
  var memberName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteAllAccessListMembersForAccessListRequest is the request for deleting all members from an access list.
struct Teleport_Accesslist_V1_DeleteAllAccessListMembersForAccessListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of access list.
  var accessList: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteAllAccessListMembersRequest is the request for all access list members in the backend.
struct Teleport_Accesslist_V1_DeleteAllAccessListMembersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListReviewsRequest is the request for getting paginated access list reviews for a particular access list.
struct Teleport_Accesslist_V1_ListAccessListReviewsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of the access list that we're listing reviews for.
  var accessList: String = String()

  /// page_size is the size of the page to request.
  var pageSize: Int32 = 0

  /// next_token is the page token.
  var nextToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAccessListReviewsResponse is the response for getting paginated access list rviews for a particular access list.
struct Teleport_Accesslist_V1_ListAccessListReviewsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// reviews is the list of access list reviews.
  var reviews: [Teleport_Accesslist_V1_Review] = []

  /// next_token is the next page token.
  var nextToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateAccessListReviewRequest is the request for creating an access list review.
struct Teleport_Accesslist_V1_CreateAccessListReviewRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// review is the actual review to create.
  var review: Teleport_Accesslist_V1_Review {
    get {return _review ?? Teleport_Accesslist_V1_Review()}
    set {_review = newValue}
  }
  /// Returns true if `review` has been explicitly set.
  var hasReview: Bool {return self._review != nil}
  /// Clears the value of `review`. Subsequent reads from it will return its default value.
  mutating func clearReview() {self._review = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _review: Teleport_Accesslist_V1_Review? = nil
}

/// CreateAccessListReviewResponse is the response for creating an access list review.
struct Teleport_Accesslist_V1_CreateAccessListReviewResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// review_name is the name of the review that was just created.
  var reviewName: String = String()

  /// next_audit_date is when the next audit should be done by.
  var nextAuditDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _nextAuditDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nextAuditDate = newValue}
  }
  /// Returns true if `nextAuditDate` has been explicitly set.
  var hasNextAuditDate: Bool {return self._nextAuditDate != nil}
  /// Clears the value of `nextAuditDate`. Subsequent reads from it will return its default value.
  mutating func clearNextAuditDate() {self._nextAuditDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nextAuditDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// DeleteAccessListReviewRequest is the request for deleting an access list review.
struct Teleport_Accesslist_V1_DeleteAccessListReviewRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// review_name is the name of the review to delete.
  var reviewName: String = String()

  /// access_list_name is the name of the access list to delete the review from.
  var accessListName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestPromoteRequest is the request for promoting an access request to an access list.
struct Teleport_Accesslist_V1_AccessRequestPromoteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RequestID is the unique ID of the request to be promoted.
  var requestID: String = String()

  /// AccessListName is the name of the access list to promote the request to.
  var accessListName: String = String()

  /// Reason is the access request review reason.
  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestPromoteResponse is the response for promoting an access request to an access list.
struct Teleport_Accesslist_V1_AccessRequestPromoteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AccessRequest is the updated access request.
  var accessRequest: Types_AccessRequestV3 {
    get {return _accessRequest ?? Types_AccessRequestV3()}
    set {_accessRequest = newValue}
  }
  /// Returns true if `accessRequest` has been explicitly set.
  var hasAccessRequest: Bool {return self._accessRequest != nil}
  /// Clears the value of `accessRequest`. Subsequent reads from it will return its default value.
  mutating func clearAccessRequest() {self._accessRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessRequest: Types_AccessRequestV3? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Teleport_Accesslist_V1_GetAccessListsRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_GetAccessListsResponse: @unchecked Sendable {}
extension Teleport_Accesslist_V1_ListAccessListsRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_ListAccessListsResponse: @unchecked Sendable {}
extension Teleport_Accesslist_V1_GetAccessListRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_UpsertAccessListRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_DeleteAccessListRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_DeleteAllAccessListsRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_GetAccessListsToReviewRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_GetAccessListsToReviewResponse: @unchecked Sendable {}
extension Teleport_Accesslist_V1_ListAccessListMembersRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_ListAccessListMembersResponse: @unchecked Sendable {}
extension Teleport_Accesslist_V1_UpsertAccessListWithMembersRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_UpsertAccessListWithMembersResponse: @unchecked Sendable {}
extension Teleport_Accesslist_V1_GetAccessListMemberRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_UpsertAccessListMemberRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_DeleteAccessListMemberRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_DeleteAllAccessListMembersForAccessListRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_DeleteAllAccessListMembersRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_ListAccessListReviewsRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_ListAccessListReviewsResponse: @unchecked Sendable {}
extension Teleport_Accesslist_V1_CreateAccessListReviewRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_CreateAccessListReviewResponse: @unchecked Sendable {}
extension Teleport_Accesslist_V1_DeleteAccessListReviewRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_AccessRequestPromoteRequest: @unchecked Sendable {}
extension Teleport_Accesslist_V1_AccessRequestPromoteResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.accesslist.v1"

extension Teleport_Accesslist_V1_GetAccessListsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListsRequest, rhs: Teleport_Accesslist_V1_GetAccessListsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_lists"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accessLists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessLists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListsResponse, rhs: Teleport_Accesslist_V1_GetAccessListsResponse) -> Bool {
    if lhs.accessLists != rhs.accessLists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "next_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListsRequest, rhs: Teleport_Accesslist_V1_ListAccessListsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_lists"),
    2: .standard(proto: "next_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accessLists) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessLists, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListsResponse, rhs: Teleport_Accesslist_V1_ListAccessListsResponse) -> Bool {
    if lhs.accessLists != rhs.accessLists {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListRequest, rhs: Teleport_Accesslist_V1_GetAccessListRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_UpsertAccessListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertAccessListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accessList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accessList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_UpsertAccessListRequest, rhs: Teleport_Accesslist_V1_UpsertAccessListRequest) -> Bool {
    if lhs._accessList != rhs._accessList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAccessListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAccessListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAccessListRequest, rhs: Teleport_Accesslist_V1_DeleteAccessListRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAllAccessListsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllAccessListsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAllAccessListsRequest, rhs: Teleport_Accesslist_V1_DeleteAllAccessListsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListsToReviewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListsToReviewRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListsToReviewRequest, rhs: Teleport_Accesslist_V1_GetAccessListsToReviewRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListsToReviewResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListsToReviewResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_lists"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accessLists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessLists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListsToReviewResponse, rhs: Teleport_Accesslist_V1_GetAccessListsToReviewResponse) -> Bool {
    if lhs.accessLists != rhs.accessLists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListMembersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
    3: .standard(proto: "access_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListMembersRequest, rhs: Teleport_Accesslist_V1_ListAccessListMembersRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.accessList != rhs.accessList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListMembersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListMembersResponse, rhs: Teleport_Accesslist_V1_ListAccessListMembersResponse) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_UpsertAccessListWithMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertAccessListWithMembersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accessList) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accessList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_UpsertAccessListWithMembersRequest, rhs: Teleport_Accesslist_V1_UpsertAccessListWithMembersRequest) -> Bool {
    if lhs._accessList != rhs._accessList {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_UpsertAccessListWithMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertAccessListWithMembersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accessList) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accessList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_UpsertAccessListWithMembersResponse, rhs: Teleport_Accesslist_V1_UpsertAccessListWithMembersResponse) -> Bool {
    if lhs._accessList != rhs._accessList {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_GetAccessListMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccessListMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .standard(proto: "member_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.memberName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    if !self.memberName.isEmpty {
      try visitor.visitSingularStringField(value: self.memberName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_GetAccessListMemberRequest, rhs: Teleport_Accesslist_V1_GetAccessListMemberRequest) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.memberName != rhs.memberName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_UpsertAccessListMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertAccessListMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "member"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_UpsertAccessListMemberRequest, rhs: Teleport_Accesslist_V1_UpsertAccessListMemberRequest) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAccessListMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAccessListMemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    3: .standard(proto: "member_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.memberName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    if !self.memberName.isEmpty {
      try visitor.visitSingularStringField(value: self.memberName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAccessListMemberRequest, rhs: Teleport_Accesslist_V1_DeleteAccessListMemberRequest) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.memberName != rhs.memberName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAllAccessListMembersForAccessListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllAccessListMembersForAccessListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAllAccessListMembersForAccessListRequest, rhs: Teleport_Accesslist_V1_DeleteAllAccessListMembersForAccessListRequest) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAllAccessListMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllAccessListMembersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAllAccessListMembersRequest, rhs: Teleport_Accesslist_V1_DeleteAllAccessListMembersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListReviewsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListReviewsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "next_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListReviewsRequest, rhs: Teleport_Accesslist_V1_ListAccessListReviewsRequest) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ListAccessListReviewsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAccessListReviewsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reviews"),
    2: .standard(proto: "next_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.reviews) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reviews.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reviews, fieldNumber: 1)
    }
    if !self.nextToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ListAccessListReviewsResponse, rhs: Teleport_Accesslist_V1_ListAccessListReviewsResponse) -> Bool {
    if lhs.reviews != rhs.reviews {return false}
    if lhs.nextToken != rhs.nextToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_CreateAccessListReviewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAccessListReviewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "review"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._review) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._review {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_CreateAccessListReviewRequest, rhs: Teleport_Accesslist_V1_CreateAccessListReviewRequest) -> Bool {
    if lhs._review != rhs._review {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_CreateAccessListReviewResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAccessListReviewResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "review_name"),
    2: .standard(proto: "next_audit_date"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reviewName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nextAuditDate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.reviewName.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewName, fieldNumber: 1)
    }
    try { if let v = self._nextAuditDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_CreateAccessListReviewResponse, rhs: Teleport_Accesslist_V1_CreateAccessListReviewResponse) -> Bool {
    if lhs.reviewName != rhs.reviewName {return false}
    if lhs._nextAuditDate != rhs._nextAuditDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_DeleteAccessListReviewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAccessListReviewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "review_name"),
    2: .standard(proto: "access_list_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reviewName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessListName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reviewName.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewName, fieldNumber: 1)
    }
    if !self.accessListName.isEmpty {
      try visitor.visitSingularStringField(value: self.accessListName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_DeleteAccessListReviewRequest, rhs: Teleport_Accesslist_V1_DeleteAccessListReviewRequest) -> Bool {
    if lhs.reviewName != rhs.reviewName {return false}
    if lhs.accessListName != rhs.accessListName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessRequestPromoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestPromoteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "access_list_name"),
    3: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessListName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.accessListName.isEmpty {
      try visitor.visitSingularStringField(value: self.accessListName, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessRequestPromoteRequest, rhs: Teleport_Accesslist_V1_AccessRequestPromoteRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.accessListName != rhs.accessListName {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessRequestPromoteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestPromoteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accessRequest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accessRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessRequestPromoteResponse, rhs: Teleport_Accesslist_V1_AccessRequestPromoteResponse) -> Bool {
    if lhs._accessRequest != rhs._accessRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
