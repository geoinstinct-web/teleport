// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/accesslist/v1/accesslist.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ReviewFrequency is the frequency of reviews.
enum Teleport_Accesslist_V1_ReviewFrequency: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case oneMonth // = 1
  case threeMonths // = 3
  case sixMonths // = 6
  case oneYear // = 12
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .oneMonth
    case 3: self = .threeMonths
    case 6: self = .sixMonths
    case 12: self = .oneYear
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .oneMonth: return 1
    case .threeMonths: return 3
    case .sixMonths: return 6
    case .oneYear: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Teleport_Accesslist_V1_ReviewFrequency: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Accesslist_V1_ReviewFrequency] = [
    .unspecified,
    .oneMonth,
    .threeMonths,
    .sixMonths,
    .oneYear,
  ]
}

#endif  // swift(>=4.2)

/// ReviewDayOfMonth is the day of month that reviews will repeat on.
enum Teleport_Accesslist_V1_ReviewDayOfMonth: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case first // = 1
  case fifteenth // = 15
  case last // = 31
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .first
    case 15: self = .fifteenth
    case 31: self = .last
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .first: return 1
    case .fifteenth: return 15
    case .last: return 31
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Teleport_Accesslist_V1_ReviewDayOfMonth: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Accesslist_V1_ReviewDayOfMonth] = [
    .unspecified,
    .first,
    .fifteenth,
    .last,
  ]
}

#endif  // swift(>=4.2)

/// IneligibleStatus describes how the user is ineligible.
enum Teleport_Accesslist_V1_IneligibleStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// INELIGIBLE_STATUS_UNSPECIFIED means eligiblity is unknown.
  case unspecified // = 0

  /// INELIGIBLE_STATUS_ELIGIBLE means checks were done and user met all requirements.
  case eligible // = 1

  /// INELIGIBLE_STATUS_USER_NOT_EXIST means user was not found in backend.
  case userNotExist // = 2

  /// INELIGIBLE_STATUS_MISSING_REQUIREMENTS means user is missing some requirements
  /// defined by AccessListRequires (fields can be either ownership_requires
  /// or membership_requires)
  case missingRequirements // = 3

  /// INELIGIBLE_STATUS_EXPIRED means user is expired.
  /// Only applicable to members.
  case expired // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .eligible
    case 2: self = .userNotExist
    case 3: self = .missingRequirements
    case 4: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .eligible: return 1
    case .userNotExist: return 2
    case .missingRequirements: return 3
    case .expired: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Teleport_Accesslist_V1_IneligibleStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Accesslist_V1_IneligibleStatus] = [
    .unspecified,
    .eligible,
    .userNotExist,
    .missingRequirements,
    .expired,
  ]
}

#endif  // swift(>=4.2)

/// AccessList describes the basic building block of access grants, which are
/// similar to access requests but for longer lived permissions that need to be
/// regularly audited.
struct Teleport_Accesslist_V1_AccessList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// header is the header for the resource.
  var header: Teleport_Header_V1_ResourceHeader {
    get {return _storage._header ?? Teleport_Header_V1_ResourceHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// spec is the specification for the access list.
  var spec: Teleport_Accesslist_V1_AccessListSpec {
    get {return _storage._spec ?? Teleport_Accesslist_V1_AccessListSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AccessListSpec is the specification for an access list.
struct Teleport_Accesslist_V1_AccessListSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// description is an optional plaintext description of the access list.
  var description_p: String = String()

  /// owners is a list of owners of the access list.
  var owners: [Teleport_Accesslist_V1_AccessListOwner] = []

  /// audit describes the frequency that this access list must be audited.
  var audit: Teleport_Accesslist_V1_AccessListAudit {
    get {return _audit ?? Teleport_Accesslist_V1_AccessListAudit()}
    set {_audit = newValue}
  }
  /// Returns true if `audit` has been explicitly set.
  var hasAudit: Bool {return self._audit != nil}
  /// Clears the value of `audit`. Subsequent reads from it will return its default value.
  mutating func clearAudit() {self._audit = nil}

  /// membership_requires describes the requirements for a user to be a member of the access list.
  /// For a membership to an access list to be effective, the user must meet the requirements of
  /// Membership_requires and must be in the members list.
  var membershipRequires: Teleport_Accesslist_V1_AccessListRequires {
    get {return _membershipRequires ?? Teleport_Accesslist_V1_AccessListRequires()}
    set {_membershipRequires = newValue}
  }
  /// Returns true if `membershipRequires` has been explicitly set.
  var hasMembershipRequires: Bool {return self._membershipRequires != nil}
  /// Clears the value of `membershipRequires`. Subsequent reads from it will return its default value.
  mutating func clearMembershipRequires() {self._membershipRequires = nil}

  /// ownership_requires describes the requirements for a user to be an owner of the access list.
  /// For ownership of an access list to be effective, the user must meet the requirements of
  /// ownership_requires and must be in the owners list.
  var ownershipRequires: Teleport_Accesslist_V1_AccessListRequires {
    get {return _ownershipRequires ?? Teleport_Accesslist_V1_AccessListRequires()}
    set {_ownershipRequires = newValue}
  }
  /// Returns true if `ownershipRequires` has been explicitly set.
  var hasOwnershipRequires: Bool {return self._ownershipRequires != nil}
  /// Clears the value of `ownershipRequires`. Subsequent reads from it will return its default value.
  mutating func clearOwnershipRequires() {self._ownershipRequires = nil}

  /// grants describes the access granted by membership to this access list.
  var grants: Teleport_Accesslist_V1_AccessListGrants {
    get {return _grants ?? Teleport_Accesslist_V1_AccessListGrants()}
    set {_grants = newValue}
  }
  /// Returns true if `grants` has been explicitly set.
  var hasGrants: Bool {return self._grants != nil}
  /// Clears the value of `grants`. Subsequent reads from it will return its default value.
  mutating func clearGrants() {self._grants = nil}

  /// title is a plaintext short description of the access list.
  var title: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _audit: Teleport_Accesslist_V1_AccessListAudit? = nil
  fileprivate var _membershipRequires: Teleport_Accesslist_V1_AccessListRequires? = nil
  fileprivate var _ownershipRequires: Teleport_Accesslist_V1_AccessListRequires? = nil
  fileprivate var _grants: Teleport_Accesslist_V1_AccessListGrants? = nil
}

/// AccessListOwner is an owner of an access list.
struct Teleport_Accesslist_V1_AccessListOwner {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the username of the owner.
  var name: String = String()

  /// description is the plaintext description of the owner and why they are an owner.
  var description_p: String = String()

  /// ineligible_status describes if this owner is eligible or not
  /// and if not, describes how they're lacking eligibility.
  var ineligibleStatus: Teleport_Accesslist_V1_IneligibleStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessListAudit describes the audit configuration for an access list.
struct Teleport_Accesslist_V1_AccessListAudit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// next_audit_date is when the next audit date should be done by.
  var nextAuditDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _nextAuditDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nextAuditDate = newValue}
  }
  /// Returns true if `nextAuditDate` has been explicitly set.
  var hasNextAuditDate: Bool {return self._nextAuditDate != nil}
  /// Clears the value of `nextAuditDate`. Subsequent reads from it will return its default value.
  mutating func clearNextAuditDate() {self._nextAuditDate = nil}

  /// recurrence is the recurrence definition
  var recurrence: Teleport_Accesslist_V1_Recurrence {
    get {return _recurrence ?? Teleport_Accesslist_V1_Recurrence()}
    set {_recurrence = newValue}
  }
  /// Returns true if `recurrence` has been explicitly set.
  var hasRecurrence: Bool {return self._recurrence != nil}
  /// Clears the value of `recurrence`. Subsequent reads from it will return its default value.
  mutating func clearRecurrence() {self._recurrence = nil}

  /// notifications is the configuration for notifying users.
  var notifications: Teleport_Accesslist_V1_Notifications {
    get {return _notifications ?? Teleport_Accesslist_V1_Notifications()}
    set {_notifications = newValue}
  }
  /// Returns true if `notifications` has been explicitly set.
  var hasNotifications: Bool {return self._notifications != nil}
  /// Clears the value of `notifications`. Subsequent reads from it will return its default value.
  mutating func clearNotifications() {self._notifications = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nextAuditDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _recurrence: Teleport_Accesslist_V1_Recurrence? = nil
  fileprivate var _notifications: Teleport_Accesslist_V1_Notifications? = nil
}

/// Recurrence is the definition for when reviews will be scheduled.
struct Teleport_Accesslist_V1_Recurrence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// frequency is the frequency of reviews.
  var frequency: Teleport_Accesslist_V1_ReviewFrequency = .unspecified

  /// day_of_month is the day of month that reviews will be scheduled on.
  var dayOfMonth: Teleport_Accesslist_V1_ReviewDayOfMonth = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Notifications contains the configuration for notifying users of a nearing next audit date.
struct Teleport_Accesslist_V1_Notifications {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// start specifies when to start notifying users that the next audit date is coming up.
  var start: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _start ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _start: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// AccessListRequires describes a requirement section for an access list. A user must
/// meet the following criteria to obtain the specific access to the list.
struct Teleport_Accesslist_V1_AccessListRequires {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// roles are the user roles that must be present for the user to obtain access.
  var roles: [String] = []

  /// traits are the traits that must be present for the user to obtain access.
  var traits: [Teleport_Trait_V1_Trait] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessListGrants describes what access is granted by membership to the access list.
struct Teleport_Accesslist_V1_AccessListGrants {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// roles are the roles that are granted to users who are members of the access list.
  var roles: [String] = []

  /// traits are the traits that are granted to users who are members of the access list.
  var traits: [Teleport_Trait_V1_Trait] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Member describes a member of an access list.
struct Teleport_Accesslist_V1_Member {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// header is the header for the resource.
  var header: Teleport_Header_V1_ResourceHeader {
    get {return _storage._header ?? Teleport_Header_V1_ResourceHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// spec is the specification for the access list member.
  var spec: Teleport_Accesslist_V1_MemberSpec {
    get {return _storage._spec ?? Teleport_Accesslist_V1_MemberSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MemberSpec is the specification for an access list member.
struct Teleport_Accesslist_V1_MemberSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// associated access list
  var accessList: String = String()

  /// name is the name of the member of the access list.
  var name: String = String()

  /// joined is when the user joined the access list.
  var joined: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _joined ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_joined = newValue}
  }
  /// Returns true if `joined` has been explicitly set.
  var hasJoined: Bool {return self._joined != nil}
  /// Clears the value of `joined`. Subsequent reads from it will return its default value.
  mutating func clearJoined() {self._joined = nil}

  /// expires is when the user's membership to the access list expires.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// reason is the reason this user was added to the access list.
  var reason: String = String()

  /// added_by is the user that added this user to the access list.
  var addedBy: String = String()

  /// ineligible_status describes if this member is eligible or not
  /// and if not, describes how they're lacking eligibility.
  var ineligibleStatus: Teleport_Accesslist_V1_IneligibleStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _joined: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Review is a review of an access list.
struct Teleport_Accesslist_V1_Review {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// header is the header for the resource.
  var header: Teleport_Header_V1_ResourceHeader {
    get {return _storage._header ?? Teleport_Header_V1_ResourceHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// spec is the specification for the access list review.
  var spec: Teleport_Accesslist_V1_ReviewSpec {
    get {return _storage._spec ?? Teleport_Accesslist_V1_ReviewSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReviewSpec is the specification for an access list review.
struct Teleport_Accesslist_V1_ReviewSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// access_list is the name of the access list that this review is for.
  var accessList: String = String()

  /// reviewers are the users who performed the review.
  var reviewers: [String] = []

  /// review_date is the date that this review was created.
  var reviewDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _reviewDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_reviewDate = newValue}
  }
  /// Returns true if `reviewDate` has been explicitly set.
  var hasReviewDate: Bool {return self._reviewDate != nil}
  /// Clears the value of `reviewDate`. Subsequent reads from it will return its default value.
  mutating func clearReviewDate() {self._reviewDate = nil}

  /// notes is an optional plaintext attached to the review that can be used by the review for arbitrary
  /// note taking on the review.
  var notes: String = String()

  /// changes are the changes made as part of the review.
  var changes: Teleport_Accesslist_V1_ReviewChanges {
    get {return _changes ?? Teleport_Accesslist_V1_ReviewChanges()}
    set {_changes = newValue}
  }
  /// Returns true if `changes` has been explicitly set.
  var hasChanges: Bool {return self._changes != nil}
  /// Clears the value of `changes`. Subsequent reads from it will return its default value.
  mutating func clearChanges() {self._changes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reviewDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _changes: Teleport_Accesslist_V1_ReviewChanges? = nil
}

/// ReviewChanges are the changes that were made as part of the review.
struct Teleport_Accesslist_V1_ReviewChanges {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// membership_requirements_changed is populated if the requirements were changed as part of this review.
  var membershipRequirementsChanged: Teleport_Accesslist_V1_AccessListRequires {
    get {return _membershipRequirementsChanged ?? Teleport_Accesslist_V1_AccessListRequires()}
    set {_membershipRequirementsChanged = newValue}
  }
  /// Returns true if `membershipRequirementsChanged` has been explicitly set.
  var hasMembershipRequirementsChanged: Bool {return self._membershipRequirementsChanged != nil}
  /// Clears the value of `membershipRequirementsChanged`. Subsequent reads from it will return its default value.
  mutating func clearMembershipRequirementsChanged() {self._membershipRequirementsChanged = nil}

  /// removed_members contains the members that were removed as part of this review.
  var removedMembers: [String] = []

  /// review_frequency_changed is populated if the review frequency has changed.
  var reviewFrequencyChanged: Teleport_Accesslist_V1_ReviewFrequency = .unspecified

  /// review_day_of_month_changed is populated if the review day of month has changed.
  var reviewDayOfMonthChanged: Teleport_Accesslist_V1_ReviewDayOfMonth = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _membershipRequirementsChanged: Teleport_Accesslist_V1_AccessListRequires? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Teleport_Accesslist_V1_ReviewFrequency: @unchecked Sendable {}
extension Teleport_Accesslist_V1_ReviewDayOfMonth: @unchecked Sendable {}
extension Teleport_Accesslist_V1_IneligibleStatus: @unchecked Sendable {}
extension Teleport_Accesslist_V1_AccessList: @unchecked Sendable {}
extension Teleport_Accesslist_V1_AccessListSpec: @unchecked Sendable {}
extension Teleport_Accesslist_V1_AccessListOwner: @unchecked Sendable {}
extension Teleport_Accesslist_V1_AccessListAudit: @unchecked Sendable {}
extension Teleport_Accesslist_V1_Recurrence: @unchecked Sendable {}
extension Teleport_Accesslist_V1_Notifications: @unchecked Sendable {}
extension Teleport_Accesslist_V1_AccessListRequires: @unchecked Sendable {}
extension Teleport_Accesslist_V1_AccessListGrants: @unchecked Sendable {}
extension Teleport_Accesslist_V1_Member: @unchecked Sendable {}
extension Teleport_Accesslist_V1_MemberSpec: @unchecked Sendable {}
extension Teleport_Accesslist_V1_Review: @unchecked Sendable {}
extension Teleport_Accesslist_V1_ReviewSpec: @unchecked Sendable {}
extension Teleport_Accesslist_V1_ReviewChanges: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.accesslist.v1"

extension Teleport_Accesslist_V1_ReviewFrequency: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REVIEW_FREQUENCY_UNSPECIFIED"),
    1: .same(proto: "REVIEW_FREQUENCY_ONE_MONTH"),
    3: .same(proto: "REVIEW_FREQUENCY_THREE_MONTHS"),
    6: .same(proto: "REVIEW_FREQUENCY_SIX_MONTHS"),
    12: .same(proto: "REVIEW_FREQUENCY_ONE_YEAR"),
  ]
}

extension Teleport_Accesslist_V1_ReviewDayOfMonth: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REVIEW_DAY_OF_MONTH_UNSPECIFIED"),
    1: .same(proto: "REVIEW_DAY_OF_MONTH_FIRST"),
    15: .same(proto: "REVIEW_DAY_OF_MONTH_FIFTEENTH"),
    31: .same(proto: "REVIEW_DAY_OF_MONTH_LAST"),
  ]
}

extension Teleport_Accesslist_V1_IneligibleStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INELIGIBLE_STATUS_UNSPECIFIED"),
    1: .same(proto: "INELIGIBLE_STATUS_ELIGIBLE"),
    2: .same(proto: "INELIGIBLE_STATUS_USER_NOT_EXIST"),
    3: .same(proto: "INELIGIBLE_STATUS_MISSING_REQUIREMENTS"),
    4: .same(proto: "INELIGIBLE_STATUS_EXPIRED"),
  ]
}

extension Teleport_Accesslist_V1_AccessList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _header: Teleport_Header_V1_ResourceHeader? = nil
    var _spec: Teleport_Accesslist_V1_AccessListSpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessList, rhs: Teleport_Accesslist_V1_AccessList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "owners"),
    3: .same(proto: "audit"),
    4: .standard(proto: "membership_requires"),
    5: .standard(proto: "ownership_requires"),
    6: .same(proto: "grants"),
    8: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.owners) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._audit) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._membershipRequires) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._ownershipRequires) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._grants) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    if !self.owners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.owners, fieldNumber: 2)
    }
    try { if let v = self._audit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._membershipRequires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._ownershipRequires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._grants {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListSpec, rhs: Teleport_Accesslist_V1_AccessListSpec) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.owners != rhs.owners {return false}
    if lhs._audit != rhs._audit {return false}
    if lhs._membershipRequires != rhs._membershipRequires {return false}
    if lhs._ownershipRequires != rhs._ownershipRequires {return false}
    if lhs._grants != rhs._grants {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListOwner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListOwner"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "ineligible_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.ineligibleStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.ineligibleStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.ineligibleStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListOwner, rhs: Teleport_Accesslist_V1_AccessListOwner) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ineligibleStatus != rhs.ineligibleStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListAudit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListAudit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "next_audit_date"),
    3: .same(proto: "recurrence"),
    4: .same(proto: "notifications"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nextAuditDate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._recurrence) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._notifications) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nextAuditDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._recurrence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._notifications {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListAudit, rhs: Teleport_Accesslist_V1_AccessListAudit) -> Bool {
    if lhs._nextAuditDate != rhs._nextAuditDate {return false}
    if lhs._recurrence != rhs._recurrence {return false}
    if lhs._notifications != rhs._notifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_Recurrence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Recurrence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frequency"),
    2: .standard(proto: "day_of_month"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.frequency) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dayOfMonth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frequency != .unspecified {
      try visitor.visitSingularEnumField(value: self.frequency, fieldNumber: 1)
    }
    if self.dayOfMonth != .unspecified {
      try visitor.visitSingularEnumField(value: self.dayOfMonth, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_Recurrence, rhs: Teleport_Accesslist_V1_Recurrence) -> Bool {
    if lhs.frequency != rhs.frequency {return false}
    if lhs.dayOfMonth != rhs.dayOfMonth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_Notifications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Notifications"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_Notifications, rhs: Teleport_Accesslist_V1_Notifications) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListRequires: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListRequires"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
    2: .same(proto: "traits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.traits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    if !self.traits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.traits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListRequires, rhs: Teleport_Accesslist_V1_AccessListRequires) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.traits != rhs.traits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_AccessListGrants: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListGrants"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
    2: .same(proto: "traits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.traits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    if !self.traits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.traits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_AccessListGrants, rhs: Teleport_Accesslist_V1_AccessListGrants) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.traits != rhs.traits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Member"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _header: Teleport_Header_V1_ResourceHeader? = nil
    var _spec: Teleport_Accesslist_V1_MemberSpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_Member, rhs: Teleport_Accesslist_V1_Member) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_MemberSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MemberSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .same(proto: "name"),
    3: .same(proto: "joined"),
    4: .same(proto: "expires"),
    5: .same(proto: "reason"),
    6: .standard(proto: "added_by"),
    7: .standard(proto: "ineligible_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._joined) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.addedBy) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.ineligibleStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._joined {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 5)
    }
    if !self.addedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.addedBy, fieldNumber: 6)
    }
    if self.ineligibleStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.ineligibleStatus, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_MemberSpec, rhs: Teleport_Accesslist_V1_MemberSpec) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.name != rhs.name {return false}
    if lhs._joined != rhs._joined {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.addedBy != rhs.addedBy {return false}
    if lhs.ineligibleStatus != rhs.ineligibleStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_Review: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Review"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "spec"),
  ]

  fileprivate class _StorageClass {
    var _header: Teleport_Header_V1_ResourceHeader? = nil
    var _spec: Teleport_Accesslist_V1_ReviewSpec? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_Review, rhs: Teleport_Accesslist_V1_Review) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ReviewSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReviewSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_list"),
    2: .same(proto: "reviewers"),
    3: .standard(proto: "review_date"),
    4: .same(proto: "notes"),
    5: .same(proto: "changes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessList) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.reviewers) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._reviewDate) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._changes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accessList.isEmpty {
      try visitor.visitSingularStringField(value: self.accessList, fieldNumber: 1)
    }
    if !self.reviewers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reviewers, fieldNumber: 2)
    }
    try { if let v = self._reviewDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 4)
    }
    try { if let v = self._changes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ReviewSpec, rhs: Teleport_Accesslist_V1_ReviewSpec) -> Bool {
    if lhs.accessList != rhs.accessList {return false}
    if lhs.reviewers != rhs.reviewers {return false}
    if lhs._reviewDate != rhs._reviewDate {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs._changes != rhs._changes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Accesslist_V1_ReviewChanges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReviewChanges"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "membership_requirements_changed"),
    3: .standard(proto: "removed_members"),
    4: .standard(proto: "review_frequency_changed"),
    5: .standard(proto: "review_day_of_month_changed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._membershipRequirementsChanged) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.removedMembers) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.reviewFrequencyChanged) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.reviewDayOfMonthChanged) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._membershipRequirementsChanged {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.removedMembers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removedMembers, fieldNumber: 3)
    }
    if self.reviewFrequencyChanged != .unspecified {
      try visitor.visitSingularEnumField(value: self.reviewFrequencyChanged, fieldNumber: 4)
    }
    if self.reviewDayOfMonthChanged != .unspecified {
      try visitor.visitSingularEnumField(value: self.reviewDayOfMonthChanged, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Accesslist_V1_ReviewChanges, rhs: Teleport_Accesslist_V1_ReviewChanges) -> Bool {
    if lhs._membershipRequirementsChanged != rhs._membershipRequirementsChanged {return false}
    if lhs.removedMembers != rhs.removedMembers {return false}
    if lhs.reviewFrequencyChanged != rhs.reviewFrequencyChanged {return false}
    if lhs.reviewDayOfMonthChanged != rhs.reviewDayOfMonthChanged {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
