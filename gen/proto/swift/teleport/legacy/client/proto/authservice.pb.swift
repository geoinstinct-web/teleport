// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/legacy/client/proto/authservice.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2021-2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// DeviceType describes supported MFA device types.
enum Proto_DeviceType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// TOTP is a Time-based One-Time Password device.
  case totp // = 1

  /// Webauthn is a device compatible with the Web Authentication
  /// specification, registered via Webauthn APIs.
  /// Supports various kinds of devices: U2F/CTAP1, CTAP2, platform
  /// authenticators (Touch ID), etc.
  case webauthn // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .totp
    case 3: self = .webauthn
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .totp: return 1
    case .webauthn: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_DeviceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_DeviceType] = [
    .unspecified,
    .totp,
    .webauthn,
  ]
}

#endif  // swift(>=4.2)

enum Proto_DeviceUsage: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// Device intended for MFA use, but not for passwordless.
  /// Allows both FIDO and FIDO2 devices.
  /// Resident keys not required.
  case mfa // = 1

  /// Device intended for both MFA and passwordless.
  /// Requires a FIDO2 device and takes a resident key slot.
  case passwordless // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .mfa
    case 2: self = .passwordless
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .mfa: return 1
    case .passwordless: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_DeviceUsage: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_DeviceUsage] = [
    .unspecified,
    .mfa,
    .passwordless,
  ]
}

#endif  // swift(>=4.2)

/// MFARequired indicates if MFA is required to access a
/// resource.
enum Proto_MFARequired: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Indicates the client/server are either old and don't support
  /// checking if MFA is required during the ceremony or that there
  /// was a catastrophic error checking RBAC to determine if completing
  /// an MFA ceremony will grant access to a resource.
  case unspecified // = 0

  /// Completing an MFA ceremony will grant access to a resource.
  case yes // = 1

  /// Completing an MFA ceremony will not grant access to a resource.
  case no // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .yes
    case 2: self = .no
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .yes: return 1
    case .no: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_MFARequired: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_MFARequired] = [
    .unspecified,
    .yes,
    .no,
  ]
}

#endif  // swift(>=4.2)

/// Order specifies any ordering of some objects as returned in regards to some aspect
/// of said objects which may be trivially ordered such as a timestamp.
enum Proto_Order: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case descending // = 0
  case ascending // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .descending
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .descending
    case 1: self = .ascending
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .descending: return 0
    case .ascending: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Order: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Order] = [
    .descending,
    .ascending,
  ]
}

#endif  // swift(>=4.2)

/// LabelUpdateKind is the type of service to update labels for.
enum Proto_LabelUpdateKind: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// SSHServer is a label update for an SSH server.
  case sshserver // = 0

  /// SSHServerCloudLabels is a label update for an SSH server coming from a
  /// cloud provider.
  case sshserverCloudLabels // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .sshserver
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sshserver
    case 1: self = .sshserverCloudLabels
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sshserver: return 0
    case .sshserverCloudLabels: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_LabelUpdateKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_LabelUpdateKind] = [
    .sshserver,
    .sshserverCloudLabels,
  ]
}

#endif  // swift(>=4.2)

/// Watch specifies watch parameters
struct Proto_Watch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kinds specifies object kinds to watch
  var kinds: [Types_WatchKind] = []

  var allowPartialSuccess: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// HostCertsRequest specifies certificate-generation parameters
/// for a server.
struct Proto_HostCertsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HostID is a unique ID of the host.
  var hostID: String {
    get {return _storage._hostID}
    set {_uniqueStorage()._hostID = newValue}
  }

  /// NodeName is a user-friendly host name.
  var nodeName: String {
    get {return _storage._nodeName}
    set {_uniqueStorage()._nodeName = newValue}
  }

  /// Role is a system role assigned to the host.
  var role: String {
    get {return _storage._role}
    set {_uniqueStorage()._role = newValue}
  }

  /// AdditionalPrincipals is a list of additional principals
  /// to include in OpenSSH and X509 certificates
  var additionalPrincipals: [String] {
    get {return _storage._additionalPrincipals}
    set {_uniqueStorage()._additionalPrincipals = newValue}
  }

  /// DNSNames is a list of DNS names to include in x509 certificates.
  var dnsnames: [String] {
    get {return _storage._dnsnames}
    set {_uniqueStorage()._dnsnames = newValue}
  }

  /// PublicTLSKey is a PEM encoded public key, which the auth server will use
  /// to create a signed TLS certificate. This field is required.
  var publicTlskey: Data {
    get {return _storage._publicTlskey}
    set {_uniqueStorage()._publicTlskey = newValue}
  }

  /// PublicSSHKey is a SSH encoded public key, which the auth server will use
  /// to create a signed SSH certificate. This field is required.
  var publicSshkey: Data {
    get {return _storage._publicSshkey}
    set {_uniqueStorage()._publicSshkey = newValue}
  }

  /// RemoteAddr is the IP address of the remote host requesting a certificate.
  /// RemoteAddr is used to replace 0.0.0.0 in the list of additional principals.
  var remoteAddr: String {
    get {return _storage._remoteAddr}
    set {_uniqueStorage()._remoteAddr = newValue}
  }

  /// Rotation allows clients to send the certificate authority rotation state
  /// expected by the client so that auth servers can avoid the situation when
  /// clients request certs assuming one state and auth servers issue another.
  var rotation: Types_Rotation {
    get {return _storage._rotation ?? Types_Rotation()}
    set {_uniqueStorage()._rotation = newValue}
  }
  /// Returns true if `rotation` has been explicitly set.
  var hasRotation: Bool {return _storage._rotation != nil}
  /// Clears the value of `rotation`. Subsequent reads from it will return its default value.
  mutating func clearRotation() {_uniqueStorage()._rotation = nil}

  /// NoCache is argument that only local callers can supply to bypass cache
  var noCache: Bool {
    get {return _storage._noCache}
    set {_uniqueStorage()._noCache = newValue}
  }

  /// SystemRoles is a list of system roles held by the host. Most host certs are
  /// single-role and only specify the Role field. The SystemRoles field is only
  /// currently used on Instance certs, which need to express all roles held by
  /// the instance.
  var systemRoles: [String] {
    get {return _storage._systemRoles}
    set {_uniqueStorage()._systemRoles = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OpenSSHCertRequest specifies certificate-generation parameters
/// for a certificates used to connect to Agentless nodes.
struct Proto_OpenSSHCertRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PublicKey is the public key to sign.
  var publicKey: Data = Data()

  /// TTL is the duration the certificate will be valid for.
  var ttl: Int64 = 0

  /// Cluster is the Teleport cluster name the target node is connected to.
  var cluster: String = String()

  /// User is the Teleport user the certificate will be generated for.
  var user: Types_UserV2 {
    get {return _user ?? Types_UserV2()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {self._user = nil}

  /// Roles are the roles of the Teleport user the certificate will be
  /// generated for.
  var roles: [Types_RoleV6] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _user: Types_UserV2? = nil
}

/// OpenSSHCert is a SSH certificate signed by OpenSSH CA.
struct Proto_OpenSSHCert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cert: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UserCertRequest specifies certificate-generation parameters
/// for a user.
struct Proto_UserCertsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PublicKey is a public key to be signed.
  var publicKey: Data {
    get {return _storage._publicKey}
    set {_uniqueStorage()._publicKey = newValue}
  }

  /// Username of key owner.
  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  /// Expires is a desired time of the expiry of the certificate, could
  /// be adjusted based on the permissions
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return _storage._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {_uniqueStorage()._expires = nil}

  /// Format encodes the desired SSH Certificate format (either old ssh
  /// compatibility
  /// format to remove some metadata causing trouble with old SSH servers)
  /// or standard SSH cert format with custom extensions
  var format: String {
    get {return _storage._format}
    set {_uniqueStorage()._format = newValue}
  }

  /// RouteToCluster is an optional cluster name to add to the certificate,
  /// so that requests originating with this certificate will be redirected
  /// to this cluster
  var routeToCluster: String {
    get {return _storage._routeToCluster}
    set {_uniqueStorage()._routeToCluster = newValue}
  }

  /// AccessRequests is an optional list of request IDs indicating requests whose
  /// escalated privileges should be added to the certificate.
  var accessRequests: [String] {
    get {return _storage._accessRequests}
    set {_uniqueStorage()._accessRequests = newValue}
  }

  /// KubernetesCluster specifies the target kubernetes cluster for TLS
  /// identities. This can be empty on older Teleport clients.
  var kubernetesCluster: String {
    get {return _storage._kubernetesCluster}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }

  /// RouteToDatabase specifies the target database proxy name to encode into
  /// certificate so database client requests are routed appropriately.
  var routeToDatabase: Proto_RouteToDatabase {
    get {return _storage._routeToDatabase ?? Proto_RouteToDatabase()}
    set {_uniqueStorage()._routeToDatabase = newValue}
  }
  /// Returns true if `routeToDatabase` has been explicitly set.
  var hasRouteToDatabase: Bool {return _storage._routeToDatabase != nil}
  /// Clears the value of `routeToDatabase`. Subsequent reads from it will return its default value.
  mutating func clearRouteToDatabase() {_uniqueStorage()._routeToDatabase = nil}

  /// NodeName is the name of the SSH node that this user certificate will be
  /// scoped to.
  var nodeName: String {
    get {return _storage._nodeName}
    set {_uniqueStorage()._nodeName = newValue}
  }

  /// CertUsage limits the resulting user certificate to a single protocol.
  var usage: Proto_UserCertsRequest.CertUsage {
    get {return _storage._usage}
    set {_uniqueStorage()._usage = newValue}
  }

  /// RouteToApp specifies application to issue certificate for.
  var routeToApp: Proto_RouteToApp {
    get {return _storage._routeToApp ?? Proto_RouteToApp()}
    set {_uniqueStorage()._routeToApp = newValue}
  }
  /// Returns true if `routeToApp` has been explicitly set.
  var hasRouteToApp: Bool {return _storage._routeToApp != nil}
  /// Clears the value of `routeToApp`. Subsequent reads from it will return its default value.
  mutating func clearRouteToApp() {_uniqueStorage()._routeToApp = nil}

  /// RoleRequests specify an alternative set of named roles to apply to the
  /// certificate, assuming the requestor is allowed to impersonate said roles
  /// directly. An empty set of requests returns the user's normal set of
  /// roles.
  var roleRequests: [String] {
    get {return _storage._roleRequests}
    set {_uniqueStorage()._roleRequests = newValue}
  }

  /// RouteToWindowsDesktop specifies the target windows desktop name to encode into
  /// certificate so windows desktop client requests are routed appropriately.
  var routeToWindowsDesktop: Proto_RouteToWindowsDesktop {
    get {return _storage._routeToWindowsDesktop ?? Proto_RouteToWindowsDesktop()}
    set {_uniqueStorage()._routeToWindowsDesktop = newValue}
  }
  /// Returns true if `routeToWindowsDesktop` has been explicitly set.
  var hasRouteToWindowsDesktop: Bool {return _storage._routeToWindowsDesktop != nil}
  /// Clears the value of `routeToWindowsDesktop`. Subsequent reads from it will return its default value.
  mutating func clearRouteToWindowsDesktop() {_uniqueStorage()._routeToWindowsDesktop = nil}

  /// UseRoleRequests is used to ensure a certificate request is intended to
  /// use role impersonation, even if the list of role requests is empty.
  var useRoleRequests: Bool {
    get {return _storage._useRoleRequests}
    set {_uniqueStorage()._useRoleRequests = newValue}
  }

  /// DropAccessRequests is an optional list of request IDs indicating requests
  /// whose escalated privileges should be removed from the certificate.
  /// IDs pointing at non-existent requests are ignored.
  ///
  /// If present, the roles and traits in the generated cert will be based on
  /// the state of the user resource on the backend, active requests (not being
  /// dropped) and new access requests specified through AccessRequests (if any).
  ///
  /// This means that technically sending UserCertsRequest with bogus IDs in
  /// DropAccessRequests can be used to refresh the role list based on backend
  /// state. A better long-term solution would be to add a dedicated field for
  /// this to avoid sending bogus IDs.
  var dropAccessRequests: [String] {
    get {return _storage._dropAccessRequests}
    set {_uniqueStorage()._dropAccessRequests = newValue}
  }

  /// ConnectionDiagnosticID is the ID of the ConnectionDiagnostic resource we should use to add
  /// traces as we pass certain checkpoints.
  var connectionDiagnosticID: String {
    get {return _storage._connectionDiagnosticID}
    set {_uniqueStorage()._connectionDiagnosticID = newValue}
  }

  /// RequesterName identifies who sent the request.
  var requesterName: Proto_UserCertsRequest.Requester {
    get {return _storage._requesterName}
    set {_uniqueStorage()._requesterName = newValue}
  }

  /// MFAResponse is a response to a challenge from a user's MFA device.
  /// An optional field, that when provided, the response will be validated
  /// and the ID of the validated MFA device will be stored in the certificate.
  var mfaresponse: Proto_MFAAuthenticateResponse {
    get {return _storage._mfaresponse ?? Proto_MFAAuthenticateResponse()}
    set {_uniqueStorage()._mfaresponse = newValue}
  }
  /// Returns true if `mfaresponse` has been explicitly set.
  var hasMfaresponse: Bool {return _storage._mfaresponse != nil}
  /// Clears the value of `mfaresponse`. Subsequent reads from it will return its default value.
  mutating func clearMfaresponse() {_uniqueStorage()._mfaresponse = nil}

  /// SSHLogin is the OS Login for the SSH session that the certificate will be used for.
  /// This login is used when performing RBAC checks to determine if MFA is required
  /// to access the resource.
  var sshlogin: String {
    get {return _storage._sshlogin}
    set {_uniqueStorage()._sshlogin = newValue}
  }

  /// AttestationStatement is an attestation statement for the given public key.
  var attestationStatement: Teleport_Attestation_V1_AttestationStatement {
    get {return _storage._attestationStatement ?? Teleport_Attestation_V1_AttestationStatement()}
    set {_uniqueStorage()._attestationStatement = newValue}
  }
  /// Returns true if `attestationStatement` has been explicitly set.
  var hasAttestationStatement: Bool {return _storage._attestationStatement != nil}
  /// Clears the value of `attestationStatement`. Subsequent reads from it will return its default value.
  mutating func clearAttestationStatement() {_uniqueStorage()._attestationStatement = nil}

  /// Purpose is the intended purpose of the certificates.
  var purpose: Proto_UserCertsRequest.CertPurpose {
    get {return _storage._purpose}
    set {_uniqueStorage()._purpose = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum CertUsage: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// All means a request for both SSH and TLS certificates for the
    /// overall user session. These certificates are not specific to any SSH
    /// node, Kubernetes cluster, database or web app.
    case all // = 0

    /// SSH means a request for an SSH certificate for access to a specific
    /// SSH node, as specified by NodeName.
    case ssh // = 1

    /// Kubernetes means a request for a TLS certificate for access to a
    /// specific Kubernetes cluster, as specified by KubernetesCluster.
    case kubernetes // = 2

    /// Database means a request for a TLS certificate for access to a
    /// specific database, as specified by RouteToDatabase.
    case database // = 3

    /// App means a request for a TLS certificate for access to a specific
    /// web app, as specified by RouteToApp.
    case app // = 4

    /// WindowsDesktop means a request for a TLS certificate for access to a specific
    /// windows desktop.
    case windowsDesktop // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .all
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .ssh
      case 2: self = .kubernetes
      case 3: self = .database
      case 4: self = .app
      case 5: self = .windowsDesktop
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .all: return 0
      case .ssh: return 1
      case .kubernetes: return 2
      case .database: return 3
      case .app: return 4
      case .windowsDesktop: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Requester is the name of the service that sent the request.
  enum Requester: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// UNSPECIFIED is set when the requester in unknown.
    case unspecified // = 0

    /// TSH_DB_LOCAL_PROXY_TUNNEL is set when the request was sent by a tsh db local proxy tunnel.
    case tshDbLocalProxyTunnel // = 1

    /// TSH_KUBE_LOCAL_PROXY is set when the request was sent by a tsh kube local proxy.
    case tshKubeLocalProxy // = 2

    /// TSH_KUBE_LOCAL_PROXY_HEADLESS is set when the request was sent by a tsh kube local proxy in headless mode.
    case tshKubeLocalProxyHeadless // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .tshDbLocalProxyTunnel
      case 2: self = .tshKubeLocalProxy
      case 3: self = .tshKubeLocalProxyHeadless
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .tshDbLocalProxyTunnel: return 1
      case .tshKubeLocalProxy: return 2
      case .tshKubeLocalProxyHeadless: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// CertPurpose complements CertUsage by informing Teleport of the intended use
  /// for the certificates.
  enum CertPurpose: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Purpose not specified.
    /// Interpreted as CERT_PURPOSE_LOGIN_CERTS.
    case unspecified // = 0

    /// Generate login certificates, both SSH and TLS, as well as CA certs.
    case loginCerts // = 1

    /// Generate single-user certificates, either SSH or TLS, depending on the
    /// specified Usage.
    case singleUseCerts // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .loginCerts
      case 2: self = .singleUseCerts
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .loginCerts: return 1
      case .singleUseCerts: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Proto_UserCertsRequest.CertUsage: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_UserCertsRequest.CertUsage] = [
    .all,
    .ssh,
    .kubernetes,
    .database,
    .app,
    .windowsDesktop,
  ]
}

extension Proto_UserCertsRequest.Requester: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_UserCertsRequest.Requester] = [
    .unspecified,
    .tshDbLocalProxyTunnel,
    .tshKubeLocalProxy,
    .tshKubeLocalProxyHeadless,
  ]
}

extension Proto_UserCertsRequest.CertPurpose: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_UserCertsRequest.CertPurpose] = [
    .unspecified,
    .loginCerts,
    .singleUseCerts,
  ]
}

#endif  // swift(>=4.2)

/// RouteToDatabase combines parameters for database service routing information.
struct Proto_RouteToDatabase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ServiceName is the Teleport database proxy service name the cert is for.
  var serviceName: String = String()

  /// Protocol is the type of the database the cert is for.
  var `protocol`: String = String()

  /// Username is an optional database username to embed.
  var username: String = String()

  /// Database is an optional database name to embed.
  var database: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RouteToWindowsDesktop combines parameters for windows desktop routing information.
struct Proto_RouteToWindowsDesktop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// WindowsDesktop is the Windows Desktop server name to embed.
  var windowsDesktop: String = String()

  /// Login is the Windows desktop user login to embed.
  var login: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RouteToApp contains parameters for application access certificate requests.
struct Proto_RouteToApp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the application name certificate is being requested for.
  var name: String = String()

  /// SessionID is the ID of the application session.
  var sessionID: String = String()

  /// PublicAddr is the application public address.
  var publicAddr: String = String()

  /// ClusterName is the cluster where the application resides.
  var clusterName: String = String()

  /// AWSRoleARN is the AWS role to assume when accessing AWS API.
  var awsroleArn: String = String()

  /// AzureIdentity is the Azure identity to assume when accessing Azure API.
  var azureIdentity: String = String()

  /// GCPServiceAccount is the GCP service account to assume when accessing GCP API.
  var gcpserviceAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetUserRequest specifies parameters for the GetUser method.
struct Proto_GetUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the desired user.
  var name: String = String()

  /// WithSecrets specifies whether to load associated secrets.
  var withSecrets: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetUsersRequest specifies parameters for the GetUsers method.
struct Proto_GetUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// WithSecrets specifies whether to load associated secrets.
  var withSecrets: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ChangePasswordRequest specifies the parameters for the ChangePassword method.
struct Proto_ChangePasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var user: String = String()

  var oldPassword: Data = Data()

  var newPassword: Data = Data()

  var secondFactorToken: String = String()

  var webauthn: Webauthn_CredentialAssertionResponse {
    get {return _webauthn ?? Webauthn_CredentialAssertionResponse()}
    set {_webauthn = newValue}
  }
  /// Returns true if `webauthn` has been explicitly set.
  var hasWebauthn: Bool {return self._webauthn != nil}
  /// Clears the value of `webauthn`. Subsequent reads from it will return its default value.
  mutating func clearWebauthn() {self._webauthn = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _webauthn: Webauthn_CredentialAssertionResponse? = nil
}

/// PluginDataSeq is a sequence of plugin data.
struct Proto_PluginDataSeq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pluginData: [Types_PluginDataV3] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RequestStateSetter encodes the parameters necessary to update the
/// state of a privilege escalation request.
struct Proto_RequestStateSetter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the request ID being targeted
  var id: String = String()

  /// State is the desired state to be set
  var state: Types_RequestState = .none

  /// Delegator is an optional indicator of who delegated this
  /// state update (used by plugins to indicate which user approved
  /// or denied the request).
  var delegator: String = String()

  /// Reason is an optional message indicating the reason for the
  /// resolution (approval, denail , etc...).
  var reason: String = String()

  /// Annotations are key/value pairs received from plugins during request
  /// resolution.  They are currently only used to provide additional logging
  /// information.
  var annotations: Wrappers_LabelValues {
    get {return _annotations ?? Wrappers_LabelValues()}
    set {_annotations = newValue}
  }
  /// Returns true if `annotations` has been explicitly set.
  var hasAnnotations: Bool {return self._annotations != nil}
  /// Clears the value of `annotations`. Subsequent reads from it will return its default value.
  mutating func clearAnnotations() {self._annotations = nil}

  /// Roles, if present, overrides the existing set of roles associated
  /// with the access request.
  var roles: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _annotations: Wrappers_LabelValues? = nil
}

/// RequestID is the unique identifier of an access request.
struct Proto_RequestID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetResetPasswordTokenRequest is a request to get a reset password token.
struct Proto_GetResetPasswordTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateResetPasswordTokenRequest is a request to create a reset password token.
struct Proto_CreateResetPasswordTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the user name.
  var name: String = String()

  /// Type is a token type.
  var type: String = String()

  /// TTL specifies how long the generated token is valid for.
  var ttl: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RenewableCertsRequest is a request to generate a first set of renewable
/// certificates from a bot join token.
struct Proto_RenewableCertsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Token is a bot join token.
  var token: String = String()

  /// PublicKey is a public key to be signed.
  var publicKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateBotRequest is used to create a bot User and associated resources.
struct Proto_CreateBotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the bot, i.e. the unprefixed User name.
  var name: String = String()

  /// TTL is the desired TTL for the token if one is created. If unset, a
  /// server default is used.
  var ttl: Int64 = 0

  /// TokenID is an optional token name of an EC2/IAM join token should be
  /// used. If unset, a new random token is created and its name returned.
  var tokenID: String = String()

  /// Roles is a list of roles the created bot should be allowed to assume
  /// via role impersonation.
  var roles: [String] = []

  /// Traits are used to populate role variables. These will propagate to
  /// role impersonated certificates generated by the bot.
  var traits: Wrappers_LabelValues {
    get {return _traits ?? Wrappers_LabelValues()}
    set {_traits = newValue}
  }
  /// Returns true if `traits` has been explicitly set.
  var hasTraits: Bool {return self._traits != nil}
  /// Clears the value of `traits`. Subsequent reads from it will return its default value.
  mutating func clearTraits() {self._traits = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _traits: Wrappers_LabelValues? = nil
}

/// CreateBotResponse returns details for bootstrapping a new bot.
struct Proto_CreateBotResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UserName is the name of the associated bot user.
  var userName: String = String()

  /// RoleName is the name of the associated bot role.
  var roleName: String = String()

  /// TokenID is the name of the join token for the bot.
  var tokenID: String = String()

  /// TokenTTL is the TTL for the token. If it differs from the requested TTL,
  /// it may have been limited by server policy.
  var tokenTtl: Int64 = 0

  /// JoinMethod is the join method the bot must use to join the cluster.
  var joinMethod: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteBotRequest is a request to delete a bot user
struct Proto_DeleteBotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the bot, i.e. the unprefixed User name.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetBotUsersRequest specifies parameters for the GetUsers method.
struct Proto_GetBotUsersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PingRequest is the input value for the Ping method.
struct Proto_PingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PingResponse contains data about the teleport auth server.
struct Proto_PingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusterName is the name of the teleport cluster.
  var clusterName: String = String()

  /// ServerVersion is the version of the auth server.
  var serverVersion: String = String()

  /// ServerFeatures are the features supported by the auth server.
  var serverFeatures: Proto_Features {
    get {return _serverFeatures ?? Proto_Features()}
    set {_serverFeatures = newValue}
  }
  /// Returns true if `serverFeatures` has been explicitly set.
  var hasServerFeatures: Bool {return self._serverFeatures != nil}
  /// Clears the value of `serverFeatures`. Subsequent reads from it will return its default value.
  mutating func clearServerFeatures() {self._serverFeatures = nil}

  /// ProxyPublicAddr is the server's public proxy address.
  var proxyPublicAddr: String = String()

  /// IsBoring signals whether or not the server was compiled with BoringCrypto.
  var isBoring: Bool = false

  /// RemoteAddr is the client peer addr as seen from the auth server (used to assist
  /// instances in guessing their external IP when none is configured).
  var remoteAddr: String = String()

  /// LoadAllCAs signals whether or not tsh should load all CAs when trying
  /// to ssh into a node.
  var loadAllCas: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _serverFeatures: Proto_Features? = nil
}

/// Features are auth server features.
struct Proto_Features {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kubernetes enables Kubernetes Access product
  var kubernetes: Bool {
    get {return _storage._kubernetes}
    set {_uniqueStorage()._kubernetes = newValue}
  }

  /// App enables Application Access product
  var app: Bool {
    get {return _storage._app}
    set {_uniqueStorage()._app = newValue}
  }

  /// DB enables database access product
  var db: Bool {
    get {return _storage._db}
    set {_uniqueStorage()._db = newValue}
  }

  /// OIDC enables OIDC connectors
  var oidc: Bool {
    get {return _storage._oidc}
    set {_uniqueStorage()._oidc = newValue}
  }

  /// SAML enables SAML connectors
  var saml: Bool {
    get {return _storage._saml}
    set {_uniqueStorage()._saml = newValue}
  }

  /// AccessControls enables FIPS access controls
  var accessControls: Bool {
    get {return _storage._accessControls}
    set {_uniqueStorage()._accessControls = newValue}
  }

  /// AdvancedAccessWorkflows enables advanced access workflows
  var advancedAccessWorkflows: Bool {
    get {return _storage._advancedAccessWorkflows}
    set {_uniqueStorage()._advancedAccessWorkflows = newValue}
  }

  /// Cloud enables some cloud-related features
  var cloud: Bool {
    get {return _storage._cloud}
    set {_uniqueStorage()._cloud = newValue}
  }

  /// HSM enables PKCS#11 HSM support
  var hsm: Bool {
    get {return _storage._hsm}
    set {_uniqueStorage()._hsm = newValue}
  }

  /// Desktop enables desktop access product
  var desktop: Bool {
    get {return _storage._desktop}
    set {_uniqueStorage()._desktop = newValue}
  }

  /// RecoveryCodes enables recovery codes
  var recoveryCodes: Bool {
    get {return _storage._recoveryCodes}
    set {_uniqueStorage()._recoveryCodes = newValue}
  }

  /// Plugins enables hosted plugins
  var plugins: Bool {
    get {return _storage._plugins}
    set {_uniqueStorage()._plugins = newValue}
  }

  /// AutomaticUpgrades enables Automatic Upgrades for the agents/services.
  var automaticUpgrades: Bool {
    get {return _storage._automaticUpgrades}
    set {_uniqueStorage()._automaticUpgrades = newValue}
  }

  /// IsUsageBased enables some usage-based billing features
  var isUsageBased: Bool {
    get {return _storage._isUsageBased}
    set {_uniqueStorage()._isUsageBased = newValue}
  }

  /// Assist enables the Assistant feature
  var assist: Bool {
    get {return _storage._assist}
    set {_uniqueStorage()._assist = newValue}
  }

  /// DeviceTrust holds its namesake feature settings.
  var deviceTrust: Proto_DeviceTrustFeature {
    get {return _storage._deviceTrust ?? Proto_DeviceTrustFeature()}
    set {_uniqueStorage()._deviceTrust = newValue}
  }
  /// Returns true if `deviceTrust` has been explicitly set.
  var hasDeviceTrust: Bool {return _storage._deviceTrust != nil}
  /// Clears the value of `deviceTrust`. Subsequent reads from it will return its default value.
  mutating func clearDeviceTrust() {_uniqueStorage()._deviceTrust = nil}

  /// FeatureHiding enables hiding features from being discoverable for users who don't have the necessary permissions.
  var featureHiding: Bool {
    get {return _storage._featureHiding}
    set {_uniqueStorage()._featureHiding = newValue}
  }

  /// AccessRequests holds its namesake feature settings.
  var accessRequests: Proto_AccessRequestsFeature {
    get {return _storage._accessRequests ?? Proto_AccessRequestsFeature()}
    set {_uniqueStorage()._accessRequests = newValue}
  }
  /// Returns true if `accessRequests` has been explicitly set.
  var hasAccessRequests: Bool {return _storage._accessRequests != nil}
  /// Clears the value of `accessRequests`. Subsequent reads from it will return its default value.
  mutating func clearAccessRequests() {_uniqueStorage()._accessRequests = nil}

  /// CustomTheme holds the name of WebUI custom theme.
  var customTheme: String {
    get {return _storage._customTheme}
    set {_uniqueStorage()._customTheme = newValue}
  }

  /// IdentityGovernance holds the Identity Governance feature settings (Access Monitoring)
  var identityGovernance: Bool {
    get {return _storage._identityGovernance}
    set {_uniqueStorage()._identityGovernance = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeviceTrustFeature holds the Device Trust feature general and usage-based
/// settings.
/// Requires Teleport Enterprise.
struct Proto_DeviceTrustFeature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if the Device Trust feature is enabled.
  var enabled: Bool = false

  /// Usage-based limit for the number of registered/enrolled devices, at the
  /// implementation's discretion.
  /// Meant for usage-based accounts, like Teleport Team. Has no effect if
  /// [Features.IsUsageBased] is `false`.
  var devicesUsageLimit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestsFeature holds the AccessRequest feature general and usage-based
/// settings.
/// Requires Teleport Enterprise.
struct Proto_AccessRequestsFeature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Usage-based limit for the number of limit for the number of
  /// access requests created in a calendar month.
  /// Meant for usage-based accounts, like Teleport Team. Has no effect if
  /// [Features.IsUsageBased] is `false`.
  var monthlyRequestLimit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteUserRequest is the input value for the DeleteUser method.
struct Proto_DeleteUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the user name to delete.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Semaphores is a sequence of Semaphore resources.
struct Proto_Semaphores {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var semaphores: [Types_SemaphoreV3] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AuditStreamRequest contains stream request - event or stream control request
struct Proto_AuditStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request is either stream request - create, resume or complete stream
  /// or event submitted as a part of the stream
  var request: Proto_AuditStreamRequest.OneOf_Request? = nil

  /// CreateStream creates the stream for session ID
  /// should be the first message sent to the stream
  var createStream: Proto_CreateStream {
    get {
      if case .createStream(let v)? = request {return v}
      return Proto_CreateStream()
    }
    set {request = .createStream(newValue)}
  }

  /// ResumeStream resumes existing stream, should be the
  /// first message sent to the stream
  var resumeStream: Proto_ResumeStream {
    get {
      if case .resumeStream(let v)? = request {return v}
      return Proto_ResumeStream()
    }
    set {request = .resumeStream(newValue)}
  }

  /// CompleteStream completes the stream
  var completeStream: Proto_CompleteStream {
    get {
      if case .completeStream(let v)? = request {return v}
      return Proto_CompleteStream()
    }
    set {request = .completeStream(newValue)}
  }

  /// FlushAndClose flushes and closes the stream
  var flushAndCloseStream: Proto_FlushAndCloseStream {
    get {
      if case .flushAndCloseStream(let v)? = request {return v}
      return Proto_FlushAndCloseStream()
    }
    set {request = .flushAndCloseStream(newValue)}
  }

  /// Event contains the stream event
  var event: Events_OneOf {
    get {
      if case .event(let v)? = request {return v}
      return Events_OneOf()
    }
    set {request = .event(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request is either stream request - create, resume or complete stream
  /// or event submitted as a part of the stream
  enum OneOf_Request: Equatable {
    /// CreateStream creates the stream for session ID
    /// should be the first message sent to the stream
    case createStream(Proto_CreateStream)
    /// ResumeStream resumes existing stream, should be the
    /// first message sent to the stream
    case resumeStream(Proto_ResumeStream)
    /// CompleteStream completes the stream
    case completeStream(Proto_CompleteStream)
    /// FlushAndClose flushes and closes the stream
    case flushAndCloseStream(Proto_FlushAndCloseStream)
    /// Event contains the stream event
    case event(Events_OneOf)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_AuditStreamRequest.OneOf_Request, rhs: Proto_AuditStreamRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.createStream, .createStream): return {
        guard case .createStream(let l) = lhs, case .createStream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resumeStream, .resumeStream): return {
        guard case .resumeStream(let l) = lhs, case .resumeStream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.completeStream, .completeStream): return {
        guard case .completeStream(let l) = lhs, case .completeStream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.flushAndCloseStream, .flushAndCloseStream): return {
        guard case .flushAndCloseStream(let l) = lhs, case .flushAndCloseStream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.event, .event): return {
        guard case .event(let l) = lhs, case .event(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// AuditStreamStatus returns audit stream status
/// with corresponding upload ID
struct Proto_AuditStreamStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UploadID is upload ID associated with the stream,
  /// can be used to resume the stream
  var uploadID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateStream creates stream for a new session ID
struct Proto_CreateStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ResumeStream resumes stream that was previously created
struct Proto_ResumeStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is a session ID of the stream
  var sessionID: String = String()

  /// UploadID is upload ID to resume
  var uploadID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CompleteStream completes the stream
/// and uploads it to the session server
struct Proto_CompleteStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// FlushAndCloseStream flushes the stream data and closes the stream
struct Proto_FlushAndCloseStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertApplicationServerRequest upserts an app server.
struct Proto_UpsertApplicationServerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server is an app server resource to register.
  var server: Types_AppServerV3 {
    get {return _server ?? Types_AppServerV3()}
    set {_server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return self._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {self._server = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _server: Types_AppServerV3? = nil
}

/// DeleteApplicationServerRequest is a request to delete an app server.
struct Proto_DeleteApplicationServerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace is the app server namespace.
  var namespace: String = String()

  /// HostID is the app server host uuid.
  var hostID: String = String()

  /// Name is the name of the application to delete.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteAllApplicationServersRequest are the parameters used to remove all applications.
struct Proto_DeleteAllApplicationServersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace is the app servers namespace.
  var namespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GenerateAppTokenRequest are the parameters used to request an application
/// token.
struct Proto_GenerateAppTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Username is the Teleport username.
  var username: String = String()

  /// Roles is a list of Teleport roles assigned to the user.
  var roles: [String] = []

  /// URI is the URI of the application this token is targeting.
  var uri: String = String()

  /// Expires is the time this token expires.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// Traits are the traits assigned to the user within Teleport.
  var traits: Dictionary<String,Wrappers_StringValues> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// GenerateAppTokenResponse contains a signed application token.
struct Proto_GenerateAppTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAppSessionRequest are the parameters used to request an application web session.
struct Proto_GetAppSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is the ID of the session being requested.
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAppSessionResponse contains the requested application web session.
struct Proto_GetAppSessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Session is the application web session.
  var session: Types_WebSessionV2 {
    get {return _session ?? Types_WebSessionV2()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: Types_WebSessionV2? = nil
}

/// ListAppSessionRequest are the parameters used to request an application web session.
///
/// Follows the pagination semantics of
/// https://cloud.google.com/apis/design/standard_methods#list.
struct Proto_ListAppSessionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The maximum number of items to return.
  /// The server may impose a different page size at its discretion.
  var pageSize: Int32 = 0

  /// The next_page_token value returned from a previous List request, if any.
  var pageToken: String = String()

  /// Optional username which will filter the returned web sessions
  /// to include only those for the given user.
  var user: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListAppSessionResponse contains the requested application web session.
struct Proto_ListAppSessionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sessions for the retrieved page.
  var sessions: [Types_WebSessionV2] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSnowflakeSessionsResponse contains all the requested Snowflake web sessions.
struct Proto_GetSnowflakeSessionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sessions is a list of Snowflake web sessions.
  var sessions: [Types_WebSessionV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListSAMLIdPSessionRequest are the parameters used to request a SAML IdP sessions.
///
/// Follows the pagination semantics of
/// https://cloud.google.com/apis/design/standard_methods#list.
struct Proto_ListSAMLIdPSessionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The maximum number of items to return.
  /// The server may impose a different page size at its discretion.
  var pageSize: Int32 = 0

  /// The next_page_token value returned from a previous List request, if any.
  var pageToken: String = String()

  /// Optional username which will filter the returned SAML IdP sessions
  /// to include only those for the given user.
  var user: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListSAMLIdPSessionsResponse contains all the requested SAML IdP sessions.
struct Proto_ListSAMLIdPSessionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sessions for the retrieved page.
  var sessions: [Types_WebSessionV2] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateAppSessionRequest contains the parameters to request a application web session.
struct Proto_CreateAppSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Username is the name of the user requesting the session.
  var username: String = String()

  /// PublicAddr is the public address the application.
  var publicAddr: String = String()

  /// ClusterName is cluster within which the application is running.
  var clusterName: String = String()

  /// AWSRoleARN is AWS role the user wants to assume.
  var awsroleArn: String = String()

  /// AzureIdentity is Azure identity the user wants to assume.
  var azureIdentity: String = String()

  /// GCPServiceAccount is the GCP service account the user wants to assume.
  var gcpserviceAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateAppSessionResponse contains the requested application web session.
struct Proto_CreateAppSessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Session is the application web session.
  var session: Types_WebSessionV2 {
    get {return _session ?? Types_WebSessionV2()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: Types_WebSessionV2? = nil
}

/// CreateSnowflakeSessionRequest contains data required to create Snowflake web session.
struct Proto_CreateSnowflakeSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Username is the name of the user requesting the session.
  var username: String = String()

  /// SessionToken is the Snowflake server session token.
  var sessionToken: String = String()

  /// TokenTTL is the token validity period.
  var tokenTtl: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateSnowflakeSessionResponse contains Snowflake WebSession.
struct Proto_CreateSnowflakeSessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var session: Types_WebSessionV2 {
    get {return _session ?? Types_WebSessionV2()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: Types_WebSessionV2? = nil
}

/// CreateSAMLIdPSessionRequest contains data required to create a SAML IdP session.
struct Proto_CreateSAMLIdPSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is the identifier for the session.
  var sessionID: String = String()

  /// Username is the name of the user requesting the session.
  var username: String = String()

  /// SAMLSession is the session data associated with the SAML IdP session.
  var samlsession: Types_SAMLSessionData {
    get {return _samlsession ?? Types_SAMLSessionData()}
    set {_samlsession = newValue}
  }
  /// Returns true if `samlsession` has been explicitly set.
  var hasSamlsession: Bool {return self._samlsession != nil}
  /// Clears the value of `samlsession`. Subsequent reads from it will return its default value.
  mutating func clearSamlsession() {self._samlsession = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _samlsession: Types_SAMLSessionData? = nil
}

/// CreateSAMLIdPSessionResponse contains a SAML IdP session.
struct Proto_CreateSAMLIdPSessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var session: Types_WebSessionV2 {
    get {return _session ?? Types_WebSessionV2()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: Types_WebSessionV2? = nil
}

/// GetSnowflakeSessionRequest are the parameters used to request an Snowflake web session.
struct Proto_GetSnowflakeSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is the ID of the session being requested.
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSnowflakeSessionResponse contains the requested Snowflake web session.
struct Proto_GetSnowflakeSessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Session is the Snowflake web session.
  var session: Types_WebSessionV2 {
    get {return _session ?? Types_WebSessionV2()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: Types_WebSessionV2? = nil
}

/// GetSAMLIdPSessionRequest are the parameters used to request a SAML IdP session.
struct Proto_GetSAMLIdPSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is the ID of the session being requested.
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSAMLIdPSessionResponse contains the requested SAML IdP session.
struct Proto_GetSAMLIdPSessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Session is the SAML IdP web session.
  var session: Types_WebSessionV2 {
    get {return _session ?? Types_WebSessionV2()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: Types_WebSessionV2? = nil
}

/// DeleteAppSessionRequest contains the parameters used to remove an application web session.
struct Proto_DeleteAppSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteSnowflakeSessionRequest contains the parameters used to remove a Snowflake web session.
struct Proto_DeleteSnowflakeSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteSAMLIdPSessionRequest contains the parameters used to remove a SAML IdP session.
struct Proto_DeleteSAMLIdPSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteUserAppSessionsRequest contains the parameters used to remove the
/// user's application web sessions.
struct Proto_DeleteUserAppSessionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteUserAppSessionsRequest contains the parameters used to remove the
/// user's SAML IdP sessions.
struct Proto_DeleteUserSAMLIdPSessionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetWebSessionResponse contains the requested web session.
struct Proto_GetWebSessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Session is the web session.
  var session: Types_WebSessionV2 {
    get {return _session ?? Types_WebSessionV2()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: Types_WebSessionV2? = nil
}

/// GetWebSessionsResponse contains all the requested web sessions.
struct Proto_GetWebSessionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sessions is a list of web sessions.
  var sessions: [Types_WebSessionV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetWebTokenResponse contains the requested web token.
struct Proto_GetWebTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Token is the web token being requested.
  var token: Types_WebTokenV3 {
    get {return _token ?? Types_WebTokenV3()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _token: Types_WebTokenV3? = nil
}

/// GetWebTokensResponse contains all the requested web tokens.
struct Proto_GetWebTokensResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tokens is a list of web tokens.
  var tokens: [Types_WebTokenV3] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertKubernetesServerRequest are the parameters used to add or update a
/// kubernetes server.
struct Proto_UpsertKubernetesServerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var server: Types_KubernetesServerV3 {
    get {return _server ?? Types_KubernetesServerV3()}
    set {_server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return self._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {self._server = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _server: Types_KubernetesServerV3? = nil
}

/// DeleteKubernetesServerRequest are the parameters used to remove a kubernetes server.
struct Proto_DeleteKubernetesServerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HostID is the kube server host uuid.
  var hostID: String = String()

  /// Name is the name of the kubernetes service to delete.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteAllKubernetesServersRequest are the parameters used to remove all kubernetes servers.
struct Proto_DeleteAllKubernetesServersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertDatabaseServerRequest is a request to register database server.
struct Proto_UpsertDatabaseServerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server is the database proxy server to register.
  var server: Types_DatabaseServerV3 {
    get {return _server ?? Types_DatabaseServerV3()}
    set {_server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return self._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {self._server = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _server: Types_DatabaseServerV3? = nil
}

/// DeleteDatabaseServerRequest is a request to delete a database server.
struct Proto_DeleteDatabaseServerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace is the database server namespace.
  var namespace: String = String()

  /// HostID is the ID of the host database server is running on.
  var hostID: String = String()

  /// Name is the database server name.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteAllDatabaseServersRequest is a request to delete all database servers.
struct Proto_DeleteAllDatabaseServersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace is the database servers namespace.
  var namespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DatabaseServiceV1List represents a list of DatabaseService resources.
struct Proto_DatabaseServiceV1List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Services is a list of DatabaseService resources.
  var services: [Types_DatabaseServiceV1] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertDatabaseServiceRequest is a request to register DatabaseService.
struct Proto_UpsertDatabaseServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Service is the database service to register.
  var service: Types_DatabaseServiceV1 {
    get {return _service ?? Types_DatabaseServiceV1()}
    set {_service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  var hasService: Bool {return self._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  mutating func clearService() {self._service = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _service: Types_DatabaseServiceV1? = nil
}

/// DeleteAllDatabaseServicesRequest is a request to delete all DatabaseServices.
struct Proto_DeleteAllDatabaseServicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DatabaseCSRRequest is a request to generate a client certificate used
/// by the proxy to authenticate with a remote database service.
struct Proto_DatabaseCSRRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CSR is the request to sign.
  var csr: Data = Data()

  /// ClusterName is the name of the cluster the request is for.
  var clusterName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DatabaseCSRResponse contains the signed database certificate.
struct Proto_DatabaseCSRResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cert is the signed certificate.
  var cert: Data = Data()

  /// CACerts is a list of certificate authorities.
  var cacerts: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DatabaseCertRequest is a request to generate a client certificate used
/// by a database service to authenticate with a database instance.
struct Proto_DatabaseCertRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CSR is the request to sign.
  var csr: Data = Data()

  /// ServerName is the SAN to include in the certificate.
  /// DEPRECATED: Replaced by ServerNames.
  var serverName: String = String()

  /// TTL is the certificate validity period.
  var ttl: Int64 = 0

  /// ServerNames are SANs to include in the certificate.
  var serverNames: [String] = []

  /// RequesterName identifies who sent the request.
  var requesterName: Proto_DatabaseCertRequest.Requester = .unspecified

  /// CertificateExtensions identifies which extensions, if any, should be added to the certificate.
  var certificateExtensions: Proto_DatabaseCertRequest.ExtensionsEnum = .normal

  /// CRLEndpoint is a certificate revocation list distribution point. Required for Windows smartcard certs.
  var crlendpoint: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Requester is a name of service that sent the request.
  enum Requester: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// UNSPECIFIED is set when the requester in unknown.
    case unspecified // = 0

    /// TCTL is set when request was sent by tctl tool.
    case tctl // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .tctl
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .tctl: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Extensions are the extensions to add to the certificate.
  enum ExtensionsEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// NORMAL is used in all cases except Windows.
    case normal // = 0

    /// WINDOWS adds specific required extensions for SQL Server, similar to Desktop Access.
    case windowsSmartcard // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .normal
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .windowsSmartcard
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .normal: return 0
      case .windowsSmartcard: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Proto_DatabaseCertRequest.Requester: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_DatabaseCertRequest.Requester] = [
    .unspecified,
    .tctl,
  ]
}

extension Proto_DatabaseCertRequest.ExtensionsEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_DatabaseCertRequest.ExtensionsEnum] = [
    .normal,
    .windowsSmartcard,
  ]
}

#endif  // swift(>=4.2)

/// DatabaseCertResponse contains the signed certificate.
struct Proto_DatabaseCertResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cert is the signed certificate.
  var cert: Data = Data()

  /// CACerts is a list of certificate authorities.
  var cacerts: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SnowflakeJWTRequest contains data required to generate Snowflake JWT used for authorization.
struct Proto_SnowflakeJWTRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountName: String = String()

  var userName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SnowflakeJWTResponse contains signed JWT that can be used for Snowflake authentication.
struct Proto_SnowflakeJWTResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetRoleRequest is a request to query a role.
struct Proto_GetRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the role to get.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetRolesResponse is a response to querying for all roles.
struct Proto_GetRolesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roles is a list of roles.
  var roles: [Types_RoleV6] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for CreateRole.
struct Proto_CreateRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Role to be created.
  var role: Types_RoleV6 {
    get {return _role ?? Types_RoleV6()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  mutating func clearRole() {self._role = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _role: Types_RoleV6? = nil
}

/// Request for UpdateRole.
struct Proto_UpdateRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Role to be updated.
  var role: Types_RoleV6 {
    get {return _role ?? Types_RoleV6()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  mutating func clearRole() {self._role = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _role: Types_RoleV6? = nil
}

/// Request for UpsertRole.
struct Proto_UpsertRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Role to be upserted.
  var role: Types_RoleV6 {
    get {return _role ?? Types_RoleV6()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  mutating func clearRole() {self._role = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _role: Types_RoleV6? = nil
}

/// DeleteRoleRequest is a request to delete a role.
struct Proto_DeleteRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the role name to delete.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MFAAuthenticateChallenge is a challenge for all MFA devices registered for a
/// user.
struct Proto_MFAAuthenticateChallenge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TOTP is a challenge for all TOTP devices registered for a user. When
  /// this field is set, any TOTP device a user has registered can be used to
  /// respond.
  var totp: Proto_TOTPChallenge {
    get {return _totp ?? Proto_TOTPChallenge()}
    set {_totp = newValue}
  }
  /// Returns true if `totp` has been explicitly set.
  var hasTotp: Bool {return self._totp != nil}
  /// Clears the value of `totp`. Subsequent reads from it will return its default value.
  mutating func clearTotp() {self._totp = nil}

  /// WebauthnChallenge contains a Webauthn credential assertion used for
  /// login/authentication ceremonies.
  /// Credential assertions hold, among other information, a list of allowed
  /// credentials for the ceremony (one for each U2F or Webauthn device
  /// registered by the user).
  var webauthnChallenge: Webauthn_CredentialAssertion {
    get {return _webauthnChallenge ?? Webauthn_CredentialAssertion()}
    set {_webauthnChallenge = newValue}
  }
  /// Returns true if `webauthnChallenge` has been explicitly set.
  var hasWebauthnChallenge: Bool {return self._webauthnChallenge != nil}
  /// Clears the value of `webauthnChallenge`. Subsequent reads from it will return its default value.
  mutating func clearWebauthnChallenge() {self._webauthnChallenge = nil}

  /// MFRequired indicates whether proceeding with the MFA ceremony will
  /// grant access to the resource.
  ///
  /// If `MFA_REQUIRED_NO` is returned then the server may opt to end ongoing
  /// communications, in case of streaming RPCs. It may also return empty
  /// challenges for all other fields.
  var mfarequired: Proto_MFARequired = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totp: Proto_TOTPChallenge? = nil
  fileprivate var _webauthnChallenge: Webauthn_CredentialAssertion? = nil
}

/// MFAAuthenticateResponse is a response to MFAAuthenticateChallenge using one
/// of the MFA devices registered for a user.
struct Proto_MFAAuthenticateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Proto_MFAAuthenticateResponse.OneOf_Response? = nil

  /// Removed: U2FResponse U2F = 1;
  var totp: Proto_TOTPResponse {
    get {
      if case .totp(let v)? = response {return v}
      return Proto_TOTPResponse()
    }
    set {response = .totp(newValue)}
  }

  var webauthn: Webauthn_CredentialAssertionResponse {
    get {
      if case .webauthn(let v)? = response {return v}
      return Webauthn_CredentialAssertionResponse()
    }
    set {response = .webauthn(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    /// Removed: U2FResponse U2F = 1;
    case totp(Proto_TOTPResponse)
    case webauthn(Webauthn_CredentialAssertionResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_MFAAuthenticateResponse.OneOf_Response, rhs: Proto_MFAAuthenticateResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.totp, .totp): return {
        guard case .totp(let l) = lhs, case .totp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webauthn, .webauthn): return {
        guard case .webauthn(let l) = lhs, case .webauthn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// TOTPChallenge is a challenge for all TOTP devices registered for a user.
struct Proto_TOTPChallenge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TOTPResponse is a response to TOTPChallenge.
struct Proto_TOTPResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MFARegisterChallenge is a challenge for registering a new MFA device.
struct Proto_MFARegisterChallenge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request depends on the type of the MFA device being registered.
  var request: Proto_MFARegisterChallenge.OneOf_Request? = nil

  /// Removed: U2FRegisterChallenge U2F = 1;
  var totp: Proto_TOTPRegisterChallenge {
    get {
      if case .totp(let v)? = request {return v}
      return Proto_TOTPRegisterChallenge()
    }
    set {request = .totp(newValue)}
  }

  var webauthn: Webauthn_CredentialCreation {
    get {
      if case .webauthn(let v)? = request {return v}
      return Webauthn_CredentialCreation()
    }
    set {request = .webauthn(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request depends on the type of the MFA device being registered.
  enum OneOf_Request: Equatable {
    /// Removed: U2FRegisterChallenge U2F = 1;
    case totp(Proto_TOTPRegisterChallenge)
    case webauthn(Webauthn_CredentialCreation)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_MFARegisterChallenge.OneOf_Request, rhs: Proto_MFARegisterChallenge.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.totp, .totp): return {
        guard case .totp(let l) = lhs, case .totp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webauthn, .webauthn): return {
        guard case .webauthn(let l) = lhs, case .webauthn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// MFARegisterResponse is a response to MFARegisterChallenge.
struct Proto_MFARegisterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Proto_MFARegisterResponse.OneOf_Response? = nil

  /// Removed: U2FRegisterResponse U2F = 1;
  var totp: Proto_TOTPRegisterResponse {
    get {
      if case .totp(let v)? = response {return v}
      return Proto_TOTPRegisterResponse()
    }
    set {response = .totp(newValue)}
  }

  var webauthn: Webauthn_CredentialCreationResponse {
    get {
      if case .webauthn(let v)? = response {return v}
      return Webauthn_CredentialCreationResponse()
    }
    set {response = .webauthn(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    /// Removed: U2FRegisterResponse U2F = 1;
    case totp(Proto_TOTPRegisterResponse)
    case webauthn(Webauthn_CredentialCreationResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_MFARegisterResponse.OneOf_Response, rhs: Proto_MFARegisterResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.totp, .totp): return {
        guard case .totp(let l) = lhs, case .totp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webauthn, .webauthn): return {
        guard case .webauthn(let l) = lhs, case .webauthn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// TOTPRegisterChallenge is a challenge for registering a new TOTP device.
struct Proto_TOTPRegisterChallenge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Secret is a secret shared by client and server to generate codes.
  var secret: String = String()

  /// Issuer is the name of the Teleport cluster.
  var issuer: String = String()

  /// PeriodSeconds is a period for TOTP code rotation, in seconds.
  var periodSeconds: UInt32 = 0

  /// Algorithm is the TOTP hashing algorithm.
  var algorithm: String = String()

  /// Digits is the number of digits in the TOTP code.
  var digits: UInt32 = 0

  /// Account is the account name for this user.
  var account: String = String()

  /// QRCode is an optional field for the QR code in PNG format. Used to display a QR code
  /// image in the UI.
  var qrcode: Data = Data()

  /// ID of the TOTP challenge.
  /// Send this back in the TOTPRegisterResponse.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TOTPRegisterResponse is a response to TOTPRegisterChallenge.
struct Proto_TOTPRegisterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: String = String()

  /// ID of the TOTP challenge, as informed by the TOTPRegisterChallenge.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AddMFADeviceRequest is a message sent by the client during AddMFADevice RPC.
///
/// Deprecated: Use [AuthService.AddMFADeviceSync] instead.
struct Proto_AddMFADeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Proto_AddMFADeviceRequest.OneOf_Request? = nil

  /// Init describes the new device.
  var init_p: Proto_AddMFADeviceRequestInit {
    get {
      if case .init_p(let v)? = request {return v}
      return Proto_AddMFADeviceRequestInit()
    }
    set {request = .init_p(newValue)}
  }

  /// ExistingMFAResponse is a response to ExistingMFAChallenge auth
  /// challenge.
  var existingMfaresponse: Proto_MFAAuthenticateResponse {
    get {
      if case .existingMfaresponse(let v)? = request {return v}
      return Proto_MFAAuthenticateResponse()
    }
    set {request = .existingMfaresponse(newValue)}
  }

  /// NewMFARegisterResponse is a response to NewMFARegisterChallenge
  /// registration challenge.
  var newMfaregisterResponse: Proto_MFARegisterResponse {
    get {
      if case .newMfaregisterResponse(let v)? = request {return v}
      return Proto_MFARegisterResponse()
    }
    set {request = .newMfaregisterResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    /// Init describes the new device.
    case init_p(Proto_AddMFADeviceRequestInit)
    /// ExistingMFAResponse is a response to ExistingMFAChallenge auth
    /// challenge.
    case existingMfaresponse(Proto_MFAAuthenticateResponse)
    /// NewMFARegisterResponse is a response to NewMFARegisterChallenge
    /// registration challenge.
    case newMfaregisterResponse(Proto_MFARegisterResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_AddMFADeviceRequest.OneOf_Request, rhs: Proto_AddMFADeviceRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.init_p, .init_p): return {
        guard case .init_p(let l) = lhs, case .init_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.existingMfaresponse, .existingMfaresponse): return {
        guard case .existingMfaresponse(let l) = lhs, case .existingMfaresponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newMfaregisterResponse, .newMfaregisterResponse): return {
        guard case .newMfaregisterResponse(let l) = lhs, case .newMfaregisterResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// AddMFADeviceResponse is a message sent by the server during AddMFADevice
/// RPC.
///
/// Deprecated: Use [AuthService.AddMFADeviceSync] instead.
struct Proto_AddMFADeviceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Proto_AddMFADeviceResponse.OneOf_Response? = nil

  /// ExistingMFAChallenge is an auth challenge using an existing MFA
  /// device.
  var existingMfachallenge: Proto_MFAAuthenticateChallenge {
    get {
      if case .existingMfachallenge(let v)? = response {return v}
      return Proto_MFAAuthenticateChallenge()
    }
    set {response = .existingMfachallenge(newValue)}
  }

  /// NewMFARegisterChallenge is a registration challenge for a new MFA
  /// device.
  var newMfaregisterChallenge: Proto_MFARegisterChallenge {
    get {
      if case .newMfaregisterChallenge(let v)? = response {return v}
      return Proto_MFARegisterChallenge()
    }
    set {response = .newMfaregisterChallenge(newValue)}
  }

  /// Ack is a confirmation of successful device registration.
  var ack: Proto_AddMFADeviceResponseAck {
    get {
      if case .ack(let v)? = response {return v}
      return Proto_AddMFADeviceResponseAck()
    }
    set {response = .ack(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    /// ExistingMFAChallenge is an auth challenge using an existing MFA
    /// device.
    case existingMfachallenge(Proto_MFAAuthenticateChallenge)
    /// NewMFARegisterChallenge is a registration challenge for a new MFA
    /// device.
    case newMfaregisterChallenge(Proto_MFARegisterChallenge)
    /// Ack is a confirmation of successful device registration.
    case ack(Proto_AddMFADeviceResponseAck)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_AddMFADeviceResponse.OneOf_Response, rhs: Proto_AddMFADeviceResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.existingMfachallenge, .existingMfachallenge): return {
        guard case .existingMfachallenge(let l) = lhs, case .existingMfachallenge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newMfaregisterChallenge, .newMfaregisterChallenge): return {
        guard case .newMfaregisterChallenge(let l) = lhs, case .newMfaregisterChallenge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ack, .ack): return {
        guard case .ack(let l) = lhs, case .ack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// AddMFADeviceRequestInit describes the new MFA device.
///
/// Deprecated: Use [AuthService.AddMFADeviceSync] instead.
struct Proto_AddMFADeviceRequestInit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceName: String = String()

  var deviceType: Proto_DeviceType = .unspecified

  /// DeviceUsage is the requested usage for the device.
  /// Defaults to DEVICE_USAGE_MFA.
  var deviceUsage: Proto_DeviceUsage = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AddMFADeviceResponseAck is a confirmation of successful device registration.
struct Proto_AddMFADeviceResponseAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var device: Types_MFADevice {
    get {return _device ?? Types_MFADevice()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _device: Types_MFADevice? = nil
}

/// DeleteMFADeviceRequest is a message sent by the client during
/// DeleteMFADevice RPC.
///
/// Deprecated: Use [AuthService.DeleteMFADeviceSync] instead.
struct Proto_DeleteMFADeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Proto_DeleteMFADeviceRequest.OneOf_Request? = nil

  /// Init describes the device to be deleted.
  var init_p: Proto_DeleteMFADeviceRequestInit {
    get {
      if case .init_p(let v)? = request {return v}
      return Proto_DeleteMFADeviceRequestInit()
    }
    set {request = .init_p(newValue)}
  }

  /// MFAResponse is a response to MFAChallenge auth challenge.
  var mfaresponse: Proto_MFAAuthenticateResponse {
    get {
      if case .mfaresponse(let v)? = request {return v}
      return Proto_MFAAuthenticateResponse()
    }
    set {request = .mfaresponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    /// Init describes the device to be deleted.
    case init_p(Proto_DeleteMFADeviceRequestInit)
    /// MFAResponse is a response to MFAChallenge auth challenge.
    case mfaresponse(Proto_MFAAuthenticateResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_DeleteMFADeviceRequest.OneOf_Request, rhs: Proto_DeleteMFADeviceRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.init_p, .init_p): return {
        guard case .init_p(let l) = lhs, case .init_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mfaresponse, .mfaresponse): return {
        guard case .mfaresponse(let l) = lhs, case .mfaresponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Deprecated: Use [AuthService.DeleteMFADeviceSync] instead.
struct Proto_DeleteMFADeviceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Proto_DeleteMFADeviceResponse.OneOf_Response? = nil

  /// MFAChallenge is an auth challenge using any existing MFA device.
  var mfachallenge: Proto_MFAAuthenticateChallenge {
    get {
      if case .mfachallenge(let v)? = response {return v}
      return Proto_MFAAuthenticateChallenge()
    }
    set {response = .mfachallenge(newValue)}
  }

  /// Ack is a confirmation of successful device deletion.
  var ack: Proto_DeleteMFADeviceResponseAck {
    get {
      if case .ack(let v)? = response {return v}
      return Proto_DeleteMFADeviceResponseAck()
    }
    set {response = .ack(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    /// MFAChallenge is an auth challenge using any existing MFA device.
    case mfachallenge(Proto_MFAAuthenticateChallenge)
    /// Ack is a confirmation of successful device deletion.
    case ack(Proto_DeleteMFADeviceResponseAck)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_DeleteMFADeviceResponse.OneOf_Response, rhs: Proto_DeleteMFADeviceResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mfachallenge, .mfachallenge): return {
        guard case .mfachallenge(let l) = lhs, case .mfachallenge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ack, .ack): return {
        guard case .ack(let l) = lhs, case .ack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// DeleteMFADeviceRequestInit describes the device to be deleted.
///
/// Deprecated: Use [AuthService.DeleteMFADeviceSync] instead.
struct Proto_DeleteMFADeviceRequestInit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DeviceName is an MFA device name or ID to be deleted.
  var deviceName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteMFADeviceResponseAck is a confirmation of successful device deletion.
struct Proto_DeleteMFADeviceResponseAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var device: Types_MFADevice {
    get {return _device ?? Types_MFADevice()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _device: Types_MFADevice? = nil
}

/// DeleteMFADeviceSyncRequest is a request to delete a MFA device (nonstream).
struct Proto_DeleteMFADeviceSyncRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TokenID is the ID of a user token that will be used to verify this request.
  ///
  /// Token types accepted are:
  ///   - Recovery approved token that is obtained with RPC VerifyAccountRecovery
  ///   - Privilege token that is obtained with RPC CreatePrivilegeToken
  ///
  /// Authenticated users can delete a device by providing an ExistingMFAResponse
  /// instead.
  var tokenID: String = String()

  /// DeviceName is the name of the device to delete.
  var deviceName: String = String()

  /// ExistingMFAResponse is an MFA response from an existing device.
  ///
  /// May be provided as an alternative to TokenID.
  var existingMfaresponse: Proto_MFAAuthenticateResponse {
    get {return _existingMfaresponse ?? Proto_MFAAuthenticateResponse()}
    set {_existingMfaresponse = newValue}
  }
  /// Returns true if `existingMfaresponse` has been explicitly set.
  var hasExistingMfaresponse: Bool {return self._existingMfaresponse != nil}
  /// Clears the value of `existingMfaresponse`. Subsequent reads from it will return its default value.
  mutating func clearExistingMfaresponse() {self._existingMfaresponse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _existingMfaresponse: Proto_MFAAuthenticateResponse? = nil
}

/// AddMFADeviceSyncRequest is a request to add a MFA device (nonstream).
struct Proto_AddMFADeviceSyncRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TokenID is the ID of a user token that will be used to verify this request.
  ///
  /// Token types accepted are:
  ///  - Privilege token that is obtained with RPC CreatePrivilegeToken
  ///
  /// An authenticated user can register a new device using only a
  /// NewMFAResponse. See [ContextUser].
  var tokenID: String = String()

  /// ContextUser allows registering a device for the authenticated user.
  ///
  /// Default option if no other is provided.
  var contextUser: Proto_ContextUser {
    get {return _contextUser ?? Proto_ContextUser()}
    set {_contextUser = newValue}
  }
  /// Returns true if `contextUser` has been explicitly set.
  var hasContextUser: Bool {return self._contextUser != nil}
  /// Clears the value of `contextUser`. Subsequent reads from it will return its default value.
  mutating func clearContextUser() {self._contextUser = nil}

  /// NewDeviceName is the name of a new mfa device.
  var newDeviceName: String = String()

  /// NewMFAResponse is a user's new mfa response to a mfa register challenge.
  var newMfaresponse: Proto_MFARegisterResponse {
    get {return _newMfaresponse ?? Proto_MFARegisterResponse()}
    set {_newMfaresponse = newValue}
  }
  /// Returns true if `newMfaresponse` has been explicitly set.
  var hasNewMfaresponse: Bool {return self._newMfaresponse != nil}
  /// Clears the value of `newMfaresponse`. Subsequent reads from it will return its default value.
  mutating func clearNewMfaresponse() {self._newMfaresponse = nil}

  /// DeviceUsage is the requested usage for the device.
  /// Defaults to DEVICE_USAGE_MFA.
  var deviceUsage: Proto_DeviceUsage = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contextUser: Proto_ContextUser? = nil
  fileprivate var _newMfaresponse: Proto_MFARegisterResponse? = nil
}

/// AddMFADeviceSyncResponse is a response to AddMFADeviceSyncRequest.
struct Proto_AddMFADeviceSyncResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var device: Types_MFADevice {
    get {return _device ?? Types_MFADevice()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _device: Types_MFADevice? = nil
}

/// GetMFADeviceRequest is a request for MFA devices for the calling user.
struct Proto_GetMFADevicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TokenID is an optional field for the ID of a user token that will be used to
  /// verify this request. Token is only required if an unauthenticated user wants to view their
  /// list of devices eg: during account recovery process. An empty field implies the logged in
  /// user wants to view their devices.
  /// Token types accepted are:
  ///  - Recovery approved token that is obtained after successful invocation of RPC
  ///  VerifyAccountRecovery
  var tokenID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetMFADeviceResponse is a response for GetMFADevices RPC.
struct Proto_GetMFADevicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var devices: [Types_MFADevice] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UserSingleUseCertsRequest is a request for a single-use user certificate.
///
/// Deprecated: Use [AuthService.GenerateUserCerts] instead.
struct Proto_UserSingleUseCertsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Proto_UserSingleUseCertsRequest.OneOf_Request? = nil

  var init_p: Proto_UserCertsRequest {
    get {
      if case .init_p(let v)? = request {return v}
      return Proto_UserCertsRequest()
    }
    set {request = .init_p(newValue)}
  }

  var mfaresponse: Proto_MFAAuthenticateResponse {
    get {
      if case .mfaresponse(let v)? = request {return v}
      return Proto_MFAAuthenticateResponse()
    }
    set {request = .mfaresponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case init_p(Proto_UserCertsRequest)
    case mfaresponse(Proto_MFAAuthenticateResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_UserSingleUseCertsRequest.OneOf_Request, rhs: Proto_UserSingleUseCertsRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.init_p, .init_p): return {
        guard case .init_p(let l) = lhs, case .init_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mfaresponse, .mfaresponse): return {
        guard case .mfaresponse(let l) = lhs, case .mfaresponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// UserSingleUseCertsResponse is a response with a single-use user certificate.
///
/// Deprecated: Use [AuthService.GenerateUserCerts] instead.
struct Proto_UserSingleUseCertsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Proto_UserSingleUseCertsResponse.OneOf_Response? = nil

  var mfachallenge: Proto_MFAAuthenticateChallenge {
    get {
      if case .mfachallenge(let v)? = response {return v}
      return Proto_MFAAuthenticateChallenge()
    }
    set {response = .mfachallenge(newValue)}
  }

  var cert: Proto_SingleUseUserCert {
    get {
      if case .cert(let v)? = response {return v}
      return Proto_SingleUseUserCert()
    }
    set {response = .cert(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case mfachallenge(Proto_MFAAuthenticateChallenge)
    case cert(Proto_SingleUseUserCert)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_UserSingleUseCertsResponse.OneOf_Response, rhs: Proto_UserSingleUseCertsResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mfachallenge, .mfachallenge): return {
        guard case .mfachallenge(let l) = lhs, case .mfachallenge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cert, .cert): return {
        guard case .cert(let l) = lhs, case .cert(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// IsMFARequiredRequest is a request to check whether MFA is required to access
/// the Target.
struct Proto_IsMFARequiredRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var target: Proto_IsMFARequiredRequest.OneOf_Target? = nil

  /// KubernetesCluster specifies the target kubernetes cluster.
  var kubernetesCluster: String {
    get {
      if case .kubernetesCluster(let v)? = target {return v}
      return String()
    }
    set {target = .kubernetesCluster(newValue)}
  }

  /// RouteToDatabase specifies the target database proxy name.
  var database: Proto_RouteToDatabase {
    get {
      if case .database(let v)? = target {return v}
      return Proto_RouteToDatabase()
    }
    set {target = .database(newValue)}
  }

  /// Node specifies the target SSH node.
  var node: Proto_NodeLogin {
    get {
      if case .node(let v)? = target {return v}
      return Proto_NodeLogin()
    }
    set {target = .node(newValue)}
  }

  /// WindowsDesktop specifies the target Windows Desktop.
  var windowsDesktop: Proto_RouteToWindowsDesktop {
    get {
      if case .windowsDesktop(let v)? = target {return v}
      return Proto_RouteToWindowsDesktop()
    }
    set {target = .windowsDesktop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable {
    /// KubernetesCluster specifies the target kubernetes cluster.
    case kubernetesCluster(String)
    /// RouteToDatabase specifies the target database proxy name.
    case database(Proto_RouteToDatabase)
    /// Node specifies the target SSH node.
    case node(Proto_NodeLogin)
    /// WindowsDesktop specifies the target Windows Desktop.
    case windowsDesktop(Proto_RouteToWindowsDesktop)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_IsMFARequiredRequest.OneOf_Target, rhs: Proto_IsMFARequiredRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.kubernetesCluster, .kubernetesCluster): return {
        guard case .kubernetesCluster(let l) = lhs, case .kubernetesCluster(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.database, .database): return {
        guard case .database(let l) = lhs, case .database(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.node, .node): return {
        guard case .node(let l) = lhs, case .node(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsDesktop, .windowsDesktop): return {
        guard case .windowsDesktop(let l) = lhs, case .windowsDesktop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// StreamSessionEventsRequest is a request containing needed data to fetch a session recording.
struct Proto_StreamSessionEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is the ID for a given session in an UUIDv4 format.
  var sessionID: String = String()

  /// StartIndex is the index of the event to resume the stream after.
  /// A StartIndex of 0 creates a new stream.
  var startIndex: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NodeLogin specifies an SSH node and OS login.
struct Proto_NodeLogin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Node can be node's hostname or UUID.
  var node: String = String()

  /// Login is the OS login name.
  var login: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// IsMFARequiredResponse is a response for MFA requirement check.
struct Proto_IsMFARequiredResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required is a simplified view over [MFARequired].
  var required: Bool = false

  /// MFARequired informs whether MFA is required to access the corresponding
  /// resource.
  var mfarequired: Proto_MFARequired = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SingleUseUserCert is a single-use user certificate, either SSH or TLS.
struct Proto_SingleUseUserCert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cert: Proto_SingleUseUserCert.OneOf_Cert? = nil

  var ssh: Data {
    get {
      if case .ssh(let v)? = cert {return v}
      return Data()
    }
    set {cert = .ssh(newValue)}
  }

  var tls: Data {
    get {
      if case .tls(let v)? = cert {return v}
      return Data()
    }
    set {cert = .tls(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Cert: Equatable {
    case ssh(Data)
    case tls(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_SingleUseUserCert.OneOf_Cert, rhs: Proto_SingleUseUserCert.OneOf_Cert) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ssh, .ssh): return {
        guard case .ssh(let l) = lhs, case .ssh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tls, .tls): return {
        guard case .tls(let l) = lhs, case .tls(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Proto_GetEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace, if not set, defaults to 'default'
  var namespace: String = String()

  /// StartDate is the oldest date of returned events
  var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  var hasStartDate: Bool {return self._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  mutating func clearStartDate() {self._startDate = nil}

  /// EndDate is the newest date of returned events
  var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  var hasEndDate: Bool {return self._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  mutating func clearEndDate() {self._endDate = nil}

  /// EventTypes is optional, if not set, returns all events
  var eventTypes: [String] = []

  /// Limit is the maximum amount of events returned
  var limit: Int32 = 0

  /// StartKey is used to resume a query in order to enable pagination.
  /// If the previous response had LastKey set then this should be
  /// set to its value. Otherwise leave empty.
  var startKey: String = String()

  /// Order specifies an ascending or descending order of events.
  /// A value of 0 means a descending order and a value of 1 means an ascending order.
  var order: Proto_Order = .descending

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Proto_GetSessionEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// StartDate is the oldest date of returned events
  var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  var hasStartDate: Bool {return self._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  mutating func clearStartDate() {self._startDate = nil}

  /// EndDate is the newest date of returned events
  var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  var hasEndDate: Bool {return self._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  mutating func clearEndDate() {self._endDate = nil}

  /// Limit is the maximum amount of events to retrieve.
  var limit: Int32 = 0

  /// StartKey is used to resume a query in order to enable pagination.
  /// If the previous response had LastKey set then this should be
  /// set to its value. Otherwise leave empty.
  var startKey: String = String()

  /// Order specifies an ascending or descending order of events.
  /// A value of 0 means a descending order and a value of 1 means an ascending order.
  var order: Proto_Order = .descending

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Proto_Events {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Items is a list of typed gRPC formatted audit events.
  var items: [Events_OneOf] = []

  /// the key of the last event if the returned set did not contain all events found i.e limit <
  /// actual amount. this is the key clients can supply in another API request to continue fetching
  /// events from the previous last position
  var lastKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_GetLocksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Targets is a list of targets. Every returned lock must match at least
  /// one of the targets.
  var targets: [Types_LockTarget] = []

  /// InForceOnly specifies whether to return only those locks that are in force.
  var inForceOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_GetLocksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Locks is a list of locks.
  var locks: [Types_LockV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_GetLockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the lock to get.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_DeleteLockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the lock to delete.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_ReplaceRemoteLocksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusterName identifies the cluster from which the locks originate.
  var clusterName: String = String()

  /// Locks is a list of new remote locks to store.
  var locks: [Types_LockV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetWindowsDesktopServicesResponse contains all registered Windows desktop services.
struct Proto_GetWindowsDesktopServicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Services is a list of Windows desktop services.
  var services: [Types_WindowsDesktopServiceV3] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetWindowsDesktopServiceRequest is a request for a specific Windows Desktop Service.
struct Proto_GetWindowsDesktopServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the Windows Desktop Service to be requested.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetWindowsDesktopServiceResponse contains the requested WindowsDesktopService
struct Proto_GetWindowsDesktopServiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Service is the requested Windows Desktop Service.
  var service: Types_WindowsDesktopServiceV3 {
    get {return _service ?? Types_WindowsDesktopServiceV3()}
    set {_service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  var hasService: Bool {return self._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  mutating func clearService() {self._service = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _service: Types_WindowsDesktopServiceV3? = nil
}

/// DeleteWindowsDesktopServiceRequest is a request to delete a Windows desktop service.
struct Proto_DeleteWindowsDesktopServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the Windows desktop service name.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetWindowsDesktopsResponse contains all registered Windows desktop hosts.
struct Proto_GetWindowsDesktopsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Servers is a list of Windows desktop hosts.
  var desktops: [Types_WindowsDesktopV3] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteWindowsDesktopRequest is a request to delete a Windows
/// desktop host. If HostID is not specified, all Windows desktops with
/// specified Name will be deleted
struct Proto_DeleteWindowsDesktopRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the Windows desktop host.
  var name: String = String()

  /// HostID is the ID of the Windows Desktop Service reporting the desktop.
  var hostID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WindowsDesktopCertRequest is a request to generate a client certificate used
/// for Windows RDP authentication.
struct Proto_WindowsDesktopCertRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CSR is the request to sign in PEM format.
  var csr: Data = Data()

  /// CRLEndpoint is the address of the CRL for this certificate.
  var crlendpoint: String = String()

  /// TTL is the certificate validity period.
  var ttl: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WindowsDesktopCertResponse contains the signed Windows RDP certificate.
struct Proto_WindowsDesktopCertResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cert is the signed certificate in PEM format.
  var cert: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListSAMLIdPServiceProvidersRequest is a request for a paginated list of SAML IdP service providers.
struct Proto_ListSAMLIdPServiceProvidersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Limit is the maximum amount of resources to retrieve.
  var limit: Int32 = 0

  /// NextKey is the key for the next page of SAML IdP service providers.
  var nextKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListSAMLIdPServiceProvidersResponse a paginated list of SAML IdP service providers.
struct Proto_ListSAMLIdPServiceProvidersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Servers is a list of SAML IdP service providers.
  var serviceProviders: [Types_SAMLIdPServiceProviderV1] = []

  /// NextKey is the key for the next page of SAML IdP service providers.
  var nextKey: String = String()

  /// TotalCount is the total number of resources available after filter, if any.
  var totalCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSAMLIdPServiceProviderRequest is a request for a specific SAML IdP service provider resource.
struct Proto_GetSAMLIdPServiceProviderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the SAML IdP sercice provider to be requested.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteSAMLIdPServiceProviderRequest is a request for deleting a specific SAML IdP service provider resource.
struct Proto_DeleteSAMLIdPServiceProviderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the SAML IdP sercice provider to be deleted.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListUserGroupsRequest is a request for a paginated list of user groups.
struct Proto_ListUserGroupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Limit is the maximum amount of resources to retrieve.
  var limit: Int32 = 0

  /// NextKey is the key for the next page of user groups.
  var nextKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListUserGroupsResponse a paginated list of user groups.
struct Proto_ListUserGroupsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UserGroups is a list of user groups.
  var userGroups: [Types_UserGroupV1] = []

  /// NextKey is the key for the next page of user groups.
  var nextKey: String = String()

  /// TotalCount is the total number of resources available after filter, if any.
  var totalCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetUserGroupRequest is a request for a specific user group resource.
struct Proto_GetUserGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the user group to be requested.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteUserGroupRequest is a request for deleting a specific user group resource.
struct Proto_DeleteUserGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the user group to be deleted.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CertAuthorityRequest is a request that identifies a Teleport CA.
struct Proto_CertAuthorityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is either user or host certificate authority.
  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CRL is the X.509 Certificate Revocation List.
struct Proto_CRL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CRL is the Certificate Revocation List in DER format.
  var crl: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ChangeUserAuthenticationRequest defines a request to change a password and if enabled
/// also adds a new MFA device from a user reset or from a new user invite. User can also skip
/// setting a new password if passwordless is enabled and just provide a new webauthn register
/// response.
///
/// After a successful request a new web session is created.
///
/// Users may also receive new recovery codes if they meet the necessary requirements. If a user
/// previously had recovery codes, the previous codes become invalid as it is replaced with newly
/// generated ones.
struct Proto_ChangeUserAuthenticationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TokenID is the ID of a reset or invite token.
  /// The token allows the user to change their credentials without being logged
  /// in.
  var tokenID: String = String()

  /// NewPassword is the new password in plain text.
  var newPassword: Data = Data()

  /// NewMFARegisterResponse is a MFA response to a MFA authentication challenge.
  /// This field can be empty which implies that user chose not to add a new device (allowable when
  /// cluster settings enable optional second factor), or cluster settings disabled second factor.
  var newMfaregisterResponse: Proto_MFARegisterResponse {
    get {return _newMfaregisterResponse ?? Proto_MFARegisterResponse()}
    set {_newMfaregisterResponse = newValue}
  }
  /// Returns true if `newMfaregisterResponse` has been explicitly set.
  var hasNewMfaregisterResponse: Bool {return self._newMfaregisterResponse != nil}
  /// Clears the value of `newMfaregisterResponse`. Subsequent reads from it will return its default value.
  mutating func clearNewMfaregisterResponse() {self._newMfaregisterResponse = nil}

  /// NewDeviceName is the name of a new mfa or passwordless device.
  var newDeviceName: String = String()

  /// LoginIP is an IP that will be embedded in the new client's certificate for web session if successful.
  var loginIp: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newMfaregisterResponse: Proto_MFARegisterResponse? = nil
}

/// ChangeUserAuthenticationResponse is a response for ChangeUserAuthentication.
struct Proto_ChangeUserAuthenticationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// WebSession is a user's web sesssion created from successful changing of password.
  var webSession: Types_WebSessionV2 {
    get {return _webSession ?? Types_WebSessionV2()}
    set {_webSession = newValue}
  }
  /// Returns true if `webSession` has been explicitly set.
  var hasWebSession: Bool {return self._webSession != nil}
  /// Clears the value of `webSession`. Subsequent reads from it will return its default value.
  mutating func clearWebSession() {self._webSession = nil}

  /// Recovery holds user's new recovery related fields. Previous recovery codes become invalid.
  /// This field can be empty if a user does not meet the following
  /// requirements to receive recovery codes:
  ///  - cloud feature is enabled
  ///  - username is in valid email format
  var recovery: Proto_RecoveryCodes {
    get {return _recovery ?? Proto_RecoveryCodes()}
    set {_recovery = newValue}
  }
  /// Returns true if `recovery` has been explicitly set.
  var hasRecovery: Bool {return self._recovery != nil}
  /// Clears the value of `recovery`. Subsequent reads from it will return its default value.
  mutating func clearRecovery() {self._recovery = nil}

  /// PrivateKeyPolicyEnabled is a flag that when true means one of the private key policy was
  /// set in either through cluster config or through a user's assigned role.
  var privateKeyPolicyEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _webSession: Types_WebSessionV2? = nil
  fileprivate var _recovery: Proto_RecoveryCodes? = nil
}

/// StartAccountRecoveryRequest defines a request to create a recovery start token for a user who is
/// allowed to recover their account. The tokens ID is used as part of a URL that will be emailed to
/// the user (not done in this request). Represents step 1 of the account recovery process, next step
/// is RPC VerifyAccountRecovery.
struct Proto_StartAccountRecoveryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Username is the requesting user. The username must meet the following requirements to be
  /// allowed to recover their account:
  ///  - cloud feature is enabled
  ///  - username is in valid email format
  var username: String = String()

  /// RecoveryCode is one of the user's recovery code in plain text.
  var recoveryCode: Data = Data()

  /// RecoverType defines what type of authentication user needs to recover.
  var recoverType: Types_UserTokenUsage = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// VerifyAccountRecoveryRequest is a request to create a recovery approved token that allows users
/// to perform protected actions while not logged in. Represents step 2 of the account recovery
/// process after RPC StartAccountRecovery, next step is RPC CompleteAccountRecovery.
struct Proto_VerifyAccountRecoveryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RecoveryStartTokenID is the ID of a recovery start token that's required to verify this
  /// request.
  var recoveryStartTokenID: String = String()

  /// Username is the name of the user that the token belongs to, used to verify that this name
  /// is the same as defined in token for use with emails.
  var username: String = String()

  /// AuthnCred is the authentication cred that needs to be verified.
  var authnCred: Proto_VerifyAccountRecoveryRequest.OneOf_AuthnCred? = nil

  /// Password is users password in plain text.
  var password: Data {
    get {
      if case .password(let v)? = authnCred {return v}
      return Data()
    }
    set {authnCred = .password(newValue)}
  }

  /// MFAAuthenticateResponse is a response to a MFA challenge.
  var mfaauthenticateResponse: Proto_MFAAuthenticateResponse {
    get {
      if case .mfaauthenticateResponse(let v)? = authnCred {return v}
      return Proto_MFAAuthenticateResponse()
    }
    set {authnCred = .mfaauthenticateResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// AuthnCred is the authentication cred that needs to be verified.
  enum OneOf_AuthnCred: Equatable {
    /// Password is users password in plain text.
    case password(Data)
    /// MFAAuthenticateResponse is a response to a MFA challenge.
    case mfaauthenticateResponse(Proto_MFAAuthenticateResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_VerifyAccountRecoveryRequest.OneOf_AuthnCred, rhs: Proto_VerifyAccountRecoveryRequest.OneOf_AuthnCred) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.password, .password): return {
        guard case .password(let l) = lhs, case .password(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mfaauthenticateResponse, .mfaauthenticateResponse): return {
        guard case .mfaauthenticateResponse(let l) = lhs, case .mfaauthenticateResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// CompleteAccountRecoveryRequest is a request to set either a new password or
/// add a new mfa device, allowing the user to regain access to their account with the new
/// credentials. Represents the last step in the account recovery process after RPC's
/// StartAccountRecovery and VerifyAccountRecovery.
struct Proto_CompleteAccountRecoveryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RecoveryApprovedTokenID is the ID of a recovery approved token that's required to verify this
  /// request.
  var recoveryApprovedTokenID: String = String()

  /// NewDeviceName is the name of a new mfa device.
  /// Optional if NewPassword is used.
  var newDeviceName: String = String()

  /// NewAuthnCred contains the new authentication credential.
  var newAuthnCred: Proto_CompleteAccountRecoveryRequest.OneOf_NewAuthnCred? = nil

  /// NewPassword is user's new password in plain text.
  var newPassword: Data {
    get {
      if case .newPassword(let v)? = newAuthnCred {return v}
      return Data()
    }
    set {newAuthnCred = .newPassword(newValue)}
  }

  /// NewMFAResponse is a user's new mfa response to a mfa register challenge.
  var newMfaresponse: Proto_MFARegisterResponse {
    get {
      if case .newMfaresponse(let v)? = newAuthnCred {return v}
      return Proto_MFARegisterResponse()
    }
    set {newAuthnCred = .newMfaresponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// NewAuthnCred contains the new authentication credential.
  enum OneOf_NewAuthnCred: Equatable {
    /// NewPassword is user's new password in plain text.
    case newPassword(Data)
    /// NewMFAResponse is a user's new mfa response to a mfa register challenge.
    case newMfaresponse(Proto_MFARegisterResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_CompleteAccountRecoveryRequest.OneOf_NewAuthnCred, rhs: Proto_CompleteAccountRecoveryRequest.OneOf_NewAuthnCred) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.newPassword, .newPassword): return {
        guard case .newPassword(let l) = lhs, case .newPassword(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newMfaresponse, .newMfaresponse): return {
        guard case .newMfaresponse(let l) = lhs, case .newMfaresponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// RecoveryCodes describes account recovery fields. Used as a RPC
/// response or as part of a RPC response that requires any of these fields.
struct Proto_RecoveryCodes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Codes holds the list of recovery phrase words.
  /// Field is only used when new recovery codes are generated and returned to user.
  var codes: [String] = []

  /// Created is the date the recovery codes were created.
  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// CreateAccountRecoveryCodesRequest is a request to create new set of recovery codes for a user,
/// replacing and invalidating any previously existing codes. Recovery codes can only be given to
/// users who meet the following requirements:
///  - cloud feature is enabled
///  - username is in valid email format
struct Proto_CreateAccountRecoveryCodesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TokenID is the ID of a user token that will be used to verify this request.
  /// Token types accepted are:
  ///   - Recovery approved token that is obtained with RPC VerifyAccountRecovery
  ///   - Privilege token that is obtained with RPC CreatePrivilegeToken
  var tokenID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccountRecoveryTokenRequest is a request to return a user token resource after verifying that
/// the token in the request is not expired and is of the recovery kind.
struct Proto_GetAccountRecoveryTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RecoveryTokenID is the ID of a recovery token to verify.
  /// Recovery tokens are obtained with RPC StartAccountRecovery or VerifyAccountRecovery.
  var recoveryTokenID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAccountRecoveryCodesRequest is a request to return the user in context their
/// recovery codes. This request will not return any secrets (the values of recovery codes).
struct Proto_GetAccountRecoveryCodesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UserCredentials describes fields for a user's username and password.
struct Proto_UserCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var password: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ContextUser marks requests that rely in the currently authenticated user.
struct Proto_ContextUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Passwordless marks requests for passwordless challenges.
struct Proto_Passwordless {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateAuthenticateChallengeRequest is a request for creating MFA authentication challenges for a
/// users mfa devices.
struct Proto_CreateAuthenticateChallengeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request defines how the request will be verified before creating challenges.
  /// An empty Request is equivalent to context_user being set.
  var request: Proto_CreateAuthenticateChallengeRequest.OneOf_Request? = nil

  /// UserCredentials verifies request with username and password. Used with logins or
  /// when the logged in user wants to change their password.
  var userCredentials: Proto_UserCredentials {
    get {
      if case .userCredentials(let v)? = request {return v}
      return Proto_UserCredentials()
    }
    set {request = .userCredentials(newValue)}
  }

  /// RecoveryStartTokenID is the ID of a recovery start token obtained with RPC
  /// StartAccountRecovery. This token allows a user to retrieve their MFA challenges for RPC
  /// VerifyAccountRecovery (step 2 of the recovery process after RPC StartAccountRecovery).
  var recoveryStartTokenID: String {
    get {
      if case .recoveryStartTokenID(let v)? = request {return v}
      return String()
    }
    set {request = .recoveryStartTokenID(newValue)}
  }

  /// ContextUser issues a challenge for the currently-authenticated user.
  /// Default option if no other is provided.
  var contextUser: Proto_ContextUser {
    get {
      if case .contextUser(let v)? = request {return v}
      return Proto_ContextUser()
    }
    set {request = .contextUser(newValue)}
  }

  /// Passwordless issues a passwordless challenge (authenticated user not
  /// required).
  var passwordless: Proto_Passwordless {
    get {
      if case .passwordless(let v)? = request {return v}
      return Proto_Passwordless()
    }
    set {request = .passwordless(newValue)}
  }

  /// MFARequiredCheck, if set, is used to verify if MFA is necessary for the
  /// request. It's akin to a call to [AuthService.IsMFARequired].
  ///
  /// If MFA is not required, then no challenges are issued in the
  /// [MFAAuthenticateResponse].
  ///
  /// MFA verification should run in the cluster that holds the target resource.
  /// If you are issuing challenges from the root cluster, but accessing a leaf,
  /// call [AuthService.IsMFARequired] in the leaf instead of setting this field.
  var mfarequiredCheck: Proto_IsMFARequiredRequest {
    get {return _mfarequiredCheck ?? Proto_IsMFARequiredRequest()}
    set {_mfarequiredCheck = newValue}
  }
  /// Returns true if `mfarequiredCheck` has been explicitly set.
  var hasMfarequiredCheck: Bool {return self._mfarequiredCheck != nil}
  /// Clears the value of `mfarequiredCheck`. Subsequent reads from it will return its default value.
  mutating func clearMfarequiredCheck() {self._mfarequiredCheck = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Request defines how the request will be verified before creating challenges.
  /// An empty Request is equivalent to context_user being set.
  enum OneOf_Request: Equatable {
    /// UserCredentials verifies request with username and password. Used with logins or
    /// when the logged in user wants to change their password.
    case userCredentials(Proto_UserCredentials)
    /// RecoveryStartTokenID is the ID of a recovery start token obtained with RPC
    /// StartAccountRecovery. This token allows a user to retrieve their MFA challenges for RPC
    /// VerifyAccountRecovery (step 2 of the recovery process after RPC StartAccountRecovery).
    case recoveryStartTokenID(String)
    /// ContextUser issues a challenge for the currently-authenticated user.
    /// Default option if no other is provided.
    case contextUser(Proto_ContextUser)
    /// Passwordless issues a passwordless challenge (authenticated user not
    /// required).
    case passwordless(Proto_Passwordless)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_CreateAuthenticateChallengeRequest.OneOf_Request, rhs: Proto_CreateAuthenticateChallengeRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.userCredentials, .userCredentials): return {
        guard case .userCredentials(let l) = lhs, case .userCredentials(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.recoveryStartTokenID, .recoveryStartTokenID): return {
        guard case .recoveryStartTokenID(let l) = lhs, case .recoveryStartTokenID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contextUser, .contextUser): return {
        guard case .contextUser(let l) = lhs, case .contextUser(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.passwordless, .passwordless): return {
        guard case .passwordless(let l) = lhs, case .passwordless(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _mfarequiredCheck: Proto_IsMFARequiredRequest? = nil
}

/// CreatePrivilegeTokenRequest defines a request to obtain a privilege token.
/// Only logged in users are allowed to obtain privilege tokens after they have successfully
/// re-authenticated with their second factor.
struct Proto_CreatePrivilegeTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ExistingMFAResponse is a response to a challenge from the user's existing MFA devices.
  /// This field can be empty to create a UserTokenTypePrivilegeException token that
  /// allows a user to bypass second factor re-authentication eg: allowing a user
  /// with no mfa devices to add a device without re-authenticating.
  var existingMfaresponse: Proto_MFAAuthenticateResponse {
    get {return _existingMfaresponse ?? Proto_MFAAuthenticateResponse()}
    set {_existingMfaresponse = newValue}
  }
  /// Returns true if `existingMfaresponse` has been explicitly set.
  var hasExistingMfaresponse: Bool {return self._existingMfaresponse != nil}
  /// Clears the value of `existingMfaresponse`. Subsequent reads from it will return its default value.
  mutating func clearExistingMfaresponse() {self._existingMfaresponse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _existingMfaresponse: Proto_MFAAuthenticateResponse? = nil
}

/// CreateRegisterChallengeRequest is a request for creating MFA register challenge for a
/// new MFA device.
struct Proto_CreateRegisterChallengeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TokenID is the ID of a user token that will be used to verify this request.
  /// Either TokenID or ExistingMFAResponse are required.
  ///
  /// All user token types are accepted except UserTokenTypeRecoveryStart.
  ///
  /// An authenticated user can create challenges without a token by supplying an
  /// ExistingMFAResponse.
  var tokenID: String = String()

  /// ExistingMFAResponse is a response to ExistingMFAChallenge auth challenge.
  /// Either ExistingMFAResponse or TokenID are required.
  ///
  /// Note that a user with no devices can create the initial register challenge,
  /// in the same manner that they could create a privilege token.
  ///
  /// See the [AuthService.CreateAuthenticateChallenge] RPC.
  var existingMfaresponse: Proto_MFAAuthenticateResponse {
    get {return _existingMfaresponse ?? Proto_MFAAuthenticateResponse()}
    set {_existingMfaresponse = newValue}
  }
  /// Returns true if `existingMfaresponse` has been explicitly set.
  var hasExistingMfaresponse: Bool {return self._existingMfaresponse != nil}
  /// Clears the value of `existingMfaresponse`. Subsequent reads from it will return its default value.
  mutating func clearExistingMfaresponse() {self._existingMfaresponse = nil}

  /// DeviceType is the type of MFA device to make a register challenge for.
  var deviceType: Proto_DeviceType = .unspecified

  /// DeviceUsage is the requested usage for the device.
  /// Defaults to DEVICE_USAGE_MFA.
  var deviceUsage: Proto_DeviceUsage = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _existingMfaresponse: Proto_MFAAuthenticateResponse? = nil
}

/// PaginatedResource represents one of the supported resources.
struct Proto_PaginatedResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource is the resource itself.
  var resource: Proto_PaginatedResource.OneOf_Resource? = nil

  /// DatabaseServer represents a DatabaseServer resource.
  var databaseServer: Types_DatabaseServerV3 {
    get {
      if case .databaseServer(let v)? = resource {return v}
      return Types_DatabaseServerV3()
    }
    set {resource = .databaseServer(newValue)}
  }

  /// AppServer represents a AppServer resource.
  var appServer: Types_AppServerV3 {
    get {
      if case .appServer(let v)? = resource {return v}
      return Types_AppServerV3()
    }
    set {resource = .appServer(newValue)}
  }

  /// Nodes represents a Server resource.
  var node: Types_ServerV2 {
    get {
      if case .node(let v)? = resource {return v}
      return Types_ServerV2()
    }
    set {resource = .node(newValue)}
  }

  /// WindowsDesktop represents a WindowsDesktop resource.
  var windowsDesktop: Types_WindowsDesktopV3 {
    get {
      if case .windowsDesktop(let v)? = resource {return v}
      return Types_WindowsDesktopV3()
    }
    set {resource = .windowsDesktop(newValue)}
  }

  /// KubeCluster represents a KubeCluster resource.
  var kubeCluster: Types_KubernetesClusterV3 {
    get {
      if case .kubeCluster(let v)? = resource {return v}
      return Types_KubernetesClusterV3()
    }
    set {resource = .kubeCluster(newValue)}
  }

  /// KubernetesServer represents a Kubernetes Server resource.
  var kubernetesServer: Types_KubernetesServerV3 {
    get {
      if case .kubernetesServer(let v)? = resource {return v}
      return Types_KubernetesServerV3()
    }
    set {resource = .kubernetesServer(newValue)}
  }

  /// WindowsDesktopService represents a WindowsDesktopServiceV3 resource.
  var windowsDesktopService: Types_WindowsDesktopServiceV3 {
    get {
      if case .windowsDesktopService(let v)? = resource {return v}
      return Types_WindowsDesktopServiceV3()
    }
    set {resource = .windowsDesktopService(newValue)}
  }

  /// DatabaseService represents a DatabaseService resource.
  var databaseService: Types_DatabaseServiceV1 {
    get {
      if case .databaseService(let v)? = resource {return v}
      return Types_DatabaseServiceV1()
    }
    set {resource = .databaseService(newValue)}
  }

  /// UserGroup represents a UserGroup resource.
  var userGroup: Types_UserGroupV1 {
    get {
      if case .userGroup(let v)? = resource {return v}
      return Types_UserGroupV1()
    }
    set {resource = .userGroup(newValue)}
  }

  /// AppServerOrSAMLIdPServiceProvider represents either an AppServer or a SAML IdP Service Provider resource.
  var appServerOrSamlidPserviceProvider: Types_AppServerOrSAMLIdPServiceProviderV1 {
    get {
      if case .appServerOrSamlidPserviceProvider(let v)? = resource {return v}
      return Types_AppServerOrSAMLIdPServiceProviderV1()
    }
    set {resource = .appServerOrSamlidPserviceProvider(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Resource is the resource itself.
  enum OneOf_Resource: Equatable {
    /// DatabaseServer represents a DatabaseServer resource.
    case databaseServer(Types_DatabaseServerV3)
    /// AppServer represents a AppServer resource.
    case appServer(Types_AppServerV3)
    /// Nodes represents a Server resource.
    case node(Types_ServerV2)
    /// WindowsDesktop represents a WindowsDesktop resource.
    case windowsDesktop(Types_WindowsDesktopV3)
    /// KubeCluster represents a KubeCluster resource.
    case kubeCluster(Types_KubernetesClusterV3)
    /// KubernetesServer represents a Kubernetes Server resource.
    case kubernetesServer(Types_KubernetesServerV3)
    /// WindowsDesktopService represents a WindowsDesktopServiceV3 resource.
    case windowsDesktopService(Types_WindowsDesktopServiceV3)
    /// DatabaseService represents a DatabaseService resource.
    case databaseService(Types_DatabaseServiceV1)
    /// UserGroup represents a UserGroup resource.
    case userGroup(Types_UserGroupV1)
    /// AppServerOrSAMLIdPServiceProvider represents either an AppServer or a SAML IdP Service Provider resource.
    case appServerOrSamlidPserviceProvider(Types_AppServerOrSAMLIdPServiceProviderV1)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_PaginatedResource.OneOf_Resource, rhs: Proto_PaginatedResource.OneOf_Resource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.databaseServer, .databaseServer): return {
        guard case .databaseServer(let l) = lhs, case .databaseServer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appServer, .appServer): return {
        guard case .appServer(let l) = lhs, case .appServer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.node, .node): return {
        guard case .node(let l) = lhs, case .node(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsDesktop, .windowsDesktop): return {
        guard case .windowsDesktop(let l) = lhs, case .windowsDesktop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kubeCluster, .kubeCluster): return {
        guard case .kubeCluster(let l) = lhs, case .kubeCluster(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kubernetesServer, .kubernetesServer): return {
        guard case .kubernetesServer(let l) = lhs, case .kubernetesServer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsDesktopService, .windowsDesktopService): return {
        guard case .windowsDesktopService(let l) = lhs, case .windowsDesktopService(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseService, .databaseService): return {
        guard case .databaseService(let l) = lhs, case .databaseService(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userGroup, .userGroup): return {
        guard case .userGroup(let l) = lhs, case .userGroup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appServerOrSamlidPserviceProvider, .appServerOrSamlidPserviceProvider): return {
        guard case .appServerOrSamlidPserviceProvider(let l) = lhs, case .appServerOrSamlidPserviceProvider(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// ListUnifiedResourcesRequest is a request to receive a paginated list of unified resources
struct Proto_ListUnifiedResourcesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kinds is a list of kinds to match against a resource's kind. This can be used in a
  /// unified resource request that can include multiple types.
  var kinds: [String] = []

  /// Limit is the maximum amount of resources to retrieve.
  var limit: Int32 = 0

  /// StartKey is used to start listing resources from a specific spot. It
  /// should be set to the previous NextKey value if using pagination, or
  /// left empty.
  var startKey: String = String()

  /// Labels is a label-based matcher if non-empty.
  var labels: Dictionary<String,String> = [:]

  /// PredicateExpression defines boolean conditions that will be matched against the resource.
  var predicateExpression: String = String()

  /// SearchKeywords is a list of search keywords to match against resource field values.
  var searchKeywords: [String] = []

  /// SortBy describes which resource field and which direction to sort by.
  var sortBy: Types_SortBy {
    get {return _sortBy ?? Types_SortBy()}
    set {_sortBy = newValue}
  }
  /// Returns true if `sortBy` has been explicitly set.
  var hasSortBy: Bool {return self._sortBy != nil}
  /// Clears the value of `sortBy`. Subsequent reads from it will return its default value.
  mutating func clearSortBy() {self._sortBy = nil}

  /// WindowsDesktopFilter specifies windows desktop specific filters.
  var windowsDesktopFilter: Types_WindowsDesktopFilter {
    get {return _windowsDesktopFilter ?? Types_WindowsDesktopFilter()}
    set {_windowsDesktopFilter = newValue}
  }
  /// Returns true if `windowsDesktopFilter` has been explicitly set.
  var hasWindowsDesktopFilter: Bool {return self._windowsDesktopFilter != nil}
  /// Clears the value of `windowsDesktopFilter`. Subsequent reads from it will return its default value.
  mutating func clearWindowsDesktopFilter() {self._windowsDesktopFilter = nil}

  /// UseSearchAsRoles indicates that the response should include all resources
  /// the caller is able to request access to using search_as_roles
  var useSearchAsRoles: Bool = false

  /// UsePreviewAsRoles indicates that the response should include all resources
  /// the caller would be able to access with their preview_as_roles
  var usePreviewAsRoles: Bool = false

  /// PinnedOnly indicates that the request will pull only the pinned resources
  /// of the requesting user
  var pinnedOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sortBy: Types_SortBy? = nil
  fileprivate var _windowsDesktopFilter: Types_WindowsDesktopFilter? = nil
}

/// ListUnifiedResourceResponse response of ListUnifiedResources.
struct Proto_ListUnifiedResourcesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resources is a list of resource.
  var resources: [Proto_PaginatedResource] = []

  /// NextKey is the next Key to use as StartKey in a ListResourcesRequest to
  /// continue retrieving pages of resource. If NextKey is empty, there are no
  /// more pages.
  var nextKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListResourcesRequest defines a request to retrieve resources paginated. Only
/// one type of resource can be retrieved per request.
///
/// NOTE: There are two paths this request can take:
///  1. ListResources: the more efficient path that retrieves resources by subset
///  at a time defined by field 'Limit'. Does NOT de-duplicate matches.
///  2. listResourcesWithSort: the less efficient path that retrieves all resources
///  upfront by falling back to the traditional GetXXX calls. Used when sorting (SortBy),
///  total count of resources (NeedTotalCount), or ResourceType `KindKubernetesCluster`
///  is requested. Matches are de-duplicated.
struct Proto_ListResourcesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ResourceType is the resource that is going to be retrieved.
  /// This only needs to be set explicitly for the `ListResources` rpc.
  var resourceType: String = String()

  /// Namespace is the namespace of resources.
  var namespace: String = String()

  /// Limit is the maximum amount of resources to retrieve.
  var limit: Int32 = 0

  /// StartKey is used to start listing resources from a specific spot. It
  /// should be set to the previous NextKey value if using pagination, or
  /// left empty.
  var startKey: String = String()

  /// Labels is a label-based matcher if non-empty.
  var labels: Dictionary<String,String> = [:]

  /// PredicateExpression defines boolean conditions that will be matched against the resource.
  var predicateExpression: String = String()

  /// SearchKeywords is a list of search keywords to match against resource field values.
  var searchKeywords: [String] = []

  /// SortBy describes which resource field and which direction to sort by.
  var sortBy: Types_SortBy {
    get {return _sortBy ?? Types_SortBy()}
    set {_sortBy = newValue}
  }
  /// Returns true if `sortBy` has been explicitly set.
  var hasSortBy: Bool {return self._sortBy != nil}
  /// Clears the value of `sortBy`. Subsequent reads from it will return its default value.
  mutating func clearSortBy() {self._sortBy = nil}

  /// NeedTotalCount indicates whether or not the caller also wants the total number of resources
  /// after filtering.
  var needTotalCount: Bool = false

  /// WindowsDesktopFilter specifies windows desktop specific filters.
  var windowsDesktopFilter: Types_WindowsDesktopFilter {
    get {return _windowsDesktopFilter ?? Types_WindowsDesktopFilter()}
    set {_windowsDesktopFilter = newValue}
  }
  /// Returns true if `windowsDesktopFilter` has been explicitly set.
  var hasWindowsDesktopFilter: Bool {return self._windowsDesktopFilter != nil}
  /// Clears the value of `windowsDesktopFilter`. Subsequent reads from it will return its default value.
  mutating func clearWindowsDesktopFilter() {self._windowsDesktopFilter = nil}

  /// UseSearchAsRoles indicates that the response should include all resources
  /// the caller is able to request access to using search_as_roles
  var useSearchAsRoles: Bool = false

  /// UsePreviewAsRoles indicates that the response should include all resources
  /// the caller would be able to access with their preview_as_roles
  var usePreviewAsRoles: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sortBy: Types_SortBy? = nil
  fileprivate var _windowsDesktopFilter: Types_WindowsDesktopFilter? = nil
}

/// GetSSHTargetsRequest gets all servers that might match an equivalent ssh dial request.
struct Proto_GetSSHTargetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Host is the target host as would be sent to the proxy during a dial request.
  var host: String = String()

  /// Port is the ssh port. This value is optional, and both empty string and "0" are typically
  /// treated as meaning that any port should match.
  var port: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSSHTargetsResponse holds ssh servers that match an ssh targets request.
struct Proto_GetSSHTargetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Servers is a list of servers matching the supplied request.
  var servers: [Types_ServerV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListResourceResponse response of ListResources.
struct Proto_ListResourcesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resources is a list of resource.
  var resources: [Proto_PaginatedResource] = []

  /// NextKey is the next Key to use as StartKey in a ListResourcesRequest to
  /// continue retrieving pages of resource. If NextKey is empty, there are no
  /// more pages.
  var nextKey: String = String()

  /// TotalCount is the total number of resources available after filter, if any.
  var totalCount: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateSessionTrackerRequest is a request to create a new session.
///
/// This is not specific to any session type. Relevant fields should be set for a given session type.
struct Proto_CreateSessionTrackerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionTracker is the session tracker to be created.
  var sessionTracker: Types_SessionTrackerV1 {
    get {return _sessionTracker ?? Types_SessionTrackerV1()}
    set {_sessionTracker = newValue}
  }
  /// Returns true if `sessionTracker` has been explicitly set.
  var hasSessionTracker: Bool {return self._sessionTracker != nil}
  /// Clears the value of `sessionTracker`. Subsequent reads from it will return its default value.
  mutating func clearSessionTracker() {self._sessionTracker = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sessionTracker: Types_SessionTrackerV1? = nil
}

/// GetSessionTrackerRequest is a request to fetch a session resource.
struct Proto_GetSessionTrackerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is unique identifier of this session.
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RemoveSessionTrackerRequest is a request to remove a session.
struct Proto_RemoveSessionTrackerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is unique identifier of this session.
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SessionTrackerUpdateState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// State is the new state of the session tracker.
  var state: Types_SessionState = .pending

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Proto_SessionTrackerAddParticipant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Participant is the participant to be added to the session.
  var participant: Types_Participant {
    get {return _participant ?? Types_Participant()}
    set {_participant = newValue}
  }
  /// Returns true if `participant` has been explicitly set.
  var hasParticipant: Bool {return self._participant != nil}
  /// Clears the value of `participant`. Subsequent reads from it will return its default value.
  mutating func clearParticipant() {self._participant = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _participant: Types_Participant? = nil
}

struct Proto_SessionTrackerRemoveParticipant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ParticipantID is unique identifier of the participant.
  var participantID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SessionTrackerUpdateExpiry is used to update the session tracker expiration time.
struct Proto_SessionTrackerUpdateExpiry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Expires is when the session tracker will expire.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// UpdateSessionTrackerRequest is a request to update some state of a session.
struct Proto_UpdateSessionTrackerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is unique identifier of this session.
  var sessionID: String = String()

  var update: Proto_UpdateSessionTrackerRequest.OneOf_Update? = nil

  var updateState: Proto_SessionTrackerUpdateState {
    get {
      if case .updateState(let v)? = update {return v}
      return Proto_SessionTrackerUpdateState()
    }
    set {update = .updateState(newValue)}
  }

  var addParticipant: Proto_SessionTrackerAddParticipant {
    get {
      if case .addParticipant(let v)? = update {return v}
      return Proto_SessionTrackerAddParticipant()
    }
    set {update = .addParticipant(newValue)}
  }

  var removeParticipant: Proto_SessionTrackerRemoveParticipant {
    get {
      if case .removeParticipant(let v)? = update {return v}
      return Proto_SessionTrackerRemoveParticipant()
    }
    set {update = .removeParticipant(newValue)}
  }

  var updateExpiry: Proto_SessionTrackerUpdateExpiry {
    get {
      if case .updateExpiry(let v)? = update {return v}
      return Proto_SessionTrackerUpdateExpiry()
    }
    set {update = .updateExpiry(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Update: Equatable {
    case updateState(Proto_SessionTrackerUpdateState)
    case addParticipant(Proto_SessionTrackerAddParticipant)
    case removeParticipant(Proto_SessionTrackerRemoveParticipant)
    case updateExpiry(Proto_SessionTrackerUpdateExpiry)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_UpdateSessionTrackerRequest.OneOf_Update, rhs: Proto_UpdateSessionTrackerRequest.OneOf_Update) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.updateState, .updateState): return {
        guard case .updateState(let l) = lhs, case .updateState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addParticipant, .addParticipant): return {
        guard case .addParticipant(let l) = lhs, case .addParticipant(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeParticipant, .removeParticipant): return {
        guard case .removeParticipant(let l) = lhs, case .removeParticipant(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateExpiry, .updateExpiry): return {
        guard case .updateExpiry(let l) = lhs, case .updateExpiry(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// PresenceMFAChallengeRequest is a request for a presence MFA challenge.
struct Proto_PresenceMFAChallengeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is unique identifier of the session you want to request presence for.
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PresenceMFAChallengeSend is a presence challenge request or response.
struct Proto_PresenceMFAChallengeSend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Proto_PresenceMFAChallengeSend.OneOf_Request? = nil

  var challengeRequest: Proto_PresenceMFAChallengeRequest {
    get {
      if case .challengeRequest(let v)? = request {return v}
      return Proto_PresenceMFAChallengeRequest()
    }
    set {request = .challengeRequest(newValue)}
  }

  var challengeResponse: Proto_MFAAuthenticateResponse {
    get {
      if case .challengeResponse(let v)? = request {return v}
      return Proto_MFAAuthenticateResponse()
    }
    set {request = .challengeResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case challengeRequest(Proto_PresenceMFAChallengeRequest)
    case challengeResponse(Proto_MFAAuthenticateResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_PresenceMFAChallengeSend.OneOf_Request, rhs: Proto_PresenceMFAChallengeSend.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.challengeRequest, .challengeRequest): return {
        guard case .challengeRequest(let l) = lhs, case .challengeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.challengeResponse, .challengeResponse): return {
        guard case .challengeResponse(let l) = lhs, case .challengeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// GetDomainNameResponse is a response from GetDomainName.
struct Proto_GetDomainNameResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DomainName is the local auth domain of the current auth server.
  var domainName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetClusterCACertResponse is a response from GetClusterCACert.
struct Proto_GetClusterCACertResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TLSCA is a PEM-encoded TLS certificate authority.
  var tlsca: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetLicenseResponse is a response from GetLicense
struct Proto_GetLicenseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var license: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ListReleasesResponse is a response from ListReleases
struct Proto_ListReleasesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var releases: [Types_Release] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetOIDCAuthRequestRequest is a request for GetOIDCAuthRequest.
struct Proto_GetOIDCAuthRequestRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// StateToken is an oidc auth request state token.
  var stateToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetSAMLAuthRequestRequest is a request for GetSAMLAuthRequest.
struct Proto_GetSAMLAuthRequestRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is a saml auth request unique id.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetGithubAuthRequestRequest is a request for GetGithubAuthRequest.
struct Proto_GetGithubAuthRequestRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// StateToken is a github auth request state token.
  var stateToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateOIDCConnectorRequest is a request for CreateOIDCConnector.
struct Proto_CreateOIDCConnectorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connector to be created.
  var connector: Types_OIDCConnectorV3 {
    get {return _connector ?? Types_OIDCConnectorV3()}
    set {_connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  var hasConnector: Bool {return self._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  mutating func clearConnector() {self._connector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connector: Types_OIDCConnectorV3? = nil
}

/// UpdateOIDCConnectorRequest is a request for UpdateOIDCConnector.
struct Proto_UpdateOIDCConnectorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connector to be updated.
  var connector: Types_OIDCConnectorV3 {
    get {return _connector ?? Types_OIDCConnectorV3()}
    set {_connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  var hasConnector: Bool {return self._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  mutating func clearConnector() {self._connector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connector: Types_OIDCConnectorV3? = nil
}

/// UpsertOIDCConnectorRequest is a request for UpsertOIDCConnector.
struct Proto_UpsertOIDCConnectorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connector to be created or updated.
  var connector: Types_OIDCConnectorV3 {
    get {return _connector ?? Types_OIDCConnectorV3()}
    set {_connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  var hasConnector: Bool {return self._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  mutating func clearConnector() {self._connector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connector: Types_OIDCConnectorV3? = nil
}

/// CreateSAMLConnectorRequest is a request for CreateSAMLConnector.
struct Proto_CreateSAMLConnectorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connector to be created.
  var connector: Types_SAMLConnectorV2 {
    get {return _connector ?? Types_SAMLConnectorV2()}
    set {_connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  var hasConnector: Bool {return self._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  mutating func clearConnector() {self._connector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connector: Types_SAMLConnectorV2? = nil
}

/// UpdateSAMLConnectorRequest is a request for UpdateSAMLConnector.
struct Proto_UpdateSAMLConnectorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connector to be updated.
  var connector: Types_SAMLConnectorV2 {
    get {return _connector ?? Types_SAMLConnectorV2()}
    set {_connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  var hasConnector: Bool {return self._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  mutating func clearConnector() {self._connector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connector: Types_SAMLConnectorV2? = nil
}

/// UpsertSAMLConnectorRequest is a request for UpsertSAMLConnector.
struct Proto_UpsertSAMLConnectorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connector to be created or updated.
  var connector: Types_SAMLConnectorV2 {
    get {return _connector ?? Types_SAMLConnectorV2()}
    set {_connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  var hasConnector: Bool {return self._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  mutating func clearConnector() {self._connector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connector: Types_SAMLConnectorV2? = nil
}

/// CreateGithubConnectorRequest is a request for CreateGithubConnector.
struct Proto_CreateGithubConnectorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connector to be created.
  var connector: Types_GithubConnectorV3 {
    get {return _connector ?? Types_GithubConnectorV3()}
    set {_connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  var hasConnector: Bool {return self._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  mutating func clearConnector() {self._connector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connector: Types_GithubConnectorV3? = nil
}

/// UpdateGithubConnectorRequest is a request for UpdateGithubConnector.
struct Proto_UpdateGithubConnectorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connector to be updated.
  var connector: Types_GithubConnectorV3 {
    get {return _connector ?? Types_GithubConnectorV3()}
    set {_connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  var hasConnector: Bool {return self._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  mutating func clearConnector() {self._connector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connector: Types_GithubConnectorV3? = nil
}

/// UpsertGithubConnectorRequest is a request for UpsertGithubConnector.
struct Proto_UpsertGithubConnectorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connector to be created or updated.
  var connector: Types_GithubConnectorV3 {
    get {return _connector ?? Types_GithubConnectorV3()}
    set {_connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  var hasConnector: Bool {return self._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  mutating func clearConnector() {self._connector = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connector: Types_GithubConnectorV3? = nil
}

/// GetSSODiagnosticInfoRequest is a request for GetSSODiagnosticInfo.
struct Proto_GetSSODiagnosticInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AuthRequestKind is the SSO Auth Request kind (oidc, saml, or github).
  var authRequestKind: String = String()

  /// AuthRequestID is the SSO Auth Request id or state token.
  var authRequestID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpstreamInventoryOneOf is the upstream message for the inventory control stream,
/// sent from teleport instances to the auth server.
struct Proto_UpstreamInventoryOneOf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Proto_UpstreamInventoryOneOf.OneOf_Msg? = nil

  /// Hello is the first message sent up the control stream.
  var hello: Proto_UpstreamInventoryHello {
    get {
      if case .hello(let v)? = msg {return v}
      return Proto_UpstreamInventoryHello()
    }
    set {msg = .hello(newValue)}
  }

  /// Heartbeat advertises instance status/liveness.
  var heartbeat: Proto_InventoryHeartbeat {
    get {
      if case .heartbeat(let v)? = msg {return v}
      return Proto_InventoryHeartbeat()
    }
    set {msg = .heartbeat(newValue)}
  }

  /// UpstreamInventoryPong is a response to a ping (used for testing/debug).
  var pong: Proto_UpstreamInventoryPong {
    get {
      if case .pong(let v)? = msg {return v}
      return Proto_UpstreamInventoryPong()
    }
    set {msg = .pong(newValue)}
  }

  /// UpstreamInventoryAgentMetadata advertises instance metadata.
  var agentMetadata: Proto_UpstreamInventoryAgentMetadata {
    get {
      if case .agentMetadata(let v)? = msg {return v}
      return Proto_UpstreamInventoryAgentMetadata()
    }
    set {msg = .agentMetadata(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable {
    /// Hello is the first message sent up the control stream.
    case hello(Proto_UpstreamInventoryHello)
    /// Heartbeat advertises instance status/liveness.
    case heartbeat(Proto_InventoryHeartbeat)
    /// UpstreamInventoryPong is a response to a ping (used for testing/debug).
    case pong(Proto_UpstreamInventoryPong)
    /// UpstreamInventoryAgentMetadata advertises instance metadata.
    case agentMetadata(Proto_UpstreamInventoryAgentMetadata)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_UpstreamInventoryOneOf.OneOf_Msg, rhs: Proto_UpstreamInventoryOneOf.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hello, .hello): return {
        guard case .hello(let l) = lhs, case .hello(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.heartbeat, .heartbeat): return {
        guard case .heartbeat(let l) = lhs, case .heartbeat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pong, .pong): return {
        guard case .pong(let l) = lhs, case .pong(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.agentMetadata, .agentMetadata): return {
        guard case .agentMetadata(let l) = lhs, case .agentMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// DownstreamInventoryOneOf is the downstream message for the inventory control stream,
/// sent from auth servers to teleport instances.
struct Proto_DownstreamInventoryOneOf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Proto_DownstreamInventoryOneOf.OneOf_Msg? = nil

  /// Hello is the first message sent down the control stream.
  var hello: Proto_DownstreamInventoryHello {
    get {
      if case .hello(let v)? = msg {return v}
      return Proto_DownstreamInventoryHello()
    }
    set {msg = .hello(newValue)}
  }

  /// Ping triggers an upstream pong (used for testing/debug).
  var ping: Proto_DownstreamInventoryPing {
    get {
      if case .ping(let v)? = msg {return v}
      return Proto_DownstreamInventoryPing()
    }
    set {msg = .ping(newValue)}
  }

  /// UpdateLabels updates the instance's labels.
  var updateLabels: Proto_DownstreamInventoryUpdateLabels {
    get {
      if case .updateLabels(let v)? = msg {return v}
      return Proto_DownstreamInventoryUpdateLabels()
    }
    set {msg = .updateLabels(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable {
    /// Hello is the first message sent down the control stream.
    case hello(Proto_DownstreamInventoryHello)
    /// Ping triggers an upstream pong (used for testing/debug).
    case ping(Proto_DownstreamInventoryPing)
    /// UpdateLabels updates the instance's labels.
    case updateLabels(Proto_DownstreamInventoryUpdateLabels)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_DownstreamInventoryOneOf.OneOf_Msg, rhs: Proto_DownstreamInventoryOneOf.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hello, .hello): return {
        guard case .hello(let l) = lhs, case .hello(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateLabels, .updateLabels): return {
        guard case .updateLabels(let l) = lhs, case .updateLabels(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// DownstreamInventoryPing is sent down the inventory control stream for testing/debug
/// purposes.
struct Proto_DownstreamInventoryPing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpstreamInventoryPong is sent up the inventory control stream in response to a downstream
/// ping (used for testing/debug purposes).
struct Proto_UpstreamInventoryPong {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpstreamInventoryHello is the hello message sent up the inventory control stream.
struct Proto_UpstreamInventoryHello {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version advertises the teleport version of the instance.
  var version: String = String()

  /// ServerID advertises the server ID of the instance.
  var serverID: String = String()

  /// Services advertises the currently live services of the instance. note: this is
  /// distinct from the SystemRoles associated with a certificate in that a service may
  /// hold a system role that is not currently in use if it was granted that role by
  /// its auth token. i.e. Services is the subset of SystemRoles that are currently
  /// active.
  var services: [String] = []

  /// Hostname is the hostname associated with the instance. This value is not required or guaranteed
  /// to be unique and its validity is not enforceable (i.e. join tokens do not constrain what an
  /// instance can claim its hostname to be). This value exists only to assist users in correlating
  /// instance resources with hosts.
  var hostname: String = String()

  /// ExternalUpgrader identifies the external upgrader that the instance is configured to
  /// export schedules to (e.g. 'kube'). Empty if no upgrader is defined.
  var externalUpgrader: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpstreamInventoryAgentMetadata is the message sent up the inventory control stream containing
/// metadata about the instance.
struct Proto_UpstreamInventoryAgentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OS advertises the instance OS ("darwin" or "linux").
  var os: String = String()

  /// OSVersion advertises the instance OS version (e.g. "ubuntu 22.04").
  var osversion: String = String()

  /// HostArchitecture advertises the instance host architecture (e.g. "x86_64" or "arm64").
  var hostArchitecture: String = String()

  /// GlibcVersion advertises the instance glibc version of linux instances (e.g. "2.35").
  var glibcVersion: String = String()

  /// InstallMethods advertises the install methods used for the instance (e.g. "dockerfile").
  var installMethods: [String] = []

  /// ContainerRuntime advertises the container runtime for the instance, if any (e.g. "docker").
  var containerRuntime: String = String()

  /// ContainerOrchestrator advertises the container orchestrator for the instance, if any
  /// (e.g. "kubernetes-v1.24.8-eks-ffeb93d").
  var containerOrchestrator: String = String()

  /// CloudEnvironment advertises the cloud environment for the instance, if any (e.g. "aws").
  var cloudEnvironment: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DownstreamInventoryHello is the hello message sent down the inventory control stream.
struct Proto_DownstreamInventoryHello {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version advertises the version of the auth server.
  var version: String = String()

  /// ServerID advertises the server ID of the auth server.
  var serverID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InventoryUpdateLabelsRequest is used to request that a specified instance
/// update its labels.
struct Proto_InventoryUpdateLabelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ServerID advertises the server ID of the instance.
  var serverID: String = String()

  /// Kind is the type of service to update labels for.
  var kind: Proto_LabelUpdateKind = .sshserver

  /// Labels is the new set of labels for the instance.
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DownstreamInventoryUpdateLabels is the message sent down the inventory
/// control stream to update the instance's labels.
struct Proto_DownstreamInventoryUpdateLabels {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the type of service to update labels for.
  var kind: Proto_LabelUpdateKind = .sshserver

  /// Labels is the new set of labels for the instance.
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InventoryHeartbeat announces information about instance state.
struct Proto_InventoryHeartbeat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SSHServer is a complete ssh server spec to be heartbeated (note: the full spec is heartbeated
  /// in the interest of simple conversion from the old logic of heartbeating via UpsertNode, but
  /// we should be able to cut down on network usage fairly significantly by moving static values
  /// to the hello message and only heartbeating dynamic values here).
  var sshserver: Types_ServerV2 {
    get {return _sshserver ?? Types_ServerV2()}
    set {_sshserver = newValue}
  }
  /// Returns true if `sshserver` has been explicitly set.
  var hasSshserver: Bool {return self._sshserver != nil}
  /// Clears the value of `sshserver`. Subsequent reads from it will return its default value.
  mutating func clearSshserver() {self._sshserver = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sshserver: Types_ServerV2? = nil
}

/// InventoryStatusRequest requests inventory status info.
struct Proto_InventoryStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connected requests summary of the inventory control streams registered with
  /// the auth server that handles the request.
  var connected: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InventoryStatusSummary is the status summary returned by the GetInventoryStatus rpc.
struct Proto_InventoryStatusSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connected is a summary of the instances connected to the current auth server.  Only set if
  /// the Connected flag in the status request is true.
  var connected: [Proto_UpstreamInventoryHello] = []

  /// InstanceCount is the total number of instance resources aggregated.
  var instanceCount: UInt32 = 0

  /// VersionCounts aggregates unique version counts.
  var versionCounts: Dictionary<String,UInt32> = [:]

  /// UpgraderCounts aggregates the unique upgrader counts.
  var upgraderCounts: Dictionary<String,UInt32> = [:]

  /// ServiceCounts aggregates the number of services.
  var serviceCounts: Dictionary<String,UInt32> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InventoryConnectedServiceCountsRequest requests inventory connected service counts.
struct Proto_InventoryConnectedServiceCountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InventoryConnectedServiceCounts is the connected service counts seen in the inventory.
struct Proto_InventoryConnectedServiceCounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ServiceCounts is the count of each connected service seen in the inventory.
  var serviceCounts: Dictionary<String,UInt64> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InventoryPingRequest is used to request that the specified server be sent an inventory ping
/// if it has a control stream registered.
struct Proto_InventoryPingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ServerID is the ID of the instance to ping.
  var serverID: String = String()

  /// ControlLog forces the ping to use the standard "commit then act" model of control log synchronization
  /// for the ping. This significantly increases the amount of time it takes for the ping request to
  /// complete, but is useful for testing/debugging control log issues.
  var controlLog: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InventoryPingResponse returns the result of an inventory ping initiated via an
/// inventory ping request.
struct Proto_InventoryPingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var duration: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetClusterAlertsResponse contains the result of a cluster alerts query.
struct Proto_GetClusterAlertsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Alerts is the list of matching alerts.
  var alerts: [Types_ClusterAlert] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAlertAcksRequest returns the currently acknowledged alerts
struct Proto_GetAlertAcksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAlertAcksResponse contains the set of active cluster alert
/// acknowledgements for this cluster.
struct Proto_GetAlertAcksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var acks: [Types_AlertAcknowledgement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ClearAlertAcksRequest specifies alerts acknowledgements to clear.
struct Proto_ClearAlertAcksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AlertID deletes an acknowledgement by ID. Deletes all acknowledgements if
  /// the id is '*'.
  var alertID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpsertClusterAlertRequest is used to create a cluster alert.
struct Proto_UpsertClusterAlertRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Alert is the alert being created.
  var alert: Types_ClusterAlert {
    get {return _alert ?? Types_ClusterAlert()}
    set {_alert = newValue}
  }
  /// Returns true if `alert` has been explicitly set.
  var hasAlert: Bool {return self._alert != nil}
  /// Clears the value of `alert`. Subsequent reads from it will return its default value.
  mutating func clearAlert() {self._alert = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _alert: Types_ClusterAlert? = nil
}

/// GetConnectionDiagnosticRequest is a request to return a connection diagnostic.
struct Proto_GetConnectionDiagnosticRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the connection diagnostic.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AppendDiagnosticTraceRequest is a request to append a trace into a DiagnosticConnection.
struct Proto_AppendDiagnosticTraceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the connection diagnostic.
  var name: String = String()

  /// Trace is the ConnectionDiagnosticTrace to append into the DiagnosticConnection.
  var trace: Types_ConnectionDiagnosticTrace {
    get {return _trace ?? Types_ConnectionDiagnosticTrace()}
    set {_trace = newValue}
  }
  /// Returns true if `trace` has been explicitly set.
  var hasTrace: Bool {return self._trace != nil}
  /// Clears the value of `trace`. Subsequent reads from it will return its default value.
  mutating func clearTrace() {self._trace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _trace: Types_ConnectionDiagnosticTrace? = nil
}

/// SubmitUsageEventRequest is used to submit an external usage event.
struct Proto_SubmitUsageEventRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Teleport_Usageevents_V1_UsageEventOneOf {
    get {return _event ?? Teleport_Usageevents_V1_UsageEventOneOf()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  mutating func clearEvent() {self._event = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _event: Teleport_Usageevents_V1_UsageEventOneOf? = nil
}

/// GetLicenseEvent is used to submit an external usage event.
struct Proto_GetLicenseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetLicenseEvent is used to submit an external usage event.
struct Proto_ListReleasesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateTokenV2Request is used with CreateTokenV2 to create tokens in the
/// backend.
struct Proto_CreateTokenV2Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: Proto_CreateTokenV2Request.OneOf_Token? = nil

  var v2: Types_ProvisionTokenV2 {
    get {
      if case .v2(let v)? = token {return v}
      return Types_ProvisionTokenV2()
    }
    set {token = .v2(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Token: Equatable {
    case v2(Types_ProvisionTokenV2)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_CreateTokenV2Request.OneOf_Token, rhs: Proto_CreateTokenV2Request.OneOf_Token) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v2, .v2): return {
        guard case .v2(let l) = lhs, case .v2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

/// UpsertTokenV2Request is used with UpsertTokenV2 to upsert tokens in the
/// backend.
struct Proto_UpsertTokenV2Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: Proto_UpsertTokenV2Request.OneOf_Token? = nil

  var v2: Types_ProvisionTokenV2 {
    get {
      if case .v2(let v)? = token {return v}
      return Types_ProvisionTokenV2()
    }
    set {token = .v2(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Token: Equatable {
    case v2(Types_ProvisionTokenV2)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_UpsertTokenV2Request.OneOf_Token, rhs: Proto_UpsertTokenV2Request.OneOf_Token) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v2, .v2): return {
        guard case .v2(let l) = lhs, case .v2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

/// Request for GetHeadlessAuthentication.
struct Proto_GetHeadlessAuthenticationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the headless authentication id.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for UpdateHeadlessAuthenticationState.
struct Proto_UpdateHeadlessAuthenticationStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the headless authentication id.
  var id: String = String()

  /// State is the state that the request will be updated to.
  /// MFA verification is required if State=APPROVED.
  var state: Types_HeadlessAuthenticationState = .unspecified

  /// MFAResponse is an mfa challenge response used to verify the user.
  /// MFA Auth Challenges can be created for a user with the
  /// authservice.GenerateAuthenticateChallenge rpc.
  var mfaResponse: Proto_MFAAuthenticateResponse {
    get {return _mfaResponse ?? Proto_MFAAuthenticateResponse()}
    set {_mfaResponse = newValue}
  }
  /// Returns true if `mfaResponse` has been explicitly set.
  var hasMfaResponse: Bool {return self._mfaResponse != nil}
  /// Clears the value of `mfaResponse`. Subsequent reads from it will return its default value.
  mutating func clearMfaResponse() {self._mfaResponse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mfaResponse: Proto_MFAAuthenticateResponse? = nil
}

/// ExportUpgradeWindowsRequest encodes parameters for loading the
/// upgrader-facing representations of upcoming agent maintenance windows.
struct Proto_ExportUpgradeWindowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TeleportVersion is the version of the teleport client making the request.
  var teleportVersion: String = String()

  /// UpgraderKind represents the kind of upgrader the schedule is intended for.
  var upgraderKind: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ExportUpgradeWindowsResponse encodes an upgrader-facing representation
/// of upcoming agent maintenance windows. Teleport agents periodically export these
/// schedules to external upgraders as part of the externally-managed upgrade system.
struct Proto_ExportUpgradeWindowsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CanonicalSchedule is the teleport-facing schedule repr.
  var canonicalSchedule: Types_AgentUpgradeSchedule {
    get {return _canonicalSchedule ?? Types_AgentUpgradeSchedule()}
    set {_canonicalSchedule = newValue}
  }
  /// Returns true if `canonicalSchedule` has been explicitly set.
  var hasCanonicalSchedule: Bool {return self._canonicalSchedule != nil}
  /// Clears the value of `canonicalSchedule`. Subsequent reads from it will return its default value.
  mutating func clearCanonicalSchedule() {self._canonicalSchedule = nil}

  /// KubeControllerSchedule encodes upcoming upgrade upgrade windows in a format known
  /// to the kube upgrade controller. Teleport agents should treat this value as an
  /// opaque blob.
  var kubeControllerSchedule: String = String()

  /// SystemdUnitSchedule encodes the upcoming upgrade windows in a format known to
  /// the teleport-upgrade systemd unit. Teleport agents should treat this value as an
  /// opaque blob.
  var systemdUnitSchedule: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _canonicalSchedule: Types_AgentUpgradeSchedule? = nil
}

/// AccessRequestAllowedPromotionRequest is the request to AccessRequestAllowedPromotion RPC call.
struct Proto_AccessRequestAllowedPromotionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AccessRequest is the access request to get promotions for.
  var accessRequestID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestAllowedPromotionResponse is the response to AccessRequestAllowedPromotion RPC call.
struct Proto_AccessRequestAllowedPromotionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// allowedPromotions is the list of allowed promotions for the access request.
  var allowedPromotions: Types_AccessRequestAllowedPromotions {
    get {return _allowedPromotions ?? Types_AccessRequestAllowedPromotions()}
    set {_allowedPromotions = newValue}
  }
  /// Returns true if `allowedPromotions` has been explicitly set.
  var hasAllowedPromotions: Bool {return self._allowedPromotions != nil}
  /// Clears the value of `allowedPromotions`. Subsequent reads from it will return its default value.
  mutating func clearAllowedPromotions() {self._allowedPromotions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _allowedPromotions: Types_AccessRequestAllowedPromotions? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_DeviceType: @unchecked Sendable {}
extension Proto_DeviceUsage: @unchecked Sendable {}
extension Proto_MFARequired: @unchecked Sendable {}
extension Proto_Order: @unchecked Sendable {}
extension Proto_LabelUpdateKind: @unchecked Sendable {}
extension Proto_Watch: @unchecked Sendable {}
extension Proto_HostCertsRequest: @unchecked Sendable {}
extension Proto_OpenSSHCertRequest: @unchecked Sendable {}
extension Proto_OpenSSHCert: @unchecked Sendable {}
extension Proto_UserCertsRequest: @unchecked Sendable {}
extension Proto_UserCertsRequest.CertUsage: @unchecked Sendable {}
extension Proto_UserCertsRequest.Requester: @unchecked Sendable {}
extension Proto_UserCertsRequest.CertPurpose: @unchecked Sendable {}
extension Proto_RouteToDatabase: @unchecked Sendable {}
extension Proto_RouteToWindowsDesktop: @unchecked Sendable {}
extension Proto_RouteToApp: @unchecked Sendable {}
extension Proto_GetUserRequest: @unchecked Sendable {}
extension Proto_GetUsersRequest: @unchecked Sendable {}
extension Proto_ChangePasswordRequest: @unchecked Sendable {}
extension Proto_PluginDataSeq: @unchecked Sendable {}
extension Proto_RequestStateSetter: @unchecked Sendable {}
extension Proto_RequestID: @unchecked Sendable {}
extension Proto_GetResetPasswordTokenRequest: @unchecked Sendable {}
extension Proto_CreateResetPasswordTokenRequest: @unchecked Sendable {}
extension Proto_RenewableCertsRequest: @unchecked Sendable {}
extension Proto_CreateBotRequest: @unchecked Sendable {}
extension Proto_CreateBotResponse: @unchecked Sendable {}
extension Proto_DeleteBotRequest: @unchecked Sendable {}
extension Proto_GetBotUsersRequest: @unchecked Sendable {}
extension Proto_PingRequest: @unchecked Sendable {}
extension Proto_PingResponse: @unchecked Sendable {}
extension Proto_Features: @unchecked Sendable {}
extension Proto_DeviceTrustFeature: @unchecked Sendable {}
extension Proto_AccessRequestsFeature: @unchecked Sendable {}
extension Proto_DeleteUserRequest: @unchecked Sendable {}
extension Proto_Semaphores: @unchecked Sendable {}
extension Proto_AuditStreamRequest: @unchecked Sendable {}
extension Proto_AuditStreamRequest.OneOf_Request: @unchecked Sendable {}
extension Proto_AuditStreamStatus: @unchecked Sendable {}
extension Proto_CreateStream: @unchecked Sendable {}
extension Proto_ResumeStream: @unchecked Sendable {}
extension Proto_CompleteStream: @unchecked Sendable {}
extension Proto_FlushAndCloseStream: @unchecked Sendable {}
extension Proto_UpsertApplicationServerRequest: @unchecked Sendable {}
extension Proto_DeleteApplicationServerRequest: @unchecked Sendable {}
extension Proto_DeleteAllApplicationServersRequest: @unchecked Sendable {}
extension Proto_GenerateAppTokenRequest: @unchecked Sendable {}
extension Proto_GenerateAppTokenResponse: @unchecked Sendable {}
extension Proto_GetAppSessionRequest: @unchecked Sendable {}
extension Proto_GetAppSessionResponse: @unchecked Sendable {}
extension Proto_ListAppSessionsRequest: @unchecked Sendable {}
extension Proto_ListAppSessionsResponse: @unchecked Sendable {}
extension Proto_GetSnowflakeSessionsResponse: @unchecked Sendable {}
extension Proto_ListSAMLIdPSessionsRequest: @unchecked Sendable {}
extension Proto_ListSAMLIdPSessionsResponse: @unchecked Sendable {}
extension Proto_CreateAppSessionRequest: @unchecked Sendable {}
extension Proto_CreateAppSessionResponse: @unchecked Sendable {}
extension Proto_CreateSnowflakeSessionRequest: @unchecked Sendable {}
extension Proto_CreateSnowflakeSessionResponse: @unchecked Sendable {}
extension Proto_CreateSAMLIdPSessionRequest: @unchecked Sendable {}
extension Proto_CreateSAMLIdPSessionResponse: @unchecked Sendable {}
extension Proto_GetSnowflakeSessionRequest: @unchecked Sendable {}
extension Proto_GetSnowflakeSessionResponse: @unchecked Sendable {}
extension Proto_GetSAMLIdPSessionRequest: @unchecked Sendable {}
extension Proto_GetSAMLIdPSessionResponse: @unchecked Sendable {}
extension Proto_DeleteAppSessionRequest: @unchecked Sendable {}
extension Proto_DeleteSnowflakeSessionRequest: @unchecked Sendable {}
extension Proto_DeleteSAMLIdPSessionRequest: @unchecked Sendable {}
extension Proto_DeleteUserAppSessionsRequest: @unchecked Sendable {}
extension Proto_DeleteUserSAMLIdPSessionsRequest: @unchecked Sendable {}
extension Proto_GetWebSessionResponse: @unchecked Sendable {}
extension Proto_GetWebSessionsResponse: @unchecked Sendable {}
extension Proto_GetWebTokenResponse: @unchecked Sendable {}
extension Proto_GetWebTokensResponse: @unchecked Sendable {}
extension Proto_UpsertKubernetesServerRequest: @unchecked Sendable {}
extension Proto_DeleteKubernetesServerRequest: @unchecked Sendable {}
extension Proto_DeleteAllKubernetesServersRequest: @unchecked Sendable {}
extension Proto_UpsertDatabaseServerRequest: @unchecked Sendable {}
extension Proto_DeleteDatabaseServerRequest: @unchecked Sendable {}
extension Proto_DeleteAllDatabaseServersRequest: @unchecked Sendable {}
extension Proto_DatabaseServiceV1List: @unchecked Sendable {}
extension Proto_UpsertDatabaseServiceRequest: @unchecked Sendable {}
extension Proto_DeleteAllDatabaseServicesRequest: @unchecked Sendable {}
extension Proto_DatabaseCSRRequest: @unchecked Sendable {}
extension Proto_DatabaseCSRResponse: @unchecked Sendable {}
extension Proto_DatabaseCertRequest: @unchecked Sendable {}
extension Proto_DatabaseCertRequest.Requester: @unchecked Sendable {}
extension Proto_DatabaseCertRequest.ExtensionsEnum: @unchecked Sendable {}
extension Proto_DatabaseCertResponse: @unchecked Sendable {}
extension Proto_SnowflakeJWTRequest: @unchecked Sendable {}
extension Proto_SnowflakeJWTResponse: @unchecked Sendable {}
extension Proto_GetRoleRequest: @unchecked Sendable {}
extension Proto_GetRolesResponse: @unchecked Sendable {}
extension Proto_CreateRoleRequest: @unchecked Sendable {}
extension Proto_UpdateRoleRequest: @unchecked Sendable {}
extension Proto_UpsertRoleRequest: @unchecked Sendable {}
extension Proto_DeleteRoleRequest: @unchecked Sendable {}
extension Proto_MFAAuthenticateChallenge: @unchecked Sendable {}
extension Proto_MFAAuthenticateResponse: @unchecked Sendable {}
extension Proto_MFAAuthenticateResponse.OneOf_Response: @unchecked Sendable {}
extension Proto_TOTPChallenge: @unchecked Sendable {}
extension Proto_TOTPResponse: @unchecked Sendable {}
extension Proto_MFARegisterChallenge: @unchecked Sendable {}
extension Proto_MFARegisterChallenge.OneOf_Request: @unchecked Sendable {}
extension Proto_MFARegisterResponse: @unchecked Sendable {}
extension Proto_MFARegisterResponse.OneOf_Response: @unchecked Sendable {}
extension Proto_TOTPRegisterChallenge: @unchecked Sendable {}
extension Proto_TOTPRegisterResponse: @unchecked Sendable {}
extension Proto_AddMFADeviceRequest: @unchecked Sendable {}
extension Proto_AddMFADeviceRequest.OneOf_Request: @unchecked Sendable {}
extension Proto_AddMFADeviceResponse: @unchecked Sendable {}
extension Proto_AddMFADeviceResponse.OneOf_Response: @unchecked Sendable {}
extension Proto_AddMFADeviceRequestInit: @unchecked Sendable {}
extension Proto_AddMFADeviceResponseAck: @unchecked Sendable {}
extension Proto_DeleteMFADeviceRequest: @unchecked Sendable {}
extension Proto_DeleteMFADeviceRequest.OneOf_Request: @unchecked Sendable {}
extension Proto_DeleteMFADeviceResponse: @unchecked Sendable {}
extension Proto_DeleteMFADeviceResponse.OneOf_Response: @unchecked Sendable {}
extension Proto_DeleteMFADeviceRequestInit: @unchecked Sendable {}
extension Proto_DeleteMFADeviceResponseAck: @unchecked Sendable {}
extension Proto_DeleteMFADeviceSyncRequest: @unchecked Sendable {}
extension Proto_AddMFADeviceSyncRequest: @unchecked Sendable {}
extension Proto_AddMFADeviceSyncResponse: @unchecked Sendable {}
extension Proto_GetMFADevicesRequest: @unchecked Sendable {}
extension Proto_GetMFADevicesResponse: @unchecked Sendable {}
extension Proto_UserSingleUseCertsRequest: @unchecked Sendable {}
extension Proto_UserSingleUseCertsRequest.OneOf_Request: @unchecked Sendable {}
extension Proto_UserSingleUseCertsResponse: @unchecked Sendable {}
extension Proto_UserSingleUseCertsResponse.OneOf_Response: @unchecked Sendable {}
extension Proto_IsMFARequiredRequest: @unchecked Sendable {}
extension Proto_IsMFARequiredRequest.OneOf_Target: @unchecked Sendable {}
extension Proto_StreamSessionEventsRequest: @unchecked Sendable {}
extension Proto_NodeLogin: @unchecked Sendable {}
extension Proto_IsMFARequiredResponse: @unchecked Sendable {}
extension Proto_SingleUseUserCert: @unchecked Sendable {}
extension Proto_SingleUseUserCert.OneOf_Cert: @unchecked Sendable {}
extension Proto_GetEventsRequest: @unchecked Sendable {}
extension Proto_GetSessionEventsRequest: @unchecked Sendable {}
extension Proto_Events: @unchecked Sendable {}
extension Proto_GetLocksRequest: @unchecked Sendable {}
extension Proto_GetLocksResponse: @unchecked Sendable {}
extension Proto_GetLockRequest: @unchecked Sendable {}
extension Proto_DeleteLockRequest: @unchecked Sendable {}
extension Proto_ReplaceRemoteLocksRequest: @unchecked Sendable {}
extension Proto_GetWindowsDesktopServicesResponse: @unchecked Sendable {}
extension Proto_GetWindowsDesktopServiceRequest: @unchecked Sendable {}
extension Proto_GetWindowsDesktopServiceResponse: @unchecked Sendable {}
extension Proto_DeleteWindowsDesktopServiceRequest: @unchecked Sendable {}
extension Proto_GetWindowsDesktopsResponse: @unchecked Sendable {}
extension Proto_DeleteWindowsDesktopRequest: @unchecked Sendable {}
extension Proto_WindowsDesktopCertRequest: @unchecked Sendable {}
extension Proto_WindowsDesktopCertResponse: @unchecked Sendable {}
extension Proto_ListSAMLIdPServiceProvidersRequest: @unchecked Sendable {}
extension Proto_ListSAMLIdPServiceProvidersResponse: @unchecked Sendable {}
extension Proto_GetSAMLIdPServiceProviderRequest: @unchecked Sendable {}
extension Proto_DeleteSAMLIdPServiceProviderRequest: @unchecked Sendable {}
extension Proto_ListUserGroupsRequest: @unchecked Sendable {}
extension Proto_ListUserGroupsResponse: @unchecked Sendable {}
extension Proto_GetUserGroupRequest: @unchecked Sendable {}
extension Proto_DeleteUserGroupRequest: @unchecked Sendable {}
extension Proto_CertAuthorityRequest: @unchecked Sendable {}
extension Proto_CRL: @unchecked Sendable {}
extension Proto_ChangeUserAuthenticationRequest: @unchecked Sendable {}
extension Proto_ChangeUserAuthenticationResponse: @unchecked Sendable {}
extension Proto_StartAccountRecoveryRequest: @unchecked Sendable {}
extension Proto_VerifyAccountRecoveryRequest: @unchecked Sendable {}
extension Proto_VerifyAccountRecoveryRequest.OneOf_AuthnCred: @unchecked Sendable {}
extension Proto_CompleteAccountRecoveryRequest: @unchecked Sendable {}
extension Proto_CompleteAccountRecoveryRequest.OneOf_NewAuthnCred: @unchecked Sendable {}
extension Proto_RecoveryCodes: @unchecked Sendable {}
extension Proto_CreateAccountRecoveryCodesRequest: @unchecked Sendable {}
extension Proto_GetAccountRecoveryTokenRequest: @unchecked Sendable {}
extension Proto_GetAccountRecoveryCodesRequest: @unchecked Sendable {}
extension Proto_UserCredentials: @unchecked Sendable {}
extension Proto_ContextUser: @unchecked Sendable {}
extension Proto_Passwordless: @unchecked Sendable {}
extension Proto_CreateAuthenticateChallengeRequest: @unchecked Sendable {}
extension Proto_CreateAuthenticateChallengeRequest.OneOf_Request: @unchecked Sendable {}
extension Proto_CreatePrivilegeTokenRequest: @unchecked Sendable {}
extension Proto_CreateRegisterChallengeRequest: @unchecked Sendable {}
extension Proto_PaginatedResource: @unchecked Sendable {}
extension Proto_PaginatedResource.OneOf_Resource: @unchecked Sendable {}
extension Proto_ListUnifiedResourcesRequest: @unchecked Sendable {}
extension Proto_ListUnifiedResourcesResponse: @unchecked Sendable {}
extension Proto_ListResourcesRequest: @unchecked Sendable {}
extension Proto_GetSSHTargetsRequest: @unchecked Sendable {}
extension Proto_GetSSHTargetsResponse: @unchecked Sendable {}
extension Proto_ListResourcesResponse: @unchecked Sendable {}
extension Proto_CreateSessionTrackerRequest: @unchecked Sendable {}
extension Proto_GetSessionTrackerRequest: @unchecked Sendable {}
extension Proto_RemoveSessionTrackerRequest: @unchecked Sendable {}
extension Proto_SessionTrackerUpdateState: @unchecked Sendable {}
extension Proto_SessionTrackerAddParticipant: @unchecked Sendable {}
extension Proto_SessionTrackerRemoveParticipant: @unchecked Sendable {}
extension Proto_SessionTrackerUpdateExpiry: @unchecked Sendable {}
extension Proto_UpdateSessionTrackerRequest: @unchecked Sendable {}
extension Proto_UpdateSessionTrackerRequest.OneOf_Update: @unchecked Sendable {}
extension Proto_PresenceMFAChallengeRequest: @unchecked Sendable {}
extension Proto_PresenceMFAChallengeSend: @unchecked Sendable {}
extension Proto_PresenceMFAChallengeSend.OneOf_Request: @unchecked Sendable {}
extension Proto_GetDomainNameResponse: @unchecked Sendable {}
extension Proto_GetClusterCACertResponse: @unchecked Sendable {}
extension Proto_GetLicenseResponse: @unchecked Sendable {}
extension Proto_ListReleasesResponse: @unchecked Sendable {}
extension Proto_GetOIDCAuthRequestRequest: @unchecked Sendable {}
extension Proto_GetSAMLAuthRequestRequest: @unchecked Sendable {}
extension Proto_GetGithubAuthRequestRequest: @unchecked Sendable {}
extension Proto_CreateOIDCConnectorRequest: @unchecked Sendable {}
extension Proto_UpdateOIDCConnectorRequest: @unchecked Sendable {}
extension Proto_UpsertOIDCConnectorRequest: @unchecked Sendable {}
extension Proto_CreateSAMLConnectorRequest: @unchecked Sendable {}
extension Proto_UpdateSAMLConnectorRequest: @unchecked Sendable {}
extension Proto_UpsertSAMLConnectorRequest: @unchecked Sendable {}
extension Proto_CreateGithubConnectorRequest: @unchecked Sendable {}
extension Proto_UpdateGithubConnectorRequest: @unchecked Sendable {}
extension Proto_UpsertGithubConnectorRequest: @unchecked Sendable {}
extension Proto_GetSSODiagnosticInfoRequest: @unchecked Sendable {}
extension Proto_UpstreamInventoryOneOf: @unchecked Sendable {}
extension Proto_UpstreamInventoryOneOf.OneOf_Msg: @unchecked Sendable {}
extension Proto_DownstreamInventoryOneOf: @unchecked Sendable {}
extension Proto_DownstreamInventoryOneOf.OneOf_Msg: @unchecked Sendable {}
extension Proto_DownstreamInventoryPing: @unchecked Sendable {}
extension Proto_UpstreamInventoryPong: @unchecked Sendable {}
extension Proto_UpstreamInventoryHello: @unchecked Sendable {}
extension Proto_UpstreamInventoryAgentMetadata: @unchecked Sendable {}
extension Proto_DownstreamInventoryHello: @unchecked Sendable {}
extension Proto_InventoryUpdateLabelsRequest: @unchecked Sendable {}
extension Proto_DownstreamInventoryUpdateLabels: @unchecked Sendable {}
extension Proto_InventoryHeartbeat: @unchecked Sendable {}
extension Proto_InventoryStatusRequest: @unchecked Sendable {}
extension Proto_InventoryStatusSummary: @unchecked Sendable {}
extension Proto_InventoryConnectedServiceCountsRequest: @unchecked Sendable {}
extension Proto_InventoryConnectedServiceCounts: @unchecked Sendable {}
extension Proto_InventoryPingRequest: @unchecked Sendable {}
extension Proto_InventoryPingResponse: @unchecked Sendable {}
extension Proto_GetClusterAlertsResponse: @unchecked Sendable {}
extension Proto_GetAlertAcksRequest: @unchecked Sendable {}
extension Proto_GetAlertAcksResponse: @unchecked Sendable {}
extension Proto_ClearAlertAcksRequest: @unchecked Sendable {}
extension Proto_UpsertClusterAlertRequest: @unchecked Sendable {}
extension Proto_GetConnectionDiagnosticRequest: @unchecked Sendable {}
extension Proto_AppendDiagnosticTraceRequest: @unchecked Sendable {}
extension Proto_SubmitUsageEventRequest: @unchecked Sendable {}
extension Proto_GetLicenseRequest: @unchecked Sendable {}
extension Proto_ListReleasesRequest: @unchecked Sendable {}
extension Proto_CreateTokenV2Request: @unchecked Sendable {}
extension Proto_CreateTokenV2Request.OneOf_Token: @unchecked Sendable {}
extension Proto_UpsertTokenV2Request: @unchecked Sendable {}
extension Proto_UpsertTokenV2Request.OneOf_Token: @unchecked Sendable {}
extension Proto_GetHeadlessAuthenticationRequest: @unchecked Sendable {}
extension Proto_UpdateHeadlessAuthenticationStateRequest: @unchecked Sendable {}
extension Proto_ExportUpgradeWindowsRequest: @unchecked Sendable {}
extension Proto_ExportUpgradeWindowsResponse: @unchecked Sendable {}
extension Proto_AccessRequestAllowedPromotionRequest: @unchecked Sendable {}
extension Proto_AccessRequestAllowedPromotionResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_DeviceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_TYPE_UNSPECIFIED"),
    1: .same(proto: "DEVICE_TYPE_TOTP"),
    3: .same(proto: "DEVICE_TYPE_WEBAUTHN"),
  ]
}

extension Proto_DeviceUsage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_USAGE_UNSPECIFIED"),
    1: .same(proto: "DEVICE_USAGE_MFA"),
    2: .same(proto: "DEVICE_USAGE_PASSWORDLESS"),
  ]
}

extension Proto_MFARequired: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MFA_REQUIRED_UNSPECIFIED"),
    1: .same(proto: "MFA_REQUIRED_YES"),
    2: .same(proto: "MFA_REQUIRED_NO"),
  ]
}

extension Proto_Order: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DESCENDING"),
    1: .same(proto: "ASCENDING"),
  ]
}

extension Proto_LabelUpdateKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SSHServer"),
    1: .same(proto: "SSHServerCloudLabels"),
  ]
}

extension Proto_Watch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Watch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kinds"),
    2: .same(proto: "AllowPartialSuccess"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.kinds) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowPartialSuccess) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kinds, fieldNumber: 1)
    }
    if self.allowPartialSuccess != false {
      try visitor.visitSingularBoolField(value: self.allowPartialSuccess, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Watch, rhs: Proto_Watch) -> Bool {
    if lhs.kinds != rhs.kinds {return false}
    if lhs.allowPartialSuccess != rhs.allowPartialSuccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_HostCertsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HostCertsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HostID"),
    2: .same(proto: "NodeName"),
    3: .same(proto: "Role"),
    4: .same(proto: "AdditionalPrincipals"),
    5: .same(proto: "DNSNames"),
    6: .same(proto: "PublicTLSKey"),
    7: .same(proto: "PublicSSHKey"),
    8: .same(proto: "RemoteAddr"),
    9: .same(proto: "Rotation"),
    10: .same(proto: "NoCache"),
    11: .same(proto: "SystemRoles"),
  ]

  fileprivate class _StorageClass {
    var _hostID: String = String()
    var _nodeName: String = String()
    var _role: String = String()
    var _additionalPrincipals: [String] = []
    var _dnsnames: [String] = []
    var _publicTlskey: Data = Data()
    var _publicSshkey: Data = Data()
    var _remoteAddr: String = String()
    var _rotation: Types_Rotation? = nil
    var _noCache: Bool = false
    var _systemRoles: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hostID = source._hostID
      _nodeName = source._nodeName
      _role = source._role
      _additionalPrincipals = source._additionalPrincipals
      _dnsnames = source._dnsnames
      _publicTlskey = source._publicTlskey
      _publicSshkey = source._publicSshkey
      _remoteAddr = source._remoteAddr
      _rotation = source._rotation
      _noCache = source._noCache
      _systemRoles = source._systemRoles
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._hostID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._nodeName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._role) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._additionalPrincipals) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._dnsnames) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._publicTlskey) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._publicSshkey) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._remoteAddr) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._rotation) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._noCache) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._systemRoles) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._hostID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostID, fieldNumber: 1)
      }
      if !_storage._nodeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nodeName, fieldNumber: 2)
      }
      if !_storage._role.isEmpty {
        try visitor.visitSingularStringField(value: _storage._role, fieldNumber: 3)
      }
      if !_storage._additionalPrincipals.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._additionalPrincipals, fieldNumber: 4)
      }
      if !_storage._dnsnames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._dnsnames, fieldNumber: 5)
      }
      if !_storage._publicTlskey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicTlskey, fieldNumber: 6)
      }
      if !_storage._publicSshkey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicSshkey, fieldNumber: 7)
      }
      if !_storage._remoteAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._remoteAddr, fieldNumber: 8)
      }
      try { if let v = _storage._rotation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._noCache != false {
        try visitor.visitSingularBoolField(value: _storage._noCache, fieldNumber: 10)
      }
      if !_storage._systemRoles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._systemRoles, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_HostCertsRequest, rhs: Proto_HostCertsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hostID != rhs_storage._hostID {return false}
        if _storage._nodeName != rhs_storage._nodeName {return false}
        if _storage._role != rhs_storage._role {return false}
        if _storage._additionalPrincipals != rhs_storage._additionalPrincipals {return false}
        if _storage._dnsnames != rhs_storage._dnsnames {return false}
        if _storage._publicTlskey != rhs_storage._publicTlskey {return false}
        if _storage._publicSshkey != rhs_storage._publicSshkey {return false}
        if _storage._remoteAddr != rhs_storage._remoteAddr {return false}
        if _storage._rotation != rhs_storage._rotation {return false}
        if _storage._noCache != rhs_storage._noCache {return false}
        if _storage._systemRoles != rhs_storage._systemRoles {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_OpenSSHCertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenSSHCertRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "PublicKey"),
    3: .same(proto: "TTL"),
    4: .same(proto: "Cluster"),
    5: .same(proto: "User"),
    6: .same(proto: "Roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cluster) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 3)
    }
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 4)
    }
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_OpenSSHCertRequest, rhs: Proto_OpenSSHCertRequest) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.cluster != rhs.cluster {return false}
    if lhs._user != rhs._user {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_OpenSSHCert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenSSHCert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Cert"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cert) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cert.isEmpty {
      try visitor.visitSingularBytesField(value: self.cert, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_OpenSSHCert, rhs: Proto_OpenSSHCert) -> Bool {
    if lhs.cert != rhs.cert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UserCertsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserCertsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PublicKey"),
    2: .same(proto: "Username"),
    3: .same(proto: "Expires"),
    4: .same(proto: "Format"),
    5: .same(proto: "RouteToCluster"),
    6: .same(proto: "AccessRequests"),
    7: .same(proto: "KubernetesCluster"),
    8: .same(proto: "RouteToDatabase"),
    9: .same(proto: "NodeName"),
    10: .same(proto: "Usage"),
    11: .same(proto: "RouteToApp"),
    12: .same(proto: "RoleRequests"),
    13: .same(proto: "RouteToWindowsDesktop"),
    14: .same(proto: "UseRoleRequests"),
    15: .same(proto: "DropAccessRequests"),
    16: .same(proto: "ConnectionDiagnosticID"),
    17: .same(proto: "RequesterName"),
    18: .same(proto: "MFAResponse"),
    19: .same(proto: "SSHLogin"),
    20: .standard(proto: "attestation_statement"),
    21: .same(proto: "Purpose"),
  ]

  fileprivate class _StorageClass {
    var _publicKey: Data = Data()
    var _username: String = String()
    var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _format: String = String()
    var _routeToCluster: String = String()
    var _accessRequests: [String] = []
    var _kubernetesCluster: String = String()
    var _routeToDatabase: Proto_RouteToDatabase? = nil
    var _nodeName: String = String()
    var _usage: Proto_UserCertsRequest.CertUsage = .all
    var _routeToApp: Proto_RouteToApp? = nil
    var _roleRequests: [String] = []
    var _routeToWindowsDesktop: Proto_RouteToWindowsDesktop? = nil
    var _useRoleRequests: Bool = false
    var _dropAccessRequests: [String] = []
    var _connectionDiagnosticID: String = String()
    var _requesterName: Proto_UserCertsRequest.Requester = .unspecified
    var _mfaresponse: Proto_MFAAuthenticateResponse? = nil
    var _sshlogin: String = String()
    var _attestationStatement: Teleport_Attestation_V1_AttestationStatement? = nil
    var _purpose: Proto_UserCertsRequest.CertPurpose = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _publicKey = source._publicKey
      _username = source._username
      _expires = source._expires
      _format = source._format
      _routeToCluster = source._routeToCluster
      _accessRequests = source._accessRequests
      _kubernetesCluster = source._kubernetesCluster
      _routeToDatabase = source._routeToDatabase
      _nodeName = source._nodeName
      _usage = source._usage
      _routeToApp = source._routeToApp
      _roleRequests = source._roleRequests
      _routeToWindowsDesktop = source._routeToWindowsDesktop
      _useRoleRequests = source._useRoleRequests
      _dropAccessRequests = source._dropAccessRequests
      _connectionDiagnosticID = source._connectionDiagnosticID
      _requesterName = source._requesterName
      _mfaresponse = source._mfaresponse
      _sshlogin = source._sshlogin
      _attestationStatement = source._attestationStatement
      _purpose = source._purpose
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._publicKey) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._username) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._expires) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._format) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._routeToCluster) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._accessRequests) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._kubernetesCluster) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._routeToDatabase) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._nodeName) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._usage) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._routeToApp) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._roleRequests) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._routeToWindowsDesktop) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._useRoleRequests) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._dropAccessRequests) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._connectionDiagnosticID) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._requesterName) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._mfaresponse) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._sshlogin) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._attestationStatement) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._purpose) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicKey, fieldNumber: 1)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 2)
      }
      try { if let v = _storage._expires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._format.isEmpty {
        try visitor.visitSingularStringField(value: _storage._format, fieldNumber: 4)
      }
      if !_storage._routeToCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._routeToCluster, fieldNumber: 5)
      }
      if !_storage._accessRequests.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._accessRequests, fieldNumber: 6)
      }
      if !_storage._kubernetesCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kubernetesCluster, fieldNumber: 7)
      }
      try { if let v = _storage._routeToDatabase {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._nodeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nodeName, fieldNumber: 9)
      }
      if _storage._usage != .all {
        try visitor.visitSingularEnumField(value: _storage._usage, fieldNumber: 10)
      }
      try { if let v = _storage._routeToApp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._roleRequests.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roleRequests, fieldNumber: 12)
      }
      try { if let v = _storage._routeToWindowsDesktop {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._useRoleRequests != false {
        try visitor.visitSingularBoolField(value: _storage._useRoleRequests, fieldNumber: 14)
      }
      if !_storage._dropAccessRequests.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._dropAccessRequests, fieldNumber: 15)
      }
      if !_storage._connectionDiagnosticID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectionDiagnosticID, fieldNumber: 16)
      }
      if _storage._requesterName != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._requesterName, fieldNumber: 17)
      }
      try { if let v = _storage._mfaresponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._sshlogin.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sshlogin, fieldNumber: 19)
      }
      try { if let v = _storage._attestationStatement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if _storage._purpose != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._purpose, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UserCertsRequest, rhs: Proto_UserCertsRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._expires != rhs_storage._expires {return false}
        if _storage._format != rhs_storage._format {return false}
        if _storage._routeToCluster != rhs_storage._routeToCluster {return false}
        if _storage._accessRequests != rhs_storage._accessRequests {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        if _storage._routeToDatabase != rhs_storage._routeToDatabase {return false}
        if _storage._nodeName != rhs_storage._nodeName {return false}
        if _storage._usage != rhs_storage._usage {return false}
        if _storage._routeToApp != rhs_storage._routeToApp {return false}
        if _storage._roleRequests != rhs_storage._roleRequests {return false}
        if _storage._routeToWindowsDesktop != rhs_storage._routeToWindowsDesktop {return false}
        if _storage._useRoleRequests != rhs_storage._useRoleRequests {return false}
        if _storage._dropAccessRequests != rhs_storage._dropAccessRequests {return false}
        if _storage._connectionDiagnosticID != rhs_storage._connectionDiagnosticID {return false}
        if _storage._requesterName != rhs_storage._requesterName {return false}
        if _storage._mfaresponse != rhs_storage._mfaresponse {return false}
        if _storage._sshlogin != rhs_storage._sshlogin {return false}
        if _storage._attestationStatement != rhs_storage._attestationStatement {return false}
        if _storage._purpose != rhs_storage._purpose {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UserCertsRequest.CertUsage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "All"),
    1: .same(proto: "SSH"),
    2: .same(proto: "Kubernetes"),
    3: .same(proto: "Database"),
    4: .same(proto: "App"),
    5: .same(proto: "WindowsDesktop"),
  ]
}

extension Proto_UserCertsRequest.Requester: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "TSH_DB_LOCAL_PROXY_TUNNEL"),
    2: .same(proto: "TSH_KUBE_LOCAL_PROXY"),
    3: .same(proto: "TSH_KUBE_LOCAL_PROXY_HEADLESS"),
  ]
}

extension Proto_UserCertsRequest.CertPurpose: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CERT_PURPOSE_UNSPECIFIED"),
    1: .same(proto: "CERT_PURPOSE_LOGIN_CERTS"),
    2: .same(proto: "CERT_PURPOSE_SINGLE_USE_CERTS"),
  ]
}

extension Proto_RouteToDatabase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteToDatabase"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServiceName"),
    2: .same(proto: "Protocol"),
    3: .same(proto: "Username"),
    4: .same(proto: "Database"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.database) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 1)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_RouteToDatabase, rhs: Proto_RouteToDatabase) -> Bool {
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.username != rhs.username {return false}
    if lhs.database != rhs.database {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RouteToWindowsDesktop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteToWindowsDesktop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "WindowsDesktop"),
    2: .same(proto: "Login"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.windowsDesktop) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.login) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.windowsDesktop.isEmpty {
      try visitor.visitSingularStringField(value: self.windowsDesktop, fieldNumber: 1)
    }
    if !self.login.isEmpty {
      try visitor.visitSingularStringField(value: self.login, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_RouteToWindowsDesktop, rhs: Proto_RouteToWindowsDesktop) -> Bool {
    if lhs.windowsDesktop != rhs.windowsDesktop {return false}
    if lhs.login != rhs.login {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RouteToApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteToApp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "SessionID"),
    3: .same(proto: "PublicAddr"),
    4: .same(proto: "ClusterName"),
    5: .same(proto: "AWSRoleARN"),
    6: .same(proto: "AzureIdentity"),
    7: .same(proto: "GCPServiceAccount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicAddr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.awsroleArn) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.azureIdentity) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.gcpserviceAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if !self.publicAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.publicAddr, fieldNumber: 3)
    }
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 4)
    }
    if !self.awsroleArn.isEmpty {
      try visitor.visitSingularStringField(value: self.awsroleArn, fieldNumber: 5)
    }
    if !self.azureIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.azureIdentity, fieldNumber: 6)
    }
    if !self.gcpserviceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.gcpserviceAccount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_RouteToApp, rhs: Proto_RouteToApp) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.publicAddr != rhs.publicAddr {return false}
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.awsroleArn != rhs.awsroleArn {return false}
    if lhs.azureIdentity != rhs.azureIdentity {return false}
    if lhs.gcpserviceAccount != rhs.gcpserviceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "WithSecrets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.withSecrets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.withSecrets != false {
      try visitor.visitSingularBoolField(value: self.withSecrets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetUserRequest, rhs: Proto_GetUserRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.withSecrets != rhs.withSecrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUsersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "WithSecrets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.withSecrets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.withSecrets != false {
      try visitor.visitSingularBoolField(value: self.withSecrets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetUsersRequest, rhs: Proto_GetUsersRequest) -> Bool {
    if lhs.withSecrets != rhs.withSecrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChangePasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangePasswordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "OldPassword"),
    3: .same(proto: "NewPassword"),
    4: .same(proto: "SecondFactorToken"),
    5: .same(proto: "Webauthn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.oldPassword) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.newPassword) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.secondFactorToken) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._webauthn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.oldPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.oldPassword, fieldNumber: 2)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.newPassword, fieldNumber: 3)
    }
    if !self.secondFactorToken.isEmpty {
      try visitor.visitSingularStringField(value: self.secondFactorToken, fieldNumber: 4)
    }
    try { if let v = self._webauthn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChangePasswordRequest, rhs: Proto_ChangePasswordRequest) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.oldPassword != rhs.oldPassword {return false}
    if lhs.newPassword != rhs.newPassword {return false}
    if lhs.secondFactorToken != rhs.secondFactorToken {return false}
    if lhs._webauthn != rhs._webauthn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PluginDataSeq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginDataSeq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PluginData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pluginData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pluginData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pluginData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_PluginDataSeq, rhs: Proto_PluginDataSeq) -> Bool {
    if lhs.pluginData != rhs.pluginData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RequestStateSetter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestStateSetter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "State"),
    3: .same(proto: "Delegator"),
    4: .same(proto: "Reason"),
    5: .same(proto: "Annotations"),
    6: .same(proto: "Roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.delegator) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._annotations) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.state != .none {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    if !self.delegator.isEmpty {
      try visitor.visitSingularStringField(value: self.delegator, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try { if let v = self._annotations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_RequestStateSetter, rhs: Proto_RequestStateSetter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.state != rhs.state {return false}
    if lhs.delegator != rhs.delegator {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._annotations != rhs._annotations {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RequestID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_RequestID, rhs: Proto_RequestID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetResetPasswordTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetResetPasswordTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TokenID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetResetPasswordTokenRequest, rhs: Proto_GetResetPasswordTokenRequest) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateResetPasswordTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateResetPasswordTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Type"),
    3: .same(proto: "TTL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateResetPasswordTokenRequest, rhs: Proto_CreateResetPasswordTokenRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RenewableCertsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RenewableCertsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Token"),
    2: .same(proto: "PublicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_RenewableCertsRequest, rhs: Proto_RenewableCertsRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateBotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateBotRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "TTL"),
    3: .same(proto: "TokenID"),
    4: .same(proto: "Roles"),
    5: .same(proto: "Traits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._traits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 2)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 3)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 4)
    }
    try { if let v = self._traits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateBotRequest, rhs: Proto_CreateBotRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs._traits != rhs._traits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateBotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateBotResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserName"),
    2: .same(proto: "RoleName"),
    3: .same(proto: "TokenID"),
    4: .same(proto: "TokenTTL"),
    5: .same(proto: "JoinMethod"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.roleName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.tokenTtl) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.joinMethod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.roleName.isEmpty {
      try visitor.visitSingularStringField(value: self.roleName, fieldNumber: 2)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 3)
    }
    if self.tokenTtl != 0 {
      try visitor.visitSingularInt64Field(value: self.tokenTtl, fieldNumber: 4)
    }
    if !self.joinMethod.isEmpty {
      try visitor.visitSingularStringField(value: self.joinMethod, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateBotResponse, rhs: Proto_CreateBotResponse) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.roleName != rhs.roleName {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.tokenTtl != rhs.tokenTtl {return false}
    if lhs.joinMethod != rhs.joinMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteBotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteBotRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteBotRequest, rhs: Proto_DeleteBotRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetBotUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBotUsersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetBotUsersRequest, rhs: Proto_GetBotUsersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_PingRequest, rhs: Proto_PingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClusterName"),
    2: .same(proto: "ServerVersion"),
    3: .same(proto: "ServerFeatures"),
    4: .same(proto: "ProxyPublicAddr"),
    5: .same(proto: "IsBoring"),
    7: .same(proto: "RemoteAddr"),
    8: .same(proto: "LoadAllCAs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._serverFeatures) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.proxyPublicAddr) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isBoring) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.remoteAddr) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.loadAllCas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.serverVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 2)
    }
    try { if let v = self._serverFeatures {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.proxyPublicAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.proxyPublicAddr, fieldNumber: 4)
    }
    if self.isBoring != false {
      try visitor.visitSingularBoolField(value: self.isBoring, fieldNumber: 5)
    }
    if !self.remoteAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteAddr, fieldNumber: 7)
    }
    if self.loadAllCas != false {
      try visitor.visitSingularBoolField(value: self.loadAllCas, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_PingResponse, rhs: Proto_PingResponse) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.serverVersion != rhs.serverVersion {return false}
    if lhs._serverFeatures != rhs._serverFeatures {return false}
    if lhs.proxyPublicAddr != rhs.proxyPublicAddr {return false}
    if lhs.isBoring != rhs.isBoring {return false}
    if lhs.remoteAddr != rhs.remoteAddr {return false}
    if lhs.loadAllCas != rhs.loadAllCas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Features: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Features"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kubernetes"),
    2: .same(proto: "App"),
    3: .same(proto: "DB"),
    4: .same(proto: "OIDC"),
    5: .same(proto: "SAML"),
    6: .same(proto: "AccessControls"),
    7: .same(proto: "AdvancedAccessWorkflows"),
    8: .same(proto: "Cloud"),
    9: .same(proto: "HSM"),
    10: .same(proto: "Desktop"),
    14: .same(proto: "RecoveryCodes"),
    15: .same(proto: "Plugins"),
    16: .same(proto: "AutomaticUpgrades"),
    17: .same(proto: "IsUsageBased"),
    18: .same(proto: "Assist"),
    19: .same(proto: "DeviceTrust"),
    20: .same(proto: "FeatureHiding"),
    21: .same(proto: "AccessRequests"),
    22: .same(proto: "CustomTheme"),
    23: .same(proto: "IdentityGovernance"),
  ]

  fileprivate class _StorageClass {
    var _kubernetes: Bool = false
    var _app: Bool = false
    var _db: Bool = false
    var _oidc: Bool = false
    var _saml: Bool = false
    var _accessControls: Bool = false
    var _advancedAccessWorkflows: Bool = false
    var _cloud: Bool = false
    var _hsm: Bool = false
    var _desktop: Bool = false
    var _recoveryCodes: Bool = false
    var _plugins: Bool = false
    var _automaticUpgrades: Bool = false
    var _isUsageBased: Bool = false
    var _assist: Bool = false
    var _deviceTrust: Proto_DeviceTrustFeature? = nil
    var _featureHiding: Bool = false
    var _accessRequests: Proto_AccessRequestsFeature? = nil
    var _customTheme: String = String()
    var _identityGovernance: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kubernetes = source._kubernetes
      _app = source._app
      _db = source._db
      _oidc = source._oidc
      _saml = source._saml
      _accessControls = source._accessControls
      _advancedAccessWorkflows = source._advancedAccessWorkflows
      _cloud = source._cloud
      _hsm = source._hsm
      _desktop = source._desktop
      _recoveryCodes = source._recoveryCodes
      _plugins = source._plugins
      _automaticUpgrades = source._automaticUpgrades
      _isUsageBased = source._isUsageBased
      _assist = source._assist
      _deviceTrust = source._deviceTrust
      _featureHiding = source._featureHiding
      _accessRequests = source._accessRequests
      _customTheme = source._customTheme
      _identityGovernance = source._identityGovernance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._kubernetes) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._app) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._db) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._oidc) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._saml) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._accessControls) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._advancedAccessWorkflows) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._cloud) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._hsm) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._desktop) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._recoveryCodes) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._plugins) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._automaticUpgrades) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._isUsageBased) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._assist) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._deviceTrust) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._featureHiding) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._accessRequests) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._customTheme) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._identityGovernance) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._kubernetes != false {
        try visitor.visitSingularBoolField(value: _storage._kubernetes, fieldNumber: 1)
      }
      if _storage._app != false {
        try visitor.visitSingularBoolField(value: _storage._app, fieldNumber: 2)
      }
      if _storage._db != false {
        try visitor.visitSingularBoolField(value: _storage._db, fieldNumber: 3)
      }
      if _storage._oidc != false {
        try visitor.visitSingularBoolField(value: _storage._oidc, fieldNumber: 4)
      }
      if _storage._saml != false {
        try visitor.visitSingularBoolField(value: _storage._saml, fieldNumber: 5)
      }
      if _storage._accessControls != false {
        try visitor.visitSingularBoolField(value: _storage._accessControls, fieldNumber: 6)
      }
      if _storage._advancedAccessWorkflows != false {
        try visitor.visitSingularBoolField(value: _storage._advancedAccessWorkflows, fieldNumber: 7)
      }
      if _storage._cloud != false {
        try visitor.visitSingularBoolField(value: _storage._cloud, fieldNumber: 8)
      }
      if _storage._hsm != false {
        try visitor.visitSingularBoolField(value: _storage._hsm, fieldNumber: 9)
      }
      if _storage._desktop != false {
        try visitor.visitSingularBoolField(value: _storage._desktop, fieldNumber: 10)
      }
      if _storage._recoveryCodes != false {
        try visitor.visitSingularBoolField(value: _storage._recoveryCodes, fieldNumber: 14)
      }
      if _storage._plugins != false {
        try visitor.visitSingularBoolField(value: _storage._plugins, fieldNumber: 15)
      }
      if _storage._automaticUpgrades != false {
        try visitor.visitSingularBoolField(value: _storage._automaticUpgrades, fieldNumber: 16)
      }
      if _storage._isUsageBased != false {
        try visitor.visitSingularBoolField(value: _storage._isUsageBased, fieldNumber: 17)
      }
      if _storage._assist != false {
        try visitor.visitSingularBoolField(value: _storage._assist, fieldNumber: 18)
      }
      try { if let v = _storage._deviceTrust {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if _storage._featureHiding != false {
        try visitor.visitSingularBoolField(value: _storage._featureHiding, fieldNumber: 20)
      }
      try { if let v = _storage._accessRequests {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if !_storage._customTheme.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customTheme, fieldNumber: 22)
      }
      if _storage._identityGovernance != false {
        try visitor.visitSingularBoolField(value: _storage._identityGovernance, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Features, rhs: Proto_Features) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kubernetes != rhs_storage._kubernetes {return false}
        if _storage._app != rhs_storage._app {return false}
        if _storage._db != rhs_storage._db {return false}
        if _storage._oidc != rhs_storage._oidc {return false}
        if _storage._saml != rhs_storage._saml {return false}
        if _storage._accessControls != rhs_storage._accessControls {return false}
        if _storage._advancedAccessWorkflows != rhs_storage._advancedAccessWorkflows {return false}
        if _storage._cloud != rhs_storage._cloud {return false}
        if _storage._hsm != rhs_storage._hsm {return false}
        if _storage._desktop != rhs_storage._desktop {return false}
        if _storage._recoveryCodes != rhs_storage._recoveryCodes {return false}
        if _storage._plugins != rhs_storage._plugins {return false}
        if _storage._automaticUpgrades != rhs_storage._automaticUpgrades {return false}
        if _storage._isUsageBased != rhs_storage._isUsageBased {return false}
        if _storage._assist != rhs_storage._assist {return false}
        if _storage._deviceTrust != rhs_storage._deviceTrust {return false}
        if _storage._featureHiding != rhs_storage._featureHiding {return false}
        if _storage._accessRequests != rhs_storage._accessRequests {return false}
        if _storage._customTheme != rhs_storage._customTheme {return false}
        if _storage._identityGovernance != rhs_storage._identityGovernance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeviceTrustFeature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceTrustFeature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "devices_usage_limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.devicesUsageLimit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.devicesUsageLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.devicesUsageLimit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeviceTrustFeature, rhs: Proto_DeviceTrustFeature) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.devicesUsageLimit != rhs.devicesUsageLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccessRequestsFeature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestsFeature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "monthly_request_limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.monthlyRequestLimit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.monthlyRequestLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.monthlyRequestLimit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AccessRequestsFeature, rhs: Proto_AccessRequestsFeature) -> Bool {
    if lhs.monthlyRequestLimit != rhs.monthlyRequestLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteUserRequest, rhs: Proto_DeleteUserRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Semaphores: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Semaphores"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Semaphores"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.semaphores) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.semaphores.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.semaphores, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Semaphores, rhs: Proto_Semaphores) -> Bool {
    if lhs.semaphores != rhs.semaphores {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuditStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuditStreamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CreateStream"),
    2: .same(proto: "ResumeStream"),
    3: .same(proto: "CompleteStream"),
    4: .same(proto: "FlushAndCloseStream"),
    5: .same(proto: "Event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_CreateStream?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .createStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .createStream(v)
        }
      }()
      case 2: try {
        var v: Proto_ResumeStream?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .resumeStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .resumeStream(v)
        }
      }()
      case 3: try {
        var v: Proto_CompleteStream?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .completeStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .completeStream(v)
        }
      }()
      case 4: try {
        var v: Proto_FlushAndCloseStream?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .flushAndCloseStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .flushAndCloseStream(v)
        }
      }()
      case 5: try {
        var v: Events_OneOf?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .event(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .event(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .createStream?: try {
      guard case .createStream(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .resumeStream?: try {
      guard case .resumeStream(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .completeStream?: try {
      guard case .completeStream(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .flushAndCloseStream?: try {
      guard case .flushAndCloseStream(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .event?: try {
      guard case .event(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuditStreamRequest, rhs: Proto_AuditStreamRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AuditStreamStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuditStreamStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UploadID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uploadID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uploadID.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AuditStreamStatus, rhs: Proto_AuditStreamStatus) -> Bool {
    if lhs.uploadID != rhs.uploadID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateStream"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateStream, rhs: Proto_CreateStream) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ResumeStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResumeStream"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
    2: .same(proto: "UploadID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uploadID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.uploadID.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ResumeStream, rhs: Proto_ResumeStream) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.uploadID != rhs.uploadID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompleteStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompleteStream"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CompleteStream, rhs: Proto_CompleteStream) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_FlushAndCloseStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlushAndCloseStream"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_FlushAndCloseStream, rhs: Proto_FlushAndCloseStream) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpsertApplicationServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertApplicationServerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Server"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._server) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._server {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpsertApplicationServerRequest, rhs: Proto_UpsertApplicationServerRequest) -> Bool {
    if lhs._server != rhs._server {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteApplicationServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteApplicationServerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Namespace"),
    2: .same(proto: "HostID"),
    3: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hostID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.hostID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteApplicationServerRequest, rhs: Proto_DeleteApplicationServerRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.hostID != rhs.hostID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteAllApplicationServersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllApplicationServersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Namespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteAllApplicationServersRequest, rhs: Proto_DeleteAllApplicationServersRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GenerateAppTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenerateAppTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Username"),
    2: .same(proto: "Roles"),
    3: .same(proto: "URI"),
    4: .same(proto: "Expires"),
    5: .same(proto: "Traits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Wrappers_StringValues>.self, value: &self.traits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 2)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 3)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.traits.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Wrappers_StringValues>.self, value: self.traits, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GenerateAppTokenRequest, rhs: Proto_GenerateAppTokenRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.traits != rhs.traits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GenerateAppTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenerateAppTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GenerateAppTokenResponse, rhs: Proto_GenerateAppTokenResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetAppSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAppSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetAppSessionRequest, rhs: Proto_GetAppSessionRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetAppSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAppSessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetAppSessionResponse, rhs: Proto_GetAppSessionResponse) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListAppSessionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAppSessionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
    3: .same(proto: "user"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.user) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListAppSessionsRequest, rhs: Proto_ListAppSessionsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.user != rhs.user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListAppSessionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAppSessionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessions"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sessions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListAppSessionsResponse, rhs: Proto_ListAppSessionsResponse) -> Bool {
    if lhs.sessions != rhs.sessions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSnowflakeSessionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSnowflakeSessionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sessions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSnowflakeSessionsResponse, rhs: Proto_GetSnowflakeSessionsResponse) -> Bool {
    if lhs.sessions != rhs.sessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListSAMLIdPSessionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSAMLIdPSessionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
    3: .same(proto: "user"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.user) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListSAMLIdPSessionsRequest, rhs: Proto_ListSAMLIdPSessionsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.user != rhs.user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListSAMLIdPSessionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSAMLIdPSessionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessions"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sessions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListSAMLIdPSessionsResponse, rhs: Proto_ListSAMLIdPSessionsResponse) -> Bool {
    if lhs.sessions != rhs.sessions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateAppSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAppSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Username"),
    3: .same(proto: "PublicAddr"),
    4: .same(proto: "ClusterName"),
    5: .same(proto: "AWSRoleARN"),
    6: .same(proto: "AzureIdentity"),
    7: .same(proto: "GCPServiceAccount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicAddr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.awsroleArn) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.azureIdentity) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.gcpserviceAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.publicAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.publicAddr, fieldNumber: 3)
    }
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 4)
    }
    if !self.awsroleArn.isEmpty {
      try visitor.visitSingularStringField(value: self.awsroleArn, fieldNumber: 5)
    }
    if !self.azureIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.azureIdentity, fieldNumber: 6)
    }
    if !self.gcpserviceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.gcpserviceAccount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateAppSessionRequest, rhs: Proto_CreateAppSessionRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.publicAddr != rhs.publicAddr {return false}
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.awsroleArn != rhs.awsroleArn {return false}
    if lhs.azureIdentity != rhs.azureIdentity {return false}
    if lhs.gcpserviceAccount != rhs.gcpserviceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateAppSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAppSessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateAppSessionResponse, rhs: Proto_CreateAppSessionResponse) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateSnowflakeSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateSnowflakeSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Username"),
    2: .same(proto: "SessionToken"),
    3: .same(proto: "TokenTTL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionToken) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.tokenTtl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.sessionToken.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionToken, fieldNumber: 2)
    }
    if self.tokenTtl != 0 {
      try visitor.visitSingularInt64Field(value: self.tokenTtl, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateSnowflakeSessionRequest, rhs: Proto_CreateSnowflakeSessionRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.sessionToken != rhs.sessionToken {return false}
    if lhs.tokenTtl != rhs.tokenTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateSnowflakeSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateSnowflakeSessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateSnowflakeSessionResponse, rhs: Proto_CreateSnowflakeSessionResponse) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateSAMLIdPSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateSAMLIdPSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
    2: .same(proto: "Username"),
    3: .same(proto: "SAMLSession"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._samlsession) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try { if let v = self._samlsession {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateSAMLIdPSessionRequest, rhs: Proto_CreateSAMLIdPSessionRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.username != rhs.username {return false}
    if lhs._samlsession != rhs._samlsession {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateSAMLIdPSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateSAMLIdPSessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateSAMLIdPSessionResponse, rhs: Proto_CreateSAMLIdPSessionResponse) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSnowflakeSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSnowflakeSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSnowflakeSessionRequest, rhs: Proto_GetSnowflakeSessionRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSnowflakeSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSnowflakeSessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSnowflakeSessionResponse, rhs: Proto_GetSnowflakeSessionResponse) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSAMLIdPSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSAMLIdPSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSAMLIdPSessionRequest, rhs: Proto_GetSAMLIdPSessionRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSAMLIdPSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSAMLIdPSessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSAMLIdPSessionResponse, rhs: Proto_GetSAMLIdPSessionResponse) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteAppSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAppSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteAppSessionRequest, rhs: Proto_DeleteAppSessionRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteSnowflakeSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteSnowflakeSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteSnowflakeSessionRequest, rhs: Proto_DeleteSnowflakeSessionRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteSAMLIdPSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteSAMLIdPSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteSAMLIdPSessionRequest, rhs: Proto_DeleteSAMLIdPSessionRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteUserAppSessionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteUserAppSessionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Username"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteUserAppSessionsRequest, rhs: Proto_DeleteUserAppSessionsRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteUserSAMLIdPSessionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteUserSAMLIdPSessionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Username"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteUserSAMLIdPSessionsRequest, rhs: Proto_DeleteUserSAMLIdPSessionsRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetWebSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWebSessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetWebSessionResponse, rhs: Proto_GetWebSessionResponse) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetWebSessionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWebSessionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sessions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetWebSessionsResponse, rhs: Proto_GetWebSessionsResponse) -> Bool {
    if lhs.sessions != rhs.sessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetWebTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWebTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetWebTokenResponse, rhs: Proto_GetWebTokenResponse) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetWebTokensResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWebTokensResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetWebTokensResponse, rhs: Proto_GetWebTokensResponse) -> Bool {
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpsertKubernetesServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertKubernetesServerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Server"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._server) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._server {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpsertKubernetesServerRequest, rhs: Proto_UpsertKubernetesServerRequest) -> Bool {
    if lhs._server != rhs._server {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteKubernetesServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteKubernetesServerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HostID"),
    2: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteKubernetesServerRequest, rhs: Proto_DeleteKubernetesServerRequest) -> Bool {
    if lhs.hostID != rhs.hostID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteAllKubernetesServersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllKubernetesServersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteAllKubernetesServersRequest, rhs: Proto_DeleteAllKubernetesServersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpsertDatabaseServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertDatabaseServerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Server"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._server) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._server {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpsertDatabaseServerRequest, rhs: Proto_UpsertDatabaseServerRequest) -> Bool {
    if lhs._server != rhs._server {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteDatabaseServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteDatabaseServerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Namespace"),
    2: .same(proto: "HostID"),
    3: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hostID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.hostID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteDatabaseServerRequest, rhs: Proto_DeleteDatabaseServerRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.hostID != rhs.hostID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteAllDatabaseServersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllDatabaseServersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Namespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteAllDatabaseServersRequest, rhs: Proto_DeleteAllDatabaseServersRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DatabaseServiceV1List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseServiceV1List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DatabaseServiceV1List, rhs: Proto_DatabaseServiceV1List) -> Bool {
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpsertDatabaseServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertDatabaseServiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Service"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._service) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._service {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpsertDatabaseServiceRequest, rhs: Proto_UpsertDatabaseServiceRequest) -> Bool {
    if lhs._service != rhs._service {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteAllDatabaseServicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAllDatabaseServicesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteAllDatabaseServicesRequest, rhs: Proto_DeleteAllDatabaseServicesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DatabaseCSRRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseCSRRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CSR"),
    2: .same(proto: "ClusterName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.csr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.csr.isEmpty {
      try visitor.visitSingularBytesField(value: self.csr, fieldNumber: 1)
    }
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DatabaseCSRRequest, rhs: Proto_DatabaseCSRRequest) -> Bool {
    if lhs.csr != rhs.csr {return false}
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DatabaseCSRResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseCSRResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Cert"),
    2: .same(proto: "CACerts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cert) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.cacerts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cert.isEmpty {
      try visitor.visitSingularBytesField(value: self.cert, fieldNumber: 1)
    }
    if !self.cacerts.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.cacerts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DatabaseCSRResponse, rhs: Proto_DatabaseCSRResponse) -> Bool {
    if lhs.cert != rhs.cert {return false}
    if lhs.cacerts != rhs.cacerts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DatabaseCertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseCertRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CSR"),
    2: .same(proto: "ServerName"),
    3: .same(proto: "TTL"),
    4: .same(proto: "ServerNames"),
    5: .same(proto: "RequesterName"),
    6: .same(proto: "CertificateExtensions"),
    7: .same(proto: "CRLEndpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.csr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverName) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.serverNames) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.requesterName) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.certificateExtensions) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.crlendpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.csr.isEmpty {
      try visitor.visitSingularBytesField(value: self.csr, fieldNumber: 1)
    }
    if !self.serverName.isEmpty {
      try visitor.visitSingularStringField(value: self.serverName, fieldNumber: 2)
    }
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 3)
    }
    if !self.serverNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serverNames, fieldNumber: 4)
    }
    if self.requesterName != .unspecified {
      try visitor.visitSingularEnumField(value: self.requesterName, fieldNumber: 5)
    }
    if self.certificateExtensions != .normal {
      try visitor.visitSingularEnumField(value: self.certificateExtensions, fieldNumber: 6)
    }
    if !self.crlendpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.crlendpoint, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DatabaseCertRequest, rhs: Proto_DatabaseCertRequest) -> Bool {
    if lhs.csr != rhs.csr {return false}
    if lhs.serverName != rhs.serverName {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.serverNames != rhs.serverNames {return false}
    if lhs.requesterName != rhs.requesterName {return false}
    if lhs.certificateExtensions != rhs.certificateExtensions {return false}
    if lhs.crlendpoint != rhs.crlendpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DatabaseCertRequest.Requester: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "TCTL"),
  ]
}

extension Proto_DatabaseCertRequest.ExtensionsEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "WINDOWS_SMARTCARD"),
  ]
}

extension Proto_DatabaseCertResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseCertResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Cert"),
    2: .same(proto: "CACerts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cert) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.cacerts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cert.isEmpty {
      try visitor.visitSingularBytesField(value: self.cert, fieldNumber: 1)
    }
    if !self.cacerts.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.cacerts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DatabaseCertResponse, rhs: Proto_DatabaseCertResponse) -> Bool {
    if lhs.cert != rhs.cert {return false}
    if lhs.cacerts != rhs.cacerts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SnowflakeJWTRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SnowflakeJWTRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AccountName"),
    2: .same(proto: "UserName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountName.isEmpty {
      try visitor.visitSingularStringField(value: self.accountName, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SnowflakeJWTRequest, rhs: Proto_SnowflakeJWTRequest) -> Bool {
    if lhs.accountName != rhs.accountName {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SnowflakeJWTResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SnowflakeJWTResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SnowflakeJWTResponse, rhs: Proto_SnowflakeJWTResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRoleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetRoleRequest, rhs: Proto_GetRoleRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRolesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetRolesResponse, rhs: Proto_GetRolesResponse) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateRoleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateRoleRequest, rhs: Proto_CreateRoleRequest) -> Bool {
    if lhs._role != rhs._role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpdateRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateRoleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpdateRoleRequest, rhs: Proto_UpdateRoleRequest) -> Bool {
    if lhs._role != rhs._role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpsertRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertRoleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpsertRoleRequest, rhs: Proto_UpsertRoleRequest) -> Bool {
    if lhs._role != rhs._role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteRoleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteRoleRequest, rhs: Proto_DeleteRoleRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MFAAuthenticateChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MFAAuthenticateChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "TOTP"),
    3: .same(proto: "WebauthnChallenge"),
    4: .same(proto: "MFARequired"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._totp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._webauthnChallenge) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.mfarequired) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._totp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._webauthnChallenge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.mfarequired != .unspecified {
      try visitor.visitSingularEnumField(value: self.mfarequired, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_MFAAuthenticateChallenge, rhs: Proto_MFAAuthenticateChallenge) -> Bool {
    if lhs._totp != rhs._totp {return false}
    if lhs._webauthnChallenge != rhs._webauthnChallenge {return false}
    if lhs.mfarequired != rhs.mfarequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MFAAuthenticateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MFAAuthenticateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "TOTP"),
    3: .same(proto: "Webauthn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Proto_TOTPResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .totp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .totp(v)
        }
      }()
      case 3: try {
        var v: Webauthn_CredentialAssertionResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .webauthn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .webauthn(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .totp?: try {
      guard case .totp(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .webauthn?: try {
      guard case .webauthn(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_MFAAuthenticateResponse, rhs: Proto_MFAAuthenticateResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TOTPChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOTPChallenge"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TOTPChallenge, rhs: Proto_TOTPChallenge) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TOTPResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOTPResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TOTPResponse, rhs: Proto_TOTPResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MFARegisterChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MFARegisterChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "TOTP"),
    3: .same(proto: "Webauthn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Proto_TOTPRegisterChallenge?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .totp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .totp(v)
        }
      }()
      case 3: try {
        var v: Webauthn_CredentialCreation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .webauthn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .webauthn(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .totp?: try {
      guard case .totp(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .webauthn?: try {
      guard case .webauthn(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_MFARegisterChallenge, rhs: Proto_MFARegisterChallenge) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_MFARegisterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MFARegisterResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "TOTP"),
    3: .same(proto: "Webauthn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Proto_TOTPRegisterResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .totp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .totp(v)
        }
      }()
      case 3: try {
        var v: Webauthn_CredentialCreationResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .webauthn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .webauthn(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .totp?: try {
      guard case .totp(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .webauthn?: try {
      guard case .webauthn(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_MFARegisterResponse, rhs: Proto_MFARegisterResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TOTPRegisterChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOTPRegisterChallenge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Secret"),
    2: .same(proto: "Issuer"),
    3: .same(proto: "PeriodSeconds"),
    4: .same(proto: "Algorithm"),
    5: .same(proto: "Digits"),
    6: .same(proto: "Account"),
    7: .same(proto: "QRCode"),
    8: .same(proto: "ID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.secret) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.periodSeconds) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.algorithm) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.digits) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.qrcode) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.secret.isEmpty {
      try visitor.visitSingularStringField(value: self.secret, fieldNumber: 1)
    }
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 2)
    }
    if self.periodSeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.periodSeconds, fieldNumber: 3)
    }
    if !self.algorithm.isEmpty {
      try visitor.visitSingularStringField(value: self.algorithm, fieldNumber: 4)
    }
    if self.digits != 0 {
      try visitor.visitSingularUInt32Field(value: self.digits, fieldNumber: 5)
    }
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 6)
    }
    if !self.qrcode.isEmpty {
      try visitor.visitSingularBytesField(value: self.qrcode, fieldNumber: 7)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TOTPRegisterChallenge, rhs: Proto_TOTPRegisterChallenge) -> Bool {
    if lhs.secret != rhs.secret {return false}
    if lhs.issuer != rhs.issuer {return false}
    if lhs.periodSeconds != rhs.periodSeconds {return false}
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs.digits != rhs.digits {return false}
    if lhs.account != rhs.account {return false}
    if lhs.qrcode != rhs.qrcode {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_TOTPRegisterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOTPRegisterResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Code"),
    2: .same(proto: "ID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_TOTPRegisterResponse, rhs: Proto_TOTPRegisterResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AddMFADeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddMFADeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Init"),
    2: .same(proto: "ExistingMFAResponse"),
    3: .same(proto: "NewMFARegisterResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_AddMFADeviceRequestInit?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .init_p(v)
        }
      }()
      case 2: try {
        var v: Proto_MFAAuthenticateResponse?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .existingMfaresponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .existingMfaresponse(v)
        }
      }()
      case 3: try {
        var v: Proto_MFARegisterResponse?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .newMfaregisterResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .newMfaregisterResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .init_p?: try {
      guard case .init_p(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .existingMfaresponse?: try {
      guard case .existingMfaresponse(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .newMfaregisterResponse?: try {
      guard case .newMfaregisterResponse(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AddMFADeviceRequest, rhs: Proto_AddMFADeviceRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AddMFADeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddMFADeviceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExistingMFAChallenge"),
    2: .same(proto: "NewMFARegisterChallenge"),
    3: .same(proto: "Ack"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_MFAAuthenticateChallenge?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .existingMfachallenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .existingMfachallenge(v)
        }
      }()
      case 2: try {
        var v: Proto_MFARegisterChallenge?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .newMfaregisterChallenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .newMfaregisterChallenge(v)
        }
      }()
      case 3: try {
        var v: Proto_AddMFADeviceResponseAck?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .ack(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .existingMfachallenge?: try {
      guard case .existingMfachallenge(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .newMfaregisterChallenge?: try {
      guard case .newMfaregisterChallenge(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AddMFADeviceResponse, rhs: Proto_AddMFADeviceResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AddMFADeviceRequestInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddMFADeviceRequestInit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DeviceName"),
    3: .same(proto: "DeviceType"),
    4: .same(proto: "DeviceUsage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.deviceType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.deviceUsage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 1)
    }
    if self.deviceType != .unspecified {
      try visitor.visitSingularEnumField(value: self.deviceType, fieldNumber: 3)
    }
    if self.deviceUsage != .unspecified {
      try visitor.visitSingularEnumField(value: self.deviceUsage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AddMFADeviceRequestInit, rhs: Proto_AddMFADeviceRequestInit) -> Bool {
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.deviceUsage != rhs.deviceUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AddMFADeviceResponseAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddMFADeviceResponseAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AddMFADeviceResponseAck, rhs: Proto_AddMFADeviceResponseAck) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteMFADeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMFADeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Init"),
    2: .same(proto: "MFAResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_DeleteMFADeviceRequestInit?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .init_p(v)
        }
      }()
      case 2: try {
        var v: Proto_MFAAuthenticateResponse?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .mfaresponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .mfaresponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .init_p?: try {
      guard case .init_p(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .mfaresponse?: try {
      guard case .mfaresponse(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteMFADeviceRequest, rhs: Proto_DeleteMFADeviceRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteMFADeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMFADeviceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MFAChallenge"),
    2: .same(proto: "Ack"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_MFAAuthenticateChallenge?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .mfachallenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .mfachallenge(v)
        }
      }()
      case 2: try {
        var v: Proto_DeleteMFADeviceResponseAck?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .ack(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .mfachallenge?: try {
      guard case .mfachallenge(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteMFADeviceResponse, rhs: Proto_DeleteMFADeviceResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteMFADeviceRequestInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMFADeviceRequestInit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DeviceName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteMFADeviceRequestInit, rhs: Proto_DeleteMFADeviceRequestInit) -> Bool {
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteMFADeviceResponseAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMFADeviceResponseAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteMFADeviceResponseAck, rhs: Proto_DeleteMFADeviceResponseAck) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteMFADeviceSyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMFADeviceSyncRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TokenID"),
    2: .same(proto: "DeviceName"),
    3: .same(proto: "ExistingMFAResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._existingMfaresponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 2)
    }
    try { if let v = self._existingMfaresponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteMFADeviceSyncRequest, rhs: Proto_DeleteMFADeviceSyncRequest) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs._existingMfaresponse != rhs._existingMfaresponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AddMFADeviceSyncRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddMFADeviceSyncRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TokenID"),
    5: .same(proto: "ContextUser"),
    2: .same(proto: "NewDeviceName"),
    3: .same(proto: "NewMFAResponse"),
    4: .same(proto: "DeviceUsage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newDeviceName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newMfaresponse) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.deviceUsage) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._contextUser) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    if !self.newDeviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.newDeviceName, fieldNumber: 2)
    }
    try { if let v = self._newMfaresponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.deviceUsage != .unspecified {
      try visitor.visitSingularEnumField(value: self.deviceUsage, fieldNumber: 4)
    }
    try { if let v = self._contextUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AddMFADeviceSyncRequest, rhs: Proto_AddMFADeviceSyncRequest) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs._contextUser != rhs._contextUser {return false}
    if lhs.newDeviceName != rhs.newDeviceName {return false}
    if lhs._newMfaresponse != rhs._newMfaresponse {return false}
    if lhs.deviceUsage != rhs.deviceUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AddMFADeviceSyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddMFADeviceSyncResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AddMFADeviceSyncResponse, rhs: Proto_AddMFADeviceSyncResponse) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetMFADevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMFADevicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TokenID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetMFADevicesRequest, rhs: Proto_GetMFADevicesRequest) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetMFADevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMFADevicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetMFADevicesResponse, rhs: Proto_GetMFADevicesResponse) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UserSingleUseCertsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserSingleUseCertsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Init"),
    2: .same(proto: "MFAResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_UserCertsRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .init_p(v)
        }
      }()
      case 2: try {
        var v: Proto_MFAAuthenticateResponse?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .mfaresponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .mfaresponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .init_p?: try {
      guard case .init_p(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .mfaresponse?: try {
      guard case .mfaresponse(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UserSingleUseCertsRequest, rhs: Proto_UserSingleUseCertsRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UserSingleUseCertsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserSingleUseCertsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MFAChallenge"),
    2: .same(proto: "Cert"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_MFAAuthenticateChallenge?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .mfachallenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .mfachallenge(v)
        }
      }()
      case 2: try {
        var v: Proto_SingleUseUserCert?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .cert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .cert(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .mfachallenge?: try {
      guard case .mfachallenge(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .cert?: try {
      guard case .cert(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UserSingleUseCertsResponse, rhs: Proto_UserSingleUseCertsResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_IsMFARequiredRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsMFARequiredRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "KubernetesCluster"),
    2: .same(proto: "Database"),
    3: .same(proto: "Node"),
    4: .same(proto: "WindowsDesktop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .kubernetesCluster(v)
        }
      }()
      case 2: try {
        var v: Proto_RouteToDatabase?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .database(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .database(v)
        }
      }()
      case 3: try {
        var v: Proto_NodeLogin?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .node(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .node(v)
        }
      }()
      case 4: try {
        var v: Proto_RouteToWindowsDesktop?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .windowsDesktop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .windowsDesktop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.target {
    case .kubernetesCluster?: try {
      guard case .kubernetesCluster(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .database?: try {
      guard case .database(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .node?: try {
      guard case .node(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .windowsDesktop?: try {
      guard case .windowsDesktop(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_IsMFARequiredRequest, rhs: Proto_IsMFARequiredRequest) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_StreamSessionEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamSessionEventsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
    2: .same(proto: "StartIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if self.startIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.startIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_StreamSessionEventsRequest, rhs: Proto_StreamSessionEventsRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_NodeLogin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeLogin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Node"),
    2: .same(proto: "Login"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.node) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.login) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.node.isEmpty {
      try visitor.visitSingularStringField(value: self.node, fieldNumber: 1)
    }
    if !self.login.isEmpty {
      try visitor.visitSingularStringField(value: self.login, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_NodeLogin, rhs: Proto_NodeLogin) -> Bool {
    if lhs.node != rhs.node {return false}
    if lhs.login != rhs.login {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_IsMFARequiredResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IsMFARequiredResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Required"),
    2: .same(proto: "MFARequired"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mfarequired) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 1)
    }
    if self.mfarequired != .unspecified {
      try visitor.visitSingularEnumField(value: self.mfarequired, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_IsMFARequiredResponse, rhs: Proto_IsMFARequiredResponse) -> Bool {
    if lhs.required != rhs.required {return false}
    if lhs.mfarequired != rhs.mfarequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SingleUseUserCert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SingleUseUserCert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SSH"),
    2: .same(proto: "TLS"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.cert != nil {try decoder.handleConflictingOneOf()}
          self.cert = .ssh(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.cert != nil {try decoder.handleConflictingOneOf()}
          self.cert = .tls(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.cert {
    case .ssh?: try {
      guard case .ssh(let v)? = self.cert else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .tls?: try {
      guard case .tls(let v)? = self.cert else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SingleUseUserCert, rhs: Proto_SingleUseUserCert) -> Bool {
    if lhs.cert != rhs.cert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetEventsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Namespace"),
    2: .same(proto: "StartDate"),
    3: .same(proto: "EndDate"),
    4: .same(proto: "EventTypes"),
    5: .same(proto: "Limit"),
    6: .same(proto: "StartKey"),
    7: .same(proto: "Order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startDate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._endDate) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.eventTypes) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.startKey) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._startDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._endDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.eventTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.eventTypes, fieldNumber: 4)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 5)
    }
    if !self.startKey.isEmpty {
      try visitor.visitSingularStringField(value: self.startKey, fieldNumber: 6)
    }
    if self.order != .descending {
      try visitor.visitSingularEnumField(value: self.order, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetEventsRequest, rhs: Proto_GetEventsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._startDate != rhs._startDate {return false}
    if lhs._endDate != rhs._endDate {return false}
    if lhs.eventTypes != rhs.eventTypes {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.startKey != rhs.startKey {return false}
    if lhs.order != rhs.order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSessionEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSessionEventsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "StartDate"),
    2: .same(proto: "EndDate"),
    3: .same(proto: "Limit"),
    4: .same(proto: "StartKey"),
    5: .same(proto: "Order"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startDate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endDate) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.startKey) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.order) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 3)
    }
    if !self.startKey.isEmpty {
      try visitor.visitSingularStringField(value: self.startKey, fieldNumber: 4)
    }
    if self.order != .descending {
      try visitor.visitSingularEnumField(value: self.order, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSessionEventsRequest, rhs: Proto_GetSessionEventsRequest) -> Bool {
    if lhs._startDate != rhs._startDate {return false}
    if lhs._endDate != rhs._endDate {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.startKey != rhs.startKey {return false}
    if lhs.order != rhs.order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Events: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Events"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Items"),
    2: .same(proto: "LastKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lastKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    if !self.lastKey.isEmpty {
      try visitor.visitSingularStringField(value: self.lastKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Events, rhs: Proto_Events) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.lastKey != rhs.lastKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetLocksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLocksRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Targets"),
    2: .same(proto: "InForceOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.targets) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.inForceOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targets, fieldNumber: 1)
    }
    if self.inForceOnly != false {
      try visitor.visitSingularBoolField(value: self.inForceOnly, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetLocksRequest, rhs: Proto_GetLocksRequest) -> Bool {
    if lhs.targets != rhs.targets {return false}
    if lhs.inForceOnly != rhs.inForceOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetLocksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLocksResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Locks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.locks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetLocksResponse, rhs: Proto_GetLocksResponse) -> Bool {
    if lhs.locks != rhs.locks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetLockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLockRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetLockRequest, rhs: Proto_GetLockRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteLockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteLockRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteLockRequest, rhs: Proto_DeleteLockRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ReplaceRemoteLocksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplaceRemoteLocksRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClusterName"),
    2: .same(proto: "Locks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.locks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.locks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ReplaceRemoteLocksRequest, rhs: Proto_ReplaceRemoteLocksRequest) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.locks != rhs.locks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetWindowsDesktopServicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWindowsDesktopServicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetWindowsDesktopServicesResponse, rhs: Proto_GetWindowsDesktopServicesResponse) -> Bool {
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetWindowsDesktopServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWindowsDesktopServiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetWindowsDesktopServiceRequest, rhs: Proto_GetWindowsDesktopServiceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetWindowsDesktopServiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWindowsDesktopServiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._service) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._service {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetWindowsDesktopServiceResponse, rhs: Proto_GetWindowsDesktopServiceResponse) -> Bool {
    if lhs._service != rhs._service {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteWindowsDesktopServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteWindowsDesktopServiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteWindowsDesktopServiceRequest, rhs: Proto_DeleteWindowsDesktopServiceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetWindowsDesktopsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWindowsDesktopsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Desktops"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.desktops) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.desktops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.desktops, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetWindowsDesktopsResponse, rhs: Proto_GetWindowsDesktopsResponse) -> Bool {
    if lhs.desktops != rhs.desktops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteWindowsDesktopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteWindowsDesktopRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "HostID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hostID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.hostID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteWindowsDesktopRequest, rhs: Proto_DeleteWindowsDesktopRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.hostID != rhs.hostID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsDesktopCertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsDesktopCertRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CSR"),
    2: .same(proto: "CRLEndpoint"),
    3: .same(proto: "TTL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.csr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.crlendpoint) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.csr.isEmpty {
      try visitor.visitSingularBytesField(value: self.csr, fieldNumber: 1)
    }
    if !self.crlendpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.crlendpoint, fieldNumber: 2)
    }
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsDesktopCertRequest, rhs: Proto_WindowsDesktopCertRequest) -> Bool {
    if lhs.csr != rhs.csr {return false}
    if lhs.crlendpoint != rhs.crlendpoint {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_WindowsDesktopCertResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsDesktopCertResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Cert"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cert) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cert.isEmpty {
      try visitor.visitSingularBytesField(value: self.cert, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_WindowsDesktopCertResponse, rhs: Proto_WindowsDesktopCertResponse) -> Bool {
    if lhs.cert != rhs.cert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListSAMLIdPServiceProvidersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSAMLIdPServiceProvidersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Limit"),
    2: .same(proto: "NextKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 1)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nextKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListSAMLIdPServiceProvidersRequest, rhs: Proto_ListSAMLIdPServiceProvidersRequest) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListSAMLIdPServiceProvidersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSAMLIdPServiceProvidersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServiceProviders"),
    2: .same(proto: "NextKey"),
    3: .same(proto: "TotalCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.serviceProviders) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextKey) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceProviders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceProviders, fieldNumber: 1)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nextKey, fieldNumber: 2)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListSAMLIdPServiceProvidersResponse, rhs: Proto_ListSAMLIdPServiceProvidersResponse) -> Bool {
    if lhs.serviceProviders != rhs.serviceProviders {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSAMLIdPServiceProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSAMLIdPServiceProviderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSAMLIdPServiceProviderRequest, rhs: Proto_GetSAMLIdPServiceProviderRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteSAMLIdPServiceProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteSAMLIdPServiceProviderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteSAMLIdPServiceProviderRequest, rhs: Proto_DeleteSAMLIdPServiceProviderRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListUserGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUserGroupsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Limit"),
    2: .same(proto: "NextKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 1)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nextKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListUserGroupsRequest, rhs: Proto_ListUserGroupsRequest) -> Bool {
    if lhs.limit != rhs.limit {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListUserGroupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUserGroupsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserGroups"),
    2: .same(proto: "NextKey"),
    3: .same(proto: "TotalCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userGroups) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextKey) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userGroups, fieldNumber: 1)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nextKey, fieldNumber: 2)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListUserGroupsResponse, rhs: Proto_ListUserGroupsResponse) -> Bool {
    if lhs.userGroups != rhs.userGroups {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetUserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUserGroupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetUserGroupRequest, rhs: Proto_GetUserGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DeleteUserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteUserGroupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DeleteUserGroupRequest, rhs: Proto_DeleteUserGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CertAuthorityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertAuthorityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CertAuthorityRequest, rhs: Proto_CertAuthorityRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CRL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CRL"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CRL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.crl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.crl.isEmpty {
      try visitor.visitSingularBytesField(value: self.crl, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CRL, rhs: Proto_CRL) -> Bool {
    if lhs.crl != rhs.crl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChangeUserAuthenticationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeUserAuthenticationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TokenID"),
    2: .same(proto: "NewPassword"),
    3: .same(proto: "NewMFARegisterResponse"),
    4: .same(proto: "NewDeviceName"),
    5: .same(proto: "LoginIP"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.newPassword) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newMfaregisterResponse) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.newDeviceName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.loginIp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.newPassword, fieldNumber: 2)
    }
    try { if let v = self._newMfaregisterResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.newDeviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.newDeviceName, fieldNumber: 4)
    }
    if !self.loginIp.isEmpty {
      try visitor.visitSingularStringField(value: self.loginIp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChangeUserAuthenticationRequest, rhs: Proto_ChangeUserAuthenticationRequest) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.newPassword != rhs.newPassword {return false}
    if lhs._newMfaregisterResponse != rhs._newMfaregisterResponse {return false}
    if lhs.newDeviceName != rhs.newDeviceName {return false}
    if lhs.loginIp != rhs.loginIp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ChangeUserAuthenticationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeUserAuthenticationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "WebSession"),
    2: .same(proto: "Recovery"),
    3: .same(proto: "PrivateKeyPolicyEnabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._webSession) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recovery) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.privateKeyPolicyEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._webSession {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recovery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.privateKeyPolicyEnabled != false {
      try visitor.visitSingularBoolField(value: self.privateKeyPolicyEnabled, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ChangeUserAuthenticationResponse, rhs: Proto_ChangeUserAuthenticationResponse) -> Bool {
    if lhs._webSession != rhs._webSession {return false}
    if lhs._recovery != rhs._recovery {return false}
    if lhs.privateKeyPolicyEnabled != rhs.privateKeyPolicyEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_StartAccountRecoveryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartAccountRecoveryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Username"),
    2: .same(proto: "RecoveryCode"),
    3: .same(proto: "RecoverType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.recoveryCode) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.recoverType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.recoveryCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.recoveryCode, fieldNumber: 2)
    }
    if self.recoverType != .unspecified {
      try visitor.visitSingularEnumField(value: self.recoverType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_StartAccountRecoveryRequest, rhs: Proto_StartAccountRecoveryRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.recoveryCode != rhs.recoveryCode {return false}
    if lhs.recoverType != rhs.recoverType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_VerifyAccountRecoveryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyAccountRecoveryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RecoveryStartTokenID"),
    2: .same(proto: "Username"),
    3: .same(proto: "Password"),
    4: .same(proto: "MFAAuthenticateResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recoveryStartTokenID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.authnCred != nil {try decoder.handleConflictingOneOf()}
          self.authnCred = .password(v)
        }
      }()
      case 4: try {
        var v: Proto_MFAAuthenticateResponse?
        var hadOneofValue = false
        if let current = self.authnCred {
          hadOneofValue = true
          if case .mfaauthenticateResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.authnCred = .mfaauthenticateResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.recoveryStartTokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.recoveryStartTokenID, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    switch self.authnCred {
    case .password?: try {
      guard case .password(let v)? = self.authnCred else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .mfaauthenticateResponse?: try {
      guard case .mfaauthenticateResponse(let v)? = self.authnCred else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_VerifyAccountRecoveryRequest, rhs: Proto_VerifyAccountRecoveryRequest) -> Bool {
    if lhs.recoveryStartTokenID != rhs.recoveryStartTokenID {return false}
    if lhs.username != rhs.username {return false}
    if lhs.authnCred != rhs.authnCred {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CompleteAccountRecoveryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompleteAccountRecoveryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RecoveryApprovedTokenID"),
    2: .same(proto: "NewDeviceName"),
    3: .same(proto: "NewPassword"),
    4: .same(proto: "NewMFAResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recoveryApprovedTokenID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newDeviceName) }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.newAuthnCred != nil {try decoder.handleConflictingOneOf()}
          self.newAuthnCred = .newPassword(v)
        }
      }()
      case 4: try {
        var v: Proto_MFARegisterResponse?
        var hadOneofValue = false
        if let current = self.newAuthnCred {
          hadOneofValue = true
          if case .newMfaresponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.newAuthnCred = .newMfaresponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.recoveryApprovedTokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.recoveryApprovedTokenID, fieldNumber: 1)
    }
    if !self.newDeviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.newDeviceName, fieldNumber: 2)
    }
    switch self.newAuthnCred {
    case .newPassword?: try {
      guard case .newPassword(let v)? = self.newAuthnCred else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .newMfaresponse?: try {
      guard case .newMfaresponse(let v)? = self.newAuthnCred else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CompleteAccountRecoveryRequest, rhs: Proto_CompleteAccountRecoveryRequest) -> Bool {
    if lhs.recoveryApprovedTokenID != rhs.recoveryApprovedTokenID {return false}
    if lhs.newDeviceName != rhs.newDeviceName {return false}
    if lhs.newAuthnCred != rhs.newAuthnCred {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RecoveryCodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecoveryCodes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Codes"),
    2: .same(proto: "Created"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.codes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.codes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.codes, fieldNumber: 1)
    }
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_RecoveryCodes, rhs: Proto_RecoveryCodes) -> Bool {
    if lhs.codes != rhs.codes {return false}
    if lhs._created != rhs._created {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateAccountRecoveryCodesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAccountRecoveryCodesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TokenID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateAccountRecoveryCodesRequest, rhs: Proto_CreateAccountRecoveryCodesRequest) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetAccountRecoveryTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountRecoveryTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RecoveryTokenID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.recoveryTokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recoveryTokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.recoveryTokenID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetAccountRecoveryTokenRequest, rhs: Proto_GetAccountRecoveryTokenRequest) -> Bool {
    if lhs.recoveryTokenID != rhs.recoveryTokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetAccountRecoveryCodesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAccountRecoveryCodesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetAccountRecoveryCodesRequest, rhs: Proto_GetAccountRecoveryCodesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UserCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Username"),
    2: .same(proto: "Password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularBytesField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UserCredentials, rhs: Proto_UserCredentials) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ContextUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContextUser"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ContextUser, rhs: Proto_ContextUser) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_Passwordless: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Passwordless"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Passwordless, rhs: Proto_Passwordless) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateAuthenticateChallengeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAuthenticateChallengeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserCredentials"),
    2: .same(proto: "RecoveryStartTokenID"),
    3: .same(proto: "ContextUser"),
    4: .same(proto: "Passwordless"),
    5: .same(proto: "MFARequiredCheck"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_UserCredentials?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .userCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .userCredentials(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.request != nil {try decoder.handleConflictingOneOf()}
          self.request = .recoveryStartTokenID(v)
        }
      }()
      case 3: try {
        var v: Proto_ContextUser?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .contextUser(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .contextUser(v)
        }
      }()
      case 4: try {
        var v: Proto_Passwordless?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .passwordless(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .passwordless(v)
        }
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._mfarequiredCheck) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .userCredentials?: try {
      guard case .userCredentials(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .recoveryStartTokenID?: try {
      guard case .recoveryStartTokenID(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .contextUser?: try {
      guard case .contextUser(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .passwordless?: try {
      guard case .passwordless(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try { if let v = self._mfarequiredCheck {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateAuthenticateChallengeRequest, rhs: Proto_CreateAuthenticateChallengeRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs._mfarequiredCheck != rhs._mfarequiredCheck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreatePrivilegeTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreatePrivilegeTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExistingMFAResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._existingMfaresponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._existingMfaresponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreatePrivilegeTokenRequest, rhs: Proto_CreatePrivilegeTokenRequest) -> Bool {
    if lhs._existingMfaresponse != rhs._existingMfaresponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateRegisterChallengeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateRegisterChallengeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TokenID"),
    4: .same(proto: "ExistingMFAResponse"),
    2: .same(proto: "DeviceType"),
    3: .same(proto: "DeviceUsage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.deviceType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.deviceUsage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._existingMfaresponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    if self.deviceType != .unspecified {
      try visitor.visitSingularEnumField(value: self.deviceType, fieldNumber: 2)
    }
    if self.deviceUsage != .unspecified {
      try visitor.visitSingularEnumField(value: self.deviceUsage, fieldNumber: 3)
    }
    try { if let v = self._existingMfaresponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateRegisterChallengeRequest, rhs: Proto_CreateRegisterChallengeRequest) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs._existingMfaresponse != rhs._existingMfaresponse {return false}
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.deviceUsage != rhs.deviceUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PaginatedResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaginatedResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DatabaseServer"),
    2: .same(proto: "AppServer"),
    3: .same(proto: "Node"),
    5: .same(proto: "WindowsDesktop"),
    6: .same(proto: "KubeCluster"),
    7: .same(proto: "KubernetesServer"),
    8: .same(proto: "WindowsDesktopService"),
    9: .same(proto: "DatabaseService"),
    10: .same(proto: "UserGroup"),
    11: .same(proto: "AppServerOrSAMLIdPServiceProvider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Types_DatabaseServerV3?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .databaseServer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .databaseServer(v)
        }
      }()
      case 2: try {
        var v: Types_AppServerV3?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .appServer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .appServer(v)
        }
      }()
      case 3: try {
        var v: Types_ServerV2?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .node(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .node(v)
        }
      }()
      case 5: try {
        var v: Types_WindowsDesktopV3?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .windowsDesktop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .windowsDesktop(v)
        }
      }()
      case 6: try {
        var v: Types_KubernetesClusterV3?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .kubeCluster(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .kubeCluster(v)
        }
      }()
      case 7: try {
        var v: Types_KubernetesServerV3?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .kubernetesServer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .kubernetesServer(v)
        }
      }()
      case 8: try {
        var v: Types_WindowsDesktopServiceV3?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .windowsDesktopService(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .windowsDesktopService(v)
        }
      }()
      case 9: try {
        var v: Types_DatabaseServiceV1?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .databaseService(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .databaseService(v)
        }
      }()
      case 10: try {
        var v: Types_UserGroupV1?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .userGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .userGroup(v)
        }
      }()
      case 11: try {
        var v: Types_AppServerOrSAMLIdPServiceProviderV1?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .appServerOrSamlidPserviceProvider(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .appServerOrSamlidPserviceProvider(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.resource {
    case .databaseServer?: try {
      guard case .databaseServer(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .appServer?: try {
      guard case .appServer(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .node?: try {
      guard case .node(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .windowsDesktop?: try {
      guard case .windowsDesktop(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .kubeCluster?: try {
      guard case .kubeCluster(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .kubernetesServer?: try {
      guard case .kubernetesServer(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .windowsDesktopService?: try {
      guard case .windowsDesktopService(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .databaseService?: try {
      guard case .databaseService(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .userGroup?: try {
      guard case .userGroup(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .appServerOrSamlidPserviceProvider?: try {
      guard case .appServerOrSamlidPserviceProvider(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_PaginatedResource, rhs: Proto_PaginatedResource) -> Bool {
    if lhs.resource != rhs.resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListUnifiedResourcesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnifiedResourcesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kinds"),
    2: .same(proto: "Limit"),
    3: .same(proto: "StartKey"),
    4: .same(proto: "Labels"),
    5: .same(proto: "PredicateExpression"),
    6: .same(proto: "SearchKeywords"),
    7: .same(proto: "SortBy"),
    8: .same(proto: "WindowsDesktopFilter"),
    9: .same(proto: "UseSearchAsRoles"),
    10: .same(proto: "UsePreviewAsRoles"),
    11: .same(proto: "PinnedOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.kinds) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.startKey) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.predicateExpression) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.searchKeywords) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._sortBy) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._windowsDesktopFilter) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.useSearchAsRoles) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.usePreviewAsRoles) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.pinnedOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kinds, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    if !self.startKey.isEmpty {
      try visitor.visitSingularStringField(value: self.startKey, fieldNumber: 3)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 4)
    }
    if !self.predicateExpression.isEmpty {
      try visitor.visitSingularStringField(value: self.predicateExpression, fieldNumber: 5)
    }
    if !self.searchKeywords.isEmpty {
      try visitor.visitRepeatedStringField(value: self.searchKeywords, fieldNumber: 6)
    }
    try { if let v = self._sortBy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._windowsDesktopFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.useSearchAsRoles != false {
      try visitor.visitSingularBoolField(value: self.useSearchAsRoles, fieldNumber: 9)
    }
    if self.usePreviewAsRoles != false {
      try visitor.visitSingularBoolField(value: self.usePreviewAsRoles, fieldNumber: 10)
    }
    if self.pinnedOnly != false {
      try visitor.visitSingularBoolField(value: self.pinnedOnly, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListUnifiedResourcesRequest, rhs: Proto_ListUnifiedResourcesRequest) -> Bool {
    if lhs.kinds != rhs.kinds {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.startKey != rhs.startKey {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.predicateExpression != rhs.predicateExpression {return false}
    if lhs.searchKeywords != rhs.searchKeywords {return false}
    if lhs._sortBy != rhs._sortBy {return false}
    if lhs._windowsDesktopFilter != rhs._windowsDesktopFilter {return false}
    if lhs.useSearchAsRoles != rhs.useSearchAsRoles {return false}
    if lhs.usePreviewAsRoles != rhs.usePreviewAsRoles {return false}
    if lhs.pinnedOnly != rhs.pinnedOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListUnifiedResourcesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnifiedResourcesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Resources"),
    2: .same(proto: "NextKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 1)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nextKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListUnifiedResourcesResponse, rhs: Proto_ListUnifiedResourcesResponse) -> Bool {
    if lhs.resources != rhs.resources {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListResourcesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListResourcesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ResourceType"),
    2: .same(proto: "Namespace"),
    3: .same(proto: "Limit"),
    4: .same(proto: "StartKey"),
    5: .same(proto: "Labels"),
    6: .same(proto: "PredicateExpression"),
    7: .same(proto: "SearchKeywords"),
    8: .same(proto: "SortBy"),
    9: .same(proto: "NeedTotalCount"),
    10: .same(proto: "WindowsDesktopFilter"),
    11: .same(proto: "UseSearchAsRoles"),
    12: .same(proto: "UsePreviewAsRoles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.startKey) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.predicateExpression) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.searchKeywords) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._sortBy) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.needTotalCount) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._windowsDesktopFilter) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.useSearchAsRoles) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.usePreviewAsRoles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 3)
    }
    if !self.startKey.isEmpty {
      try visitor.visitSingularStringField(value: self.startKey, fieldNumber: 4)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 5)
    }
    if !self.predicateExpression.isEmpty {
      try visitor.visitSingularStringField(value: self.predicateExpression, fieldNumber: 6)
    }
    if !self.searchKeywords.isEmpty {
      try visitor.visitRepeatedStringField(value: self.searchKeywords, fieldNumber: 7)
    }
    try { if let v = self._sortBy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.needTotalCount != false {
      try visitor.visitSingularBoolField(value: self.needTotalCount, fieldNumber: 9)
    }
    try { if let v = self._windowsDesktopFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if self.useSearchAsRoles != false {
      try visitor.visitSingularBoolField(value: self.useSearchAsRoles, fieldNumber: 11)
    }
    if self.usePreviewAsRoles != false {
      try visitor.visitSingularBoolField(value: self.usePreviewAsRoles, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListResourcesRequest, rhs: Proto_ListResourcesRequest) -> Bool {
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.startKey != rhs.startKey {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.predicateExpression != rhs.predicateExpression {return false}
    if lhs.searchKeywords != rhs.searchKeywords {return false}
    if lhs._sortBy != rhs._sortBy {return false}
    if lhs.needTotalCount != rhs.needTotalCount {return false}
    if lhs._windowsDesktopFilter != rhs._windowsDesktopFilter {return false}
    if lhs.useSearchAsRoles != rhs.useSearchAsRoles {return false}
    if lhs.usePreviewAsRoles != rhs.usePreviewAsRoles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSSHTargetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSSHTargetsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Host"),
    2: .same(proto: "Port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if !self.port.isEmpty {
      try visitor.visitSingularStringField(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSSHTargetsRequest, rhs: Proto_GetSSHTargetsRequest) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSSHTargetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSSHTargetsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Servers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.servers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.servers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.servers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSSHTargetsResponse, rhs: Proto_GetSSHTargetsResponse) -> Bool {
    if lhs.servers != rhs.servers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListResourcesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListResourcesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Resources"),
    2: .same(proto: "NextKey"),
    3: .same(proto: "TotalCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextKey) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 1)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nextKey, fieldNumber: 2)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListResourcesResponse, rhs: Proto_ListResourcesResponse) -> Bool {
    if lhs.resources != rhs.resources {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateSessionTrackerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateSessionTrackerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    15: .same(proto: "SessionTracker"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 15: try { try decoder.decodeSingularMessageField(value: &self._sessionTracker) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionTracker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateSessionTrackerRequest, rhs: Proto_CreateSessionTrackerRequest) -> Bool {
    if lhs._sessionTracker != rhs._sessionTracker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSessionTrackerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSessionTrackerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSessionTrackerRequest, rhs: Proto_GetSessionTrackerRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_RemoveSessionTrackerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveSessionTrackerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_RemoveSessionTrackerRequest, rhs: Proto_RemoveSessionTrackerRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SessionTrackerUpdateState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionTrackerUpdateState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "State"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .pending {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SessionTrackerUpdateState, rhs: Proto_SessionTrackerUpdateState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SessionTrackerAddParticipant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionTrackerAddParticipant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "Participant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._participant) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._participant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SessionTrackerAddParticipant, rhs: Proto_SessionTrackerAddParticipant) -> Bool {
    if lhs._participant != rhs._participant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SessionTrackerRemoveParticipant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionTrackerRemoveParticipant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "ParticipantID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.participantID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.participantID.isEmpty {
      try visitor.visitSingularStringField(value: self.participantID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SessionTrackerRemoveParticipant, rhs: Proto_SessionTrackerRemoveParticipant) -> Bool {
    if lhs.participantID != rhs.participantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SessionTrackerUpdateExpiry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionTrackerUpdateExpiry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Expires"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SessionTrackerUpdateExpiry, rhs: Proto_SessionTrackerUpdateExpiry) -> Bool {
    if lhs._expires != rhs._expires {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpdateSessionTrackerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateSessionTrackerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
    2: .same(proto: "UpdateState"),
    3: .same(proto: "AddParticipant"),
    4: .same(proto: "RemoveParticipant"),
    5: .same(proto: "UpdateExpiry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try {
        var v: Proto_SessionTrackerUpdateState?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateState(v)
        }
      }()
      case 3: try {
        var v: Proto_SessionTrackerAddParticipant?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .addParticipant(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .addParticipant(v)
        }
      }()
      case 4: try {
        var v: Proto_SessionTrackerRemoveParticipant?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .removeParticipant(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .removeParticipant(v)
        }
      }()
      case 5: try {
        var v: Proto_SessionTrackerUpdateExpiry?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .updateExpiry(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .updateExpiry(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    switch self.update {
    case .updateState?: try {
      guard case .updateState(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .addParticipant?: try {
      guard case .addParticipant(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .removeParticipant?: try {
      guard case .removeParticipant(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .updateExpiry?: try {
      guard case .updateExpiry(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpdateSessionTrackerRequest, rhs: Proto_UpdateSessionTrackerRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.update != rhs.update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PresenceMFAChallengeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PresenceMFAChallengeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_PresenceMFAChallengeRequest, rhs: Proto_PresenceMFAChallengeRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_PresenceMFAChallengeSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PresenceMFAChallengeSend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ChallengeRequest"),
    2: .same(proto: "ChallengeResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_PresenceMFAChallengeRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .challengeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .challengeRequest(v)
        }
      }()
      case 2: try {
        var v: Proto_MFAAuthenticateResponse?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .challengeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .challengeResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .challengeRequest?: try {
      guard case .challengeRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .challengeResponse?: try {
      guard case .challengeResponse(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_PresenceMFAChallengeSend, rhs: Proto_PresenceMFAChallengeSend) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetDomainNameResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDomainNameResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DomainName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domainName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domainName.isEmpty {
      try visitor.visitSingularStringField(value: self.domainName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetDomainNameResponse, rhs: Proto_GetDomainNameResponse) -> Bool {
    if lhs.domainName != rhs.domainName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetClusterCACertResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetClusterCACertResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TLSCA"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tlsca) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tlsca.isEmpty {
      try visitor.visitSingularBytesField(value: self.tlsca, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetClusterCACertResponse, rhs: Proto_GetClusterCACertResponse) -> Bool {
    if lhs.tlsca != rhs.tlsca {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetLicenseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLicenseResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "License"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.license) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.license.isEmpty {
      try visitor.visitSingularBytesField(value: self.license, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetLicenseResponse, rhs: Proto_GetLicenseResponse) -> Bool {
    if lhs.license != rhs.license {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListReleasesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListReleasesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "releases"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.releases) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.releases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.releases, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListReleasesResponse, rhs: Proto_ListReleasesResponse) -> Bool {
    if lhs.releases != rhs.releases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetOIDCAuthRequestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetOIDCAuthRequestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "StateToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stateToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stateToken.isEmpty {
      try visitor.visitSingularStringField(value: self.stateToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetOIDCAuthRequestRequest, rhs: Proto_GetOIDCAuthRequestRequest) -> Bool {
    if lhs.stateToken != rhs.stateToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSAMLAuthRequestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSAMLAuthRequestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSAMLAuthRequestRequest, rhs: Proto_GetSAMLAuthRequestRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetGithubAuthRequestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetGithubAuthRequestRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "StateToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stateToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stateToken.isEmpty {
      try visitor.visitSingularStringField(value: self.stateToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetGithubAuthRequestRequest, rhs: Proto_GetGithubAuthRequestRequest) -> Bool {
    if lhs.stateToken != rhs.stateToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateOIDCConnectorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateOIDCConnectorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateOIDCConnectorRequest, rhs: Proto_CreateOIDCConnectorRequest) -> Bool {
    if lhs._connector != rhs._connector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpdateOIDCConnectorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateOIDCConnectorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpdateOIDCConnectorRequest, rhs: Proto_UpdateOIDCConnectorRequest) -> Bool {
    if lhs._connector != rhs._connector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpsertOIDCConnectorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertOIDCConnectorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpsertOIDCConnectorRequest, rhs: Proto_UpsertOIDCConnectorRequest) -> Bool {
    if lhs._connector != rhs._connector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateSAMLConnectorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateSAMLConnectorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateSAMLConnectorRequest, rhs: Proto_CreateSAMLConnectorRequest) -> Bool {
    if lhs._connector != rhs._connector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpdateSAMLConnectorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateSAMLConnectorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpdateSAMLConnectorRequest, rhs: Proto_UpdateSAMLConnectorRequest) -> Bool {
    if lhs._connector != rhs._connector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpsertSAMLConnectorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertSAMLConnectorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpsertSAMLConnectorRequest, rhs: Proto_UpsertSAMLConnectorRequest) -> Bool {
    if lhs._connector != rhs._connector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateGithubConnectorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateGithubConnectorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateGithubConnectorRequest, rhs: Proto_CreateGithubConnectorRequest) -> Bool {
    if lhs._connector != rhs._connector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpdateGithubConnectorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateGithubConnectorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpdateGithubConnectorRequest, rhs: Proto_UpdateGithubConnectorRequest) -> Bool {
    if lhs._connector != rhs._connector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpsertGithubConnectorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertGithubConnectorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connector"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connector) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpsertGithubConnectorRequest, rhs: Proto_UpsertGithubConnectorRequest) -> Bool {
    if lhs._connector != rhs._connector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetSSODiagnosticInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSSODiagnosticInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AuthRequestKind"),
    2: .same(proto: "AuthRequestID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authRequestKind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authRequestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authRequestKind.isEmpty {
      try visitor.visitSingularStringField(value: self.authRequestKind, fieldNumber: 1)
    }
    if !self.authRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.authRequestID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetSSODiagnosticInfoRequest, rhs: Proto_GetSSODiagnosticInfoRequest) -> Bool {
    if lhs.authRequestKind != rhs.authRequestKind {return false}
    if lhs.authRequestID != rhs.authRequestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpstreamInventoryOneOf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamInventoryOneOf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Hello"),
    2: .same(proto: "Heartbeat"),
    3: .same(proto: "Pong"),
    4: .same(proto: "AgentMetadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_UpstreamInventoryHello?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .hello(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .hello(v)
        }
      }()
      case 2: try {
        var v: Proto_InventoryHeartbeat?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .heartbeat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .heartbeat(v)
        }
      }()
      case 3: try {
        var v: Proto_UpstreamInventoryPong?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .pong(v)
        }
      }()
      case 4: try {
        var v: Proto_UpstreamInventoryAgentMetadata?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .agentMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .agentMetadata(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.msg {
    case .hello?: try {
      guard case .hello(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .heartbeat?: try {
      guard case .heartbeat(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .agentMetadata?: try {
      guard case .agentMetadata(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpstreamInventoryOneOf, rhs: Proto_UpstreamInventoryOneOf) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DownstreamInventoryOneOf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamInventoryOneOf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Hello"),
    2: .same(proto: "Ping"),
    3: .same(proto: "UpdateLabels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Proto_DownstreamInventoryHello?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .hello(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .hello(v)
        }
      }()
      case 2: try {
        var v: Proto_DownstreamInventoryPing?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .ping(v)
        }
      }()
      case 3: try {
        var v: Proto_DownstreamInventoryUpdateLabels?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .updateLabels(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .updateLabels(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.msg {
    case .hello?: try {
      guard case .hello(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .updateLabels?: try {
      guard case .updateLabels(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DownstreamInventoryOneOf, rhs: Proto_DownstreamInventoryOneOf) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DownstreamInventoryPing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamInventoryPing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DownstreamInventoryPing, rhs: Proto_DownstreamInventoryPing) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpstreamInventoryPong: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamInventoryPong"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpstreamInventoryPong, rhs: Proto_UpstreamInventoryPong) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpstreamInventoryHello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamInventoryHello"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Version"),
    2: .same(proto: "ServerID"),
    3: .same(proto: "Services"),
    4: .same(proto: "Hostname"),
    5: .same(proto: "ExternalUpgrader"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.services) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.externalUpgrader) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.serverID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverID, fieldNumber: 2)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedStringField(value: self.services, fieldNumber: 3)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 4)
    }
    if !self.externalUpgrader.isEmpty {
      try visitor.visitSingularStringField(value: self.externalUpgrader, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpstreamInventoryHello, rhs: Proto_UpstreamInventoryHello) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.serverID != rhs.serverID {return false}
    if lhs.services != rhs.services {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.externalUpgrader != rhs.externalUpgrader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpstreamInventoryAgentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpstreamInventoryAgentMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OS"),
    2: .same(proto: "OSVersion"),
    3: .same(proto: "HostArchitecture"),
    4: .same(proto: "GlibcVersion"),
    5: .same(proto: "InstallMethods"),
    6: .same(proto: "ContainerRuntime"),
    7: .same(proto: "ContainerOrchestrator"),
    8: .same(proto: "CloudEnvironment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.os) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osversion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostArchitecture) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.glibcVersion) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.installMethods) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.containerRuntime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.containerOrchestrator) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.cloudEnvironment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.os.isEmpty {
      try visitor.visitSingularStringField(value: self.os, fieldNumber: 1)
    }
    if !self.osversion.isEmpty {
      try visitor.visitSingularStringField(value: self.osversion, fieldNumber: 2)
    }
    if !self.hostArchitecture.isEmpty {
      try visitor.visitSingularStringField(value: self.hostArchitecture, fieldNumber: 3)
    }
    if !self.glibcVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.glibcVersion, fieldNumber: 4)
    }
    if !self.installMethods.isEmpty {
      try visitor.visitRepeatedStringField(value: self.installMethods, fieldNumber: 5)
    }
    if !self.containerRuntime.isEmpty {
      try visitor.visitSingularStringField(value: self.containerRuntime, fieldNumber: 6)
    }
    if !self.containerOrchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.containerOrchestrator, fieldNumber: 7)
    }
    if !self.cloudEnvironment.isEmpty {
      try visitor.visitSingularStringField(value: self.cloudEnvironment, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpstreamInventoryAgentMetadata, rhs: Proto_UpstreamInventoryAgentMetadata) -> Bool {
    if lhs.os != rhs.os {return false}
    if lhs.osversion != rhs.osversion {return false}
    if lhs.hostArchitecture != rhs.hostArchitecture {return false}
    if lhs.glibcVersion != rhs.glibcVersion {return false}
    if lhs.installMethods != rhs.installMethods {return false}
    if lhs.containerRuntime != rhs.containerRuntime {return false}
    if lhs.containerOrchestrator != rhs.containerOrchestrator {return false}
    if lhs.cloudEnvironment != rhs.cloudEnvironment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DownstreamInventoryHello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamInventoryHello"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Version"),
    2: .same(proto: "ServerID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.serverID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DownstreamInventoryHello, rhs: Proto_DownstreamInventoryHello) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.serverID != rhs.serverID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InventoryUpdateLabelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InventoryUpdateLabelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServerID"),
    2: .same(proto: "Kind"),
    3: .same(proto: "Labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverID, fieldNumber: 1)
    }
    if self.kind != .sshserver {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_InventoryUpdateLabelsRequest, rhs: Proto_InventoryUpdateLabelsRequest) -> Bool {
    if lhs.serverID != rhs.serverID {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_DownstreamInventoryUpdateLabels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownstreamInventoryUpdateLabels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "Labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .sshserver {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_DownstreamInventoryUpdateLabels, rhs: Proto_DownstreamInventoryUpdateLabels) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InventoryHeartbeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InventoryHeartbeat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SSHServer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sshserver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sshserver {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_InventoryHeartbeat, rhs: Proto_InventoryHeartbeat) -> Bool {
    if lhs._sshserver != rhs._sshserver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InventoryStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InventoryStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connected"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.connected) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.connected != false {
      try visitor.visitSingularBoolField(value: self.connected, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_InventoryStatusRequest, rhs: Proto_InventoryStatusRequest) -> Bool {
    if lhs.connected != rhs.connected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InventoryStatusSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InventoryStatusSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connected"),
    2: .same(proto: "InstanceCount"),
    3: .same(proto: "VersionCounts"),
    4: .same(proto: "UpgraderCounts"),
    5: .same(proto: "ServiceCounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.connected) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.instanceCount) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: &self.versionCounts) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: &self.upgraderCounts) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: &self.serviceCounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connected.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.connected, fieldNumber: 1)
    }
    if self.instanceCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.instanceCount, fieldNumber: 2)
    }
    if !self.versionCounts.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: self.versionCounts, fieldNumber: 3)
    }
    if !self.upgraderCounts.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: self.upgraderCounts, fieldNumber: 4)
    }
    if !self.serviceCounts.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt32>.self, value: self.serviceCounts, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_InventoryStatusSummary, rhs: Proto_InventoryStatusSummary) -> Bool {
    if lhs.connected != rhs.connected {return false}
    if lhs.instanceCount != rhs.instanceCount {return false}
    if lhs.versionCounts != rhs.versionCounts {return false}
    if lhs.upgraderCounts != rhs.upgraderCounts {return false}
    if lhs.serviceCounts != rhs.serviceCounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InventoryConnectedServiceCountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InventoryConnectedServiceCountsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_InventoryConnectedServiceCountsRequest, rhs: Proto_InventoryConnectedServiceCountsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InventoryConnectedServiceCounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InventoryConnectedServiceCounts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServiceCounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &self.serviceCounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceCounts.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: self.serviceCounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_InventoryConnectedServiceCounts, rhs: Proto_InventoryConnectedServiceCounts) -> Bool {
    if lhs.serviceCounts != rhs.serviceCounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InventoryPingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InventoryPingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServerID"),
    2: .same(proto: "ControlLog"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.controlLog) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverID, fieldNumber: 1)
    }
    if self.controlLog != false {
      try visitor.visitSingularBoolField(value: self.controlLog, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_InventoryPingRequest, rhs: Proto_InventoryPingRequest) -> Bool {
    if lhs.serverID != rhs.serverID {return false}
    if lhs.controlLog != rhs.controlLog {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_InventoryPingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InventoryPingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_InventoryPingResponse, rhs: Proto_InventoryPingResponse) -> Bool {
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetClusterAlertsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetClusterAlertsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Alerts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.alerts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alerts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alerts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetClusterAlertsResponse, rhs: Proto_GetClusterAlertsResponse) -> Bool {
    if lhs.alerts != rhs.alerts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetAlertAcksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAlertAcksRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetAlertAcksRequest, rhs: Proto_GetAlertAcksRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetAlertAcksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAlertAcksResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Acks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.acks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.acks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.acks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetAlertAcksResponse, rhs: Proto_GetAlertAcksResponse) -> Bool {
    if lhs.acks != rhs.acks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ClearAlertAcksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClearAlertAcksRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AlertID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.alertID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alertID.isEmpty {
      try visitor.visitSingularStringField(value: self.alertID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ClearAlertAcksRequest, rhs: Proto_ClearAlertAcksRequest) -> Bool {
    if lhs.alertID != rhs.alertID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpsertClusterAlertRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertClusterAlertRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Alert"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._alert) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._alert {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpsertClusterAlertRequest, rhs: Proto_UpsertClusterAlertRequest) -> Bool {
    if lhs._alert != rhs._alert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetConnectionDiagnosticRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionDiagnosticRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetConnectionDiagnosticRequest, rhs: Proto_GetConnectionDiagnosticRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AppendDiagnosticTraceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppendDiagnosticTraceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Trace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._trace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._trace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AppendDiagnosticTraceRequest, rhs: Proto_AppendDiagnosticTraceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._trace != rhs._trace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_SubmitUsageEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmitUsageEventRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_SubmitUsageEventRequest, rhs: Proto_SubmitUsageEventRequest) -> Bool {
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetLicenseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLicenseRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetLicenseRequest, rhs: Proto_GetLicenseRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ListReleasesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListReleasesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ListReleasesRequest, rhs: Proto_ListReleasesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_CreateTokenV2Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateTokenV2Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "V2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Types_ProvisionTokenV2?
        var hadOneofValue = false
        if let current = self.token {
          hadOneofValue = true
          if case .v2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.token = .v2(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v2(let v)? = self.token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_CreateTokenV2Request, rhs: Proto_CreateTokenV2Request) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpsertTokenV2Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpsertTokenV2Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "V2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Types_ProvisionTokenV2?
        var hadOneofValue = false
        if let current = self.token {
          hadOneofValue = true
          if case .v2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.token = .v2(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .v2(let v)? = self.token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpsertTokenV2Request, rhs: Proto_UpsertTokenV2Request) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_GetHeadlessAuthenticationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetHeadlessAuthenticationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_GetHeadlessAuthenticationRequest, rhs: Proto_GetHeadlessAuthenticationRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_UpdateHeadlessAuthenticationStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateHeadlessAuthenticationStateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "state"),
    3: .standard(proto: "mfa_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mfaResponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._mfaResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_UpdateHeadlessAuthenticationStateRequest, rhs: Proto_UpdateHeadlessAuthenticationStateRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.state != rhs.state {return false}
    if lhs._mfaResponse != rhs._mfaResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ExportUpgradeWindowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExportUpgradeWindowsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TeleportVersion"),
    2: .same(proto: "UpgraderKind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.teleportVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.upgraderKind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.teleportVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.teleportVersion, fieldNumber: 1)
    }
    if !self.upgraderKind.isEmpty {
      try visitor.visitSingularStringField(value: self.upgraderKind, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ExportUpgradeWindowsRequest, rhs: Proto_ExportUpgradeWindowsRequest) -> Bool {
    if lhs.teleportVersion != rhs.teleportVersion {return false}
    if lhs.upgraderKind != rhs.upgraderKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_ExportUpgradeWindowsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExportUpgradeWindowsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CanonicalSchedule"),
    2: .same(proto: "KubeControllerSchedule"),
    3: .same(proto: "SystemdUnitSchedule"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._canonicalSchedule) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kubeControllerSchedule) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.systemdUnitSchedule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._canonicalSchedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.kubeControllerSchedule.isEmpty {
      try visitor.visitSingularStringField(value: self.kubeControllerSchedule, fieldNumber: 2)
    }
    if !self.systemdUnitSchedule.isEmpty {
      try visitor.visitSingularStringField(value: self.systemdUnitSchedule, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_ExportUpgradeWindowsResponse, rhs: Proto_ExportUpgradeWindowsResponse) -> Bool {
    if lhs._canonicalSchedule != rhs._canonicalSchedule {return false}
    if lhs.kubeControllerSchedule != rhs.kubeControllerSchedule {return false}
    if lhs.systemdUnitSchedule != rhs.systemdUnitSchedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccessRequestAllowedPromotionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestAllowedPromotionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accessRequestID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessRequestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessRequestID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AccessRequestAllowedPromotionRequest, rhs: Proto_AccessRequestAllowedPromotionRequest) -> Bool {
    if lhs.accessRequestID != rhs.accessRequestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Proto_AccessRequestAllowedPromotionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestAllowedPromotionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allowedPromotions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._allowedPromotions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._allowedPromotions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_AccessRequestAllowedPromotionResponse, rhs: Proto_AccessRequestAllowedPromotionResponse) -> Bool {
    if lhs._allowedPromotions != rhs._allowedPromotions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
