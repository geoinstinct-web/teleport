// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/legacy/client/proto/event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Operation identifies type of operation
enum Proto_Operation: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// INIT is sent as a first sentinel event
  /// on the watch channel
  case init_ // = 0

  /// PUT identifies created or updated object
  case put // = 1

  /// DELETE identifies deleted object
  case delete // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .init_
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .init_
    case 1: self = .put
    case 2: self = .delete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .init_: return 0
    case .put: return 1
    case .delete: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Proto_Operation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Proto_Operation] = [
    .init_,
    .put,
    .delete,
  ]
}

#endif  // swift(>=4.2)

/// Event returns cluster event
struct Proto_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation identifies operation
  var type: Proto_Operation {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Resource contains the updated resource
  var resource: OneOf_Resource? {
    get {return _storage._resource}
    set {_uniqueStorage()._resource = newValue}
  }

  /// ResourceHeader is specified in delete events,
  /// the full object is not available, so resource
  /// header is used to provide information about object type
  var resourceHeader: Types_ResourceHeader {
    get {
      if case .resourceHeader(let v)? = _storage._resource {return v}
      return Types_ResourceHeader()
    }
    set {_uniqueStorage()._resource = .resourceHeader(newValue)}
  }

  /// CertAuthority is filled in certificate-authority related events
  var certAuthority: Types_CertAuthorityV2 {
    get {
      if case .certAuthority(let v)? = _storage._resource {return v}
      return Types_CertAuthorityV2()
    }
    set {_uniqueStorage()._resource = .certAuthority(newValue)}
  }

  /// StaticTokens is filled in static-tokens related events
  var staticTokens: Types_StaticTokensV2 {
    get {
      if case .staticTokens(let v)? = _storage._resource {return v}
      return Types_StaticTokensV2()
    }
    set {_uniqueStorage()._resource = .staticTokens(newValue)}
  }

  /// ProvisionToken is filled in provision-token related events
  var provisionToken: Types_ProvisionTokenV2 {
    get {
      if case .provisionToken(let v)? = _storage._resource {return v}
      return Types_ProvisionTokenV2()
    }
    set {_uniqueStorage()._resource = .provisionToken(newValue)}
  }

  /// ClusterNameV2 is a cluster name resource
  var clusterName: Types_ClusterNameV2 {
    get {
      if case .clusterName(let v)? = _storage._resource {return v}
      return Types_ClusterNameV2()
    }
    set {_uniqueStorage()._resource = .clusterName(newValue)}
  }

  /// User is a user resource
  var user: Types_UserV2 {
    get {
      if case .user(let v)? = _storage._resource {return v}
      return Types_UserV2()
    }
    set {_uniqueStorage()._resource = .user(newValue)}
  }

  /// Role is a role resource
  var role: Types_RoleV6 {
    get {
      if case .role(let v)? = _storage._resource {return v}
      return Types_RoleV6()
    }
    set {_uniqueStorage()._resource = .role(newValue)}
  }

  /// Namespace is a namespace resource
  var namespace: Types_Namespace {
    get {
      if case .namespace(let v)? = _storage._resource {return v}
      return Types_Namespace()
    }
    set {_uniqueStorage()._resource = .namespace(newValue)}
  }

  /// Server is a node or proxy resource
  var server: Types_ServerV2 {
    get {
      if case .server(let v)? = _storage._resource {return v}
      return Types_ServerV2()
    }
    set {_uniqueStorage()._resource = .server(newValue)}
  }

  /// ReverseTunnel is a resource with reverse tunnel
  var reverseTunnel: Types_ReverseTunnelV2 {
    get {
      if case .reverseTunnel(let v)? = _storage._resource {return v}
      return Types_ReverseTunnelV2()
    }
    set {_uniqueStorage()._resource = .reverseTunnel(newValue)}
  }

  /// TunnelConnection is a resource for tunnel connnections
  var tunnelConnection: Types_TunnelConnectionV2 {
    get {
      if case .tunnelConnection(let v)? = _storage._resource {return v}
      return Types_TunnelConnectionV2()
    }
    set {_uniqueStorage()._resource = .tunnelConnection(newValue)}
  }

  /// AccessRequest is a resource for access requests
  var accessRequest: Types_AccessRequestV3 {
    get {
      if case .accessRequest(let v)? = _storage._resource {return v}
      return Types_AccessRequestV3()
    }
    set {_uniqueStorage()._resource = .accessRequest(newValue)}
  }

  /// AppSession is an application web session.
  var appSession: Types_WebSessionV2 {
    get {
      if case .appSession(let v)? = _storage._resource {return v}
      return Types_WebSessionV2()
    }
    set {_uniqueStorage()._resource = .appSession(newValue)}
  }

  /// RemoteCluster is a resource for remote clusters
  var remoteCluster: Types_RemoteClusterV3 {
    get {
      if case .remoteCluster(let v)? = _storage._resource {return v}
      return Types_RemoteClusterV3()
    }
    set {_uniqueStorage()._resource = .remoteCluster(newValue)}
  }

  /// DatabaseServer is a resource for database servers.
  var databaseServer: Types_DatabaseServerV3 {
    get {
      if case .databaseServer(let v)? = _storage._resource {return v}
      return Types_DatabaseServerV3()
    }
    set {_uniqueStorage()._resource = .databaseServer(newValue)}
  }

  /// WebSession is a regular web session.
  var webSession: Types_WebSessionV2 {
    get {
      if case .webSession(let v)? = _storage._resource {return v}
      return Types_WebSessionV2()
    }
    set {_uniqueStorage()._resource = .webSession(newValue)}
  }

  /// WebToken is a web token.
  var webToken: Types_WebTokenV3 {
    get {
      if case .webToken(let v)? = _storage._resource {return v}
      return Types_WebTokenV3()
    }
    set {_uniqueStorage()._resource = .webToken(newValue)}
  }

  /// ClusterNetworkingConfig is a resource for cluster networking configuration.
  var clusterNetworkingConfig: Types_ClusterNetworkingConfigV2 {
    get {
      if case .clusterNetworkingConfig(let v)? = _storage._resource {return v}
      return Types_ClusterNetworkingConfigV2()
    }
    set {_uniqueStorage()._resource = .clusterNetworkingConfig(newValue)}
  }

  /// SessionRecordingConfig is a resource for session recording configuration.
  var sessionRecordingConfig: Types_SessionRecordingConfigV2 {
    get {
      if case .sessionRecordingConfig(let v)? = _storage._resource {return v}
      return Types_SessionRecordingConfigV2()
    }
    set {_uniqueStorage()._resource = .sessionRecordingConfig(newValue)}
  }

  /// AuthPreference is cluster auth preference.
  var authPreference: Types_AuthPreferenceV2 {
    get {
      if case .authPreference(let v)? = _storage._resource {return v}
      return Types_AuthPreferenceV2()
    }
    set {_uniqueStorage()._resource = .authPreference(newValue)}
  }

  /// ClusterAuditConfig is a resource for cluster audit configuration.
  var clusterAuditConfig: Types_ClusterAuditConfigV2 {
    get {
      if case .clusterAuditConfig(let v)? = _storage._resource {return v}
      return Types_ClusterAuditConfigV2()
    }
    set {_uniqueStorage()._resource = .clusterAuditConfig(newValue)}
  }

  /// Lock is a lock resource.
  var lock: Types_LockV2 {
    get {
      if case .lock(let v)? = _storage._resource {return v}
      return Types_LockV2()
    }
    set {_uniqueStorage()._resource = .lock(newValue)}
  }

  /// NetworkRestrictions is a resource for network restrictions
  var networkRestrictions: Types_NetworkRestrictionsV4 {
    get {
      if case .networkRestrictions(let v)? = _storage._resource {return v}
      return Types_NetworkRestrictionsV4()
    }
    set {_uniqueStorage()._resource = .networkRestrictions(newValue)}
  }

  /// WindowsDesktopService is a resource for Windows desktop services.
  var windowsDesktopService: Types_WindowsDesktopServiceV3 {
    get {
      if case .windowsDesktopService(let v)? = _storage._resource {return v}
      return Types_WindowsDesktopServiceV3()
    }
    set {_uniqueStorage()._resource = .windowsDesktopService(newValue)}
  }

  /// WindowsDesktop is a resource for Windows desktop host.
  var windowsDesktop: Types_WindowsDesktopV3 {
    get {
      if case .windowsDesktop(let v)? = _storage._resource {return v}
      return Types_WindowsDesktopV3()
    }
    set {_uniqueStorage()._resource = .windowsDesktop(newValue)}
  }

  /// Database is a database resource.
  var database: Types_DatabaseV3 {
    get {
      if case .database(let v)? = _storage._resource {return v}
      return Types_DatabaseV3()
    }
    set {_uniqueStorage()._resource = .database(newValue)}
  }

  /// AppServer is an application server resource.
  var appServer: Types_AppServerV3 {
    get {
      if case .appServer(let v)? = _storage._resource {return v}
      return Types_AppServerV3()
    }
    set {_uniqueStorage()._resource = .appServer(newValue)}
  }

  /// App is an application resource.
  var app: Types_AppV3 {
    get {
      if case .app(let v)? = _storage._resource {return v}
      return Types_AppV3()
    }
    set {_uniqueStorage()._resource = .app(newValue)}
  }

  /// SnowflakeSession is a Snowflake web session.
  var snowflakeSession: Types_WebSessionV2 {
    get {
      if case .snowflakeSession(let v)? = _storage._resource {return v}
      return Types_WebSessionV2()
    }
    set {_uniqueStorage()._resource = .snowflakeSession(newValue)}
  }

  /// KubernetesServer is an Kubernetes server resource.
  var kubernetesServer: Types_KubernetesServerV3 {
    get {
      if case .kubernetesServer(let v)? = _storage._resource {return v}
      return Types_KubernetesServerV3()
    }
    set {_uniqueStorage()._resource = .kubernetesServer(newValue)}
  }

  /// KubernetesCluster is an Kubernetes cluster resource.
  var kubernetesCluster: Types_KubernetesClusterV3 {
    get {
      if case .kubernetesCluster(let v)? = _storage._resource {return v}
      return Types_KubernetesClusterV3()
    }
    set {_uniqueStorage()._resource = .kubernetesCluster(newValue)}
  }

  /// Installer is an installer resource
  var installer: Types_InstallerV1 {
    get {
      if case .installer(let v)? = _storage._resource {return v}
      return Types_InstallerV1()
    }
    set {_uniqueStorage()._resource = .installer(newValue)}
  }

  /// DatabaseService is a DatabaseService resource
  var databaseService: Types_DatabaseServiceV1 {
    get {
      if case .databaseService(let v)? = _storage._resource {return v}
      return Types_DatabaseServiceV1()
    }
    set {_uniqueStorage()._resource = .databaseService(newValue)}
  }

  /// SAMLIdPServiceProvider is a SAMLIdPServiceProvider resource
  var samlidPserviceProvider: Types_SAMLIdPServiceProviderV1 {
    get {
      if case .samlidPserviceProvider(let v)? = _storage._resource {return v}
      return Types_SAMLIdPServiceProviderV1()
    }
    set {_uniqueStorage()._resource = .samlidPserviceProvider(newValue)}
  }

  /// SAMLIdPSession is a SAML IdP session.
  var samlidPsession: Types_WebSessionV2 {
    get {
      if case .samlidPsession(let v)? = _storage._resource {return v}
      return Types_WebSessionV2()
    }
    set {_uniqueStorage()._resource = .samlidPsession(newValue)}
  }

  /// UserGroup is a UserGroup resource
  var userGroup: Types_UserGroupV1 {
    get {
      if case .userGroup(let v)? = _storage._resource {return v}
      return Types_UserGroupV1()
    }
    set {_uniqueStorage()._resource = .userGroup(newValue)}
  }

  /// UIConfig provides a way for users to adjust settings of the UI served by the proxy service.
  var uiconfig: Types_UIConfigV1 {
    get {
      if case .uiconfig(let v)? = _storage._resource {return v}
      return Types_UIConfigV1()
    }
    set {_uniqueStorage()._resource = .uiconfig(newValue)}
  }

  /// OktaImportRule is an OktaImportRule resource.
  var oktaImportRule: Types_OktaImportRuleV1 {
    get {
      if case .oktaImportRule(let v)? = _storage._resource {return v}
      return Types_OktaImportRuleV1()
    }
    set {_uniqueStorage()._resource = .oktaImportRule(newValue)}
  }

  /// OktaAssignment is an OktaAssignment resource.
  var oktaAssignment: Types_OktaAssignmentV1 {
    get {
      if case .oktaAssignment(let v)? = _storage._resource {return v}
      return Types_OktaAssignmentV1()
    }
    set {_uniqueStorage()._resource = .oktaAssignment(newValue)}
  }

  /// Integration is an Integration resource.
  var integration: Types_IntegrationV1 {
    get {
      if case .integration(let v)? = _storage._resource {return v}
      return Types_IntegrationV1()
    }
    set {_uniqueStorage()._resource = .integration(newValue)}
  }

  /// WatchStatus is an WatchStatus resource.
  var watchStatus: Types_WatchStatusV1 {
    get {
      if case .watchStatus(let v)? = _storage._resource {return v}
      return Types_WatchStatusV1()
    }
    set {_uniqueStorage()._resource = .watchStatus(newValue)}
  }

  /// HeadlessAuthentication is a HeadlessAuthentication resource.
  var headlessAuthentication: Types_HeadlessAuthentication {
    get {
      if case .headlessAuthentication(let v)? = _storage._resource {return v}
      return Types_HeadlessAuthentication()
    }
    set {_uniqueStorage()._resource = .headlessAuthentication(newValue)}
  }

  /// AccessList is an AccessList resource.
  var accessList: Teleport_Accesslist_V1_AccessList {
    get {
      if case .accessList(let v)? = _storage._resource {return v}
      return Teleport_Accesslist_V1_AccessList()
    }
    set {_uniqueStorage()._resource = .accessList(newValue)}
  }

  /// UserLoginState is a UserLoginState resource.
  var userLoginState: Teleport_Userloginstate_V1_UserLoginState {
    get {
      if case .userLoginState(let v)? = _storage._resource {return v}
      return Teleport_Userloginstate_V1_UserLoginState()
    }
    set {_uniqueStorage()._resource = .userLoginState(newValue)}
  }

  /// AccessListMember is an access list member resource.
  var accessListMember: Teleport_Accesslist_V1_Member {
    get {
      if case .accessListMember(let v)? = _storage._resource {return v}
      return Teleport_Accesslist_V1_Member()
    }
    set {_uniqueStorage()._resource = .accessListMember(newValue)}
  }

  /// DiscoveryConfig contains a list of matchers to be loaded dynamically by Discovery Services.
  var discoveryConfig: Teleport_Discoveryconfig_V1_DiscoveryConfig {
    get {
      if case .discoveryConfig(let v)? = _storage._resource {return v}
      return Teleport_Discoveryconfig_V1_DiscoveryConfig()
    }
    set {_uniqueStorage()._resource = .discoveryConfig(newValue)}
  }

  /// ExternalCloudAudit is an ExternalCloudAudit resource.
  var externalCloudAudit: Teleport_Externalcloudaudit_V1_ExternalCloudAudit {
    get {
      if case .externalCloudAudit(let v)? = _storage._resource {return v}
      return Teleport_Externalcloudaudit_V1_ExternalCloudAudit()
    }
    set {_uniqueStorage()._resource = .externalCloudAudit(newValue)}
  }

  /// AuditQuery is an audit query resource.
  var auditQuery: Teleport_Secreports_V1_AuditQuery {
    get {
      if case .auditQuery(let v)? = _storage._resource {return v}
      return Teleport_Secreports_V1_AuditQuery()
    }
    set {_uniqueStorage()._resource = .auditQuery(newValue)}
  }

  /// SecurityReport is a security report resource.
  var report: Teleport_Secreports_V1_Report {
    get {
      if case .report(let v)? = _storage._resource {return v}
      return Teleport_Secreports_V1_Report()
    }
    set {_uniqueStorage()._resource = .report(newValue)}
  }

  /// SecurityReportState is a security report state resource.
  var reportState: Teleport_Secreports_V1_ReportState {
    get {
      if case .reportState(let v)? = _storage._resource {return v}
      return Teleport_Secreports_V1_ReportState()
    }
    set {_uniqueStorage()._resource = .reportState(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Resource contains the updated resource
  enum OneOf_Resource: Equatable {
    /// ResourceHeader is specified in delete events,
    /// the full object is not available, so resource
    /// header is used to provide information about object type
    case resourceHeader(Types_ResourceHeader)
    /// CertAuthority is filled in certificate-authority related events
    case certAuthority(Types_CertAuthorityV2)
    /// StaticTokens is filled in static-tokens related events
    case staticTokens(Types_StaticTokensV2)
    /// ProvisionToken is filled in provision-token related events
    case provisionToken(Types_ProvisionTokenV2)
    /// ClusterNameV2 is a cluster name resource
    case clusterName(Types_ClusterNameV2)
    /// User is a user resource
    case user(Types_UserV2)
    /// Role is a role resource
    case role(Types_RoleV6)
    /// Namespace is a namespace resource
    case namespace(Types_Namespace)
    /// Server is a node or proxy resource
    case server(Types_ServerV2)
    /// ReverseTunnel is a resource with reverse tunnel
    case reverseTunnel(Types_ReverseTunnelV2)
    /// TunnelConnection is a resource for tunnel connnections
    case tunnelConnection(Types_TunnelConnectionV2)
    /// AccessRequest is a resource for access requests
    case accessRequest(Types_AccessRequestV3)
    /// AppSession is an application web session.
    case appSession(Types_WebSessionV2)
    /// RemoteCluster is a resource for remote clusters
    case remoteCluster(Types_RemoteClusterV3)
    /// DatabaseServer is a resource for database servers.
    case databaseServer(Types_DatabaseServerV3)
    /// WebSession is a regular web session.
    case webSession(Types_WebSessionV2)
    /// WebToken is a web token.
    case webToken(Types_WebTokenV3)
    /// ClusterNetworkingConfig is a resource for cluster networking configuration.
    case clusterNetworkingConfig(Types_ClusterNetworkingConfigV2)
    /// SessionRecordingConfig is a resource for session recording configuration.
    case sessionRecordingConfig(Types_SessionRecordingConfigV2)
    /// AuthPreference is cluster auth preference.
    case authPreference(Types_AuthPreferenceV2)
    /// ClusterAuditConfig is a resource for cluster audit configuration.
    case clusterAuditConfig(Types_ClusterAuditConfigV2)
    /// Lock is a lock resource.
    case lock(Types_LockV2)
    /// NetworkRestrictions is a resource for network restrictions
    case networkRestrictions(Types_NetworkRestrictionsV4)
    /// WindowsDesktopService is a resource for Windows desktop services.
    case windowsDesktopService(Types_WindowsDesktopServiceV3)
    /// WindowsDesktop is a resource for Windows desktop host.
    case windowsDesktop(Types_WindowsDesktopV3)
    /// Database is a database resource.
    case database(Types_DatabaseV3)
    /// AppServer is an application server resource.
    case appServer(Types_AppServerV3)
    /// App is an application resource.
    case app(Types_AppV3)
    /// SnowflakeSession is a Snowflake web session.
    case snowflakeSession(Types_WebSessionV2)
    /// KubernetesServer is an Kubernetes server resource.
    case kubernetesServer(Types_KubernetesServerV3)
    /// KubernetesCluster is an Kubernetes cluster resource.
    case kubernetesCluster(Types_KubernetesClusterV3)
    /// Installer is an installer resource
    case installer(Types_InstallerV1)
    /// DatabaseService is a DatabaseService resource
    case databaseService(Types_DatabaseServiceV1)
    /// SAMLIdPServiceProvider is a SAMLIdPServiceProvider resource
    case samlidPserviceProvider(Types_SAMLIdPServiceProviderV1)
    /// SAMLIdPSession is a SAML IdP session.
    case samlidPsession(Types_WebSessionV2)
    /// UserGroup is a UserGroup resource
    case userGroup(Types_UserGroupV1)
    /// UIConfig provides a way for users to adjust settings of the UI served by the proxy service.
    case uiconfig(Types_UIConfigV1)
    /// OktaImportRule is an OktaImportRule resource.
    case oktaImportRule(Types_OktaImportRuleV1)
    /// OktaAssignment is an OktaAssignment resource.
    case oktaAssignment(Types_OktaAssignmentV1)
    /// Integration is an Integration resource.
    case integration(Types_IntegrationV1)
    /// WatchStatus is an WatchStatus resource.
    case watchStatus(Types_WatchStatusV1)
    /// HeadlessAuthentication is a HeadlessAuthentication resource.
    case headlessAuthentication(Types_HeadlessAuthentication)
    /// AccessList is an AccessList resource.
    case accessList(Teleport_Accesslist_V1_AccessList)
    /// UserLoginState is a UserLoginState resource.
    case userLoginState(Teleport_Userloginstate_V1_UserLoginState)
    /// AccessListMember is an access list member resource.
    case accessListMember(Teleport_Accesslist_V1_Member)
    /// DiscoveryConfig contains a list of matchers to be loaded dynamically by Discovery Services.
    case discoveryConfig(Teleport_Discoveryconfig_V1_DiscoveryConfig)
    /// ExternalCloudAudit is an ExternalCloudAudit resource.
    case externalCloudAudit(Teleport_Externalcloudaudit_V1_ExternalCloudAudit)
    /// AuditQuery is an audit query resource.
    case auditQuery(Teleport_Secreports_V1_AuditQuery)
    /// SecurityReport is a security report resource.
    case report(Teleport_Secreports_V1_Report)
    /// SecurityReportState is a security report state resource.
    case reportState(Teleport_Secreports_V1_ReportState)

  #if !swift(>=4.1)
    static func ==(lhs: Proto_Event.OneOf_Resource, rhs: Proto_Event.OneOf_Resource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.resourceHeader, .resourceHeader): return {
        guard case .resourceHeader(let l) = lhs, case .resourceHeader(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.certAuthority, .certAuthority): return {
        guard case .certAuthority(let l) = lhs, case .certAuthority(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.staticTokens, .staticTokens): return {
        guard case .staticTokens(let l) = lhs, case .staticTokens(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.provisionToken, .provisionToken): return {
        guard case .provisionToken(let l) = lhs, case .provisionToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clusterName, .clusterName): return {
        guard case .clusterName(let l) = lhs, case .clusterName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.user, .user): return {
        guard case .user(let l) = lhs, case .user(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.role, .role): return {
        guard case .role(let l) = lhs, case .role(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.namespace, .namespace): return {
        guard case .namespace(let l) = lhs, case .namespace(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.server, .server): return {
        guard case .server(let l) = lhs, case .server(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reverseTunnel, .reverseTunnel): return {
        guard case .reverseTunnel(let l) = lhs, case .reverseTunnel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tunnelConnection, .tunnelConnection): return {
        guard case .tunnelConnection(let l) = lhs, case .tunnelConnection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessRequest, .accessRequest): return {
        guard case .accessRequest(let l) = lhs, case .accessRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appSession, .appSession): return {
        guard case .appSession(let l) = lhs, case .appSession(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remoteCluster, .remoteCluster): return {
        guard case .remoteCluster(let l) = lhs, case .remoteCluster(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseServer, .databaseServer): return {
        guard case .databaseServer(let l) = lhs, case .databaseServer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webSession, .webSession): return {
        guard case .webSession(let l) = lhs, case .webSession(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webToken, .webToken): return {
        guard case .webToken(let l) = lhs, case .webToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clusterNetworkingConfig, .clusterNetworkingConfig): return {
        guard case .clusterNetworkingConfig(let l) = lhs, case .clusterNetworkingConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionRecordingConfig, .sessionRecordingConfig): return {
        guard case .sessionRecordingConfig(let l) = lhs, case .sessionRecordingConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authPreference, .authPreference): return {
        guard case .authPreference(let l) = lhs, case .authPreference(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clusterAuditConfig, .clusterAuditConfig): return {
        guard case .clusterAuditConfig(let l) = lhs, case .clusterAuditConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lock, .lock): return {
        guard case .lock(let l) = lhs, case .lock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.networkRestrictions, .networkRestrictions): return {
        guard case .networkRestrictions(let l) = lhs, case .networkRestrictions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsDesktopService, .windowsDesktopService): return {
        guard case .windowsDesktopService(let l) = lhs, case .windowsDesktopService(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsDesktop, .windowsDesktop): return {
        guard case .windowsDesktop(let l) = lhs, case .windowsDesktop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.database, .database): return {
        guard case .database(let l) = lhs, case .database(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appServer, .appServer): return {
        guard case .appServer(let l) = lhs, case .appServer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.app, .app): return {
        guard case .app(let l) = lhs, case .app(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.snowflakeSession, .snowflakeSession): return {
        guard case .snowflakeSession(let l) = lhs, case .snowflakeSession(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kubernetesServer, .kubernetesServer): return {
        guard case .kubernetesServer(let l) = lhs, case .kubernetesServer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kubernetesCluster, .kubernetesCluster): return {
        guard case .kubernetesCluster(let l) = lhs, case .kubernetesCluster(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.installer, .installer): return {
        guard case .installer(let l) = lhs, case .installer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseService, .databaseService): return {
        guard case .databaseService(let l) = lhs, case .databaseService(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlidPserviceProvider, .samlidPserviceProvider): return {
        guard case .samlidPserviceProvider(let l) = lhs, case .samlidPserviceProvider(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlidPsession, .samlidPsession): return {
        guard case .samlidPsession(let l) = lhs, case .samlidPsession(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userGroup, .userGroup): return {
        guard case .userGroup(let l) = lhs, case .userGroup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiconfig, .uiconfig): return {
        guard case .uiconfig(let l) = lhs, case .uiconfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oktaImportRule, .oktaImportRule): return {
        guard case .oktaImportRule(let l) = lhs, case .oktaImportRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oktaAssignment, .oktaAssignment): return {
        guard case .oktaAssignment(let l) = lhs, case .oktaAssignment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integration, .integration): return {
        guard case .integration(let l) = lhs, case .integration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.watchStatus, .watchStatus): return {
        guard case .watchStatus(let l) = lhs, case .watchStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.headlessAuthentication, .headlessAuthentication): return {
        guard case .headlessAuthentication(let l) = lhs, case .headlessAuthentication(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessList, .accessList): return {
        guard case .accessList(let l) = lhs, case .accessList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userLoginState, .userLoginState): return {
        guard case .userLoginState(let l) = lhs, case .userLoginState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListMember, .accessListMember): return {
        guard case .accessListMember(let l) = lhs, case .accessListMember(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.discoveryConfig, .discoveryConfig): return {
        guard case .discoveryConfig(let l) = lhs, case .discoveryConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.externalCloudAudit, .externalCloudAudit): return {
        guard case .externalCloudAudit(let l) = lhs, case .externalCloudAudit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.auditQuery, .auditQuery): return {
        guard case .auditQuery(let l) = lhs, case .auditQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.report, .report): return {
        guard case .report(let l) = lhs, case .report(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reportState, .reportState): return {
        guard case .reportState(let l) = lhs, case .reportState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto_Operation: @unchecked Sendable {}
extension Proto_Event: @unchecked Sendable {}
extension Proto_Event.OneOf_Resource: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "proto"

extension Proto_Operation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INIT"),
    1: .same(proto: "PUT"),
    2: .same(proto: "DELETE"),
  ]
}

extension Proto_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "ResourceHeader"),
    3: .same(proto: "CertAuthority"),
    4: .same(proto: "StaticTokens"),
    5: .same(proto: "ProvisionToken"),
    6: .same(proto: "ClusterName"),
    8: .same(proto: "User"),
    9: .same(proto: "Role"),
    10: .same(proto: "Namespace"),
    11: .same(proto: "Server"),
    12: .same(proto: "ReverseTunnel"),
    13: .same(proto: "TunnelConnection"),
    14: .same(proto: "AccessRequest"),
    15: .same(proto: "AppSession"),
    16: .same(proto: "RemoteCluster"),
    17: .same(proto: "DatabaseServer"),
    18: .same(proto: "WebSession"),
    19: .same(proto: "WebToken"),
    20: .same(proto: "ClusterNetworkingConfig"),
    21: .same(proto: "SessionRecordingConfig"),
    22: .same(proto: "AuthPreference"),
    23: .same(proto: "ClusterAuditConfig"),
    24: .same(proto: "Lock"),
    25: .same(proto: "NetworkRestrictions"),
    26: .same(proto: "WindowsDesktopService"),
    27: .same(proto: "WindowsDesktop"),
    28: .same(proto: "Database"),
    29: .same(proto: "AppServer"),
    30: .same(proto: "App"),
    31: .same(proto: "SnowflakeSession"),
    32: .same(proto: "KubernetesServer"),
    33: .same(proto: "KubernetesCluster"),
    34: .same(proto: "Installer"),
    35: .same(proto: "DatabaseService"),
    36: .same(proto: "SAMLIdPServiceProvider"),
    37: .same(proto: "SAMLIdPSession"),
    38: .same(proto: "UserGroup"),
    39: .same(proto: "UIConfig"),
    40: .same(proto: "OktaImportRule"),
    41: .same(proto: "OktaAssignment"),
    42: .same(proto: "Integration"),
    43: .same(proto: "WatchStatus"),
    44: .same(proto: "HeadlessAuthentication"),
    45: .same(proto: "AccessList"),
    46: .same(proto: "UserLoginState"),
    47: .same(proto: "AccessListMember"),
    48: .same(proto: "DiscoveryConfig"),
    49: .same(proto: "ExternalCloudAudit"),
    50: .same(proto: "AuditQuery"),
    51: .same(proto: "Report"),
    52: .same(proto: "ReportState"),
  ]

  fileprivate class _StorageClass {
    var _type: Proto_Operation = .init_
    var _resource: Proto_Event.OneOf_Resource?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _resource = source._resource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try {
          var v: Types_ResourceHeader?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .resourceHeader(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .resourceHeader(v)
          }
        }()
        case 3: try {
          var v: Types_CertAuthorityV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .certAuthority(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .certAuthority(v)
          }
        }()
        case 4: try {
          var v: Types_StaticTokensV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .staticTokens(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .staticTokens(v)
          }
        }()
        case 5: try {
          var v: Types_ProvisionTokenV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .provisionToken(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .provisionToken(v)
          }
        }()
        case 6: try {
          var v: Types_ClusterNameV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .clusterName(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .clusterName(v)
          }
        }()
        case 8: try {
          var v: Types_UserV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .user(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .user(v)
          }
        }()
        case 9: try {
          var v: Types_RoleV6?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .role(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .role(v)
          }
        }()
        case 10: try {
          var v: Types_Namespace?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .namespace(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .namespace(v)
          }
        }()
        case 11: try {
          var v: Types_ServerV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .server(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .server(v)
          }
        }()
        case 12: try {
          var v: Types_ReverseTunnelV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .reverseTunnel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .reverseTunnel(v)
          }
        }()
        case 13: try {
          var v: Types_TunnelConnectionV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .tunnelConnection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .tunnelConnection(v)
          }
        }()
        case 14: try {
          var v: Types_AccessRequestV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .accessRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .accessRequest(v)
          }
        }()
        case 15: try {
          var v: Types_WebSessionV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .appSession(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .appSession(v)
          }
        }()
        case 16: try {
          var v: Types_RemoteClusterV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .remoteCluster(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .remoteCluster(v)
          }
        }()
        case 17: try {
          var v: Types_DatabaseServerV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .databaseServer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .databaseServer(v)
          }
        }()
        case 18: try {
          var v: Types_WebSessionV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .webSession(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .webSession(v)
          }
        }()
        case 19: try {
          var v: Types_WebTokenV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .webToken(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .webToken(v)
          }
        }()
        case 20: try {
          var v: Types_ClusterNetworkingConfigV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .clusterNetworkingConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .clusterNetworkingConfig(v)
          }
        }()
        case 21: try {
          var v: Types_SessionRecordingConfigV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .sessionRecordingConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .sessionRecordingConfig(v)
          }
        }()
        case 22: try {
          var v: Types_AuthPreferenceV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .authPreference(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .authPreference(v)
          }
        }()
        case 23: try {
          var v: Types_ClusterAuditConfigV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .clusterAuditConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .clusterAuditConfig(v)
          }
        }()
        case 24: try {
          var v: Types_LockV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .lock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .lock(v)
          }
        }()
        case 25: try {
          var v: Types_NetworkRestrictionsV4?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .networkRestrictions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .networkRestrictions(v)
          }
        }()
        case 26: try {
          var v: Types_WindowsDesktopServiceV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .windowsDesktopService(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .windowsDesktopService(v)
          }
        }()
        case 27: try {
          var v: Types_WindowsDesktopV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .windowsDesktop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .windowsDesktop(v)
          }
        }()
        case 28: try {
          var v: Types_DatabaseV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .database(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .database(v)
          }
        }()
        case 29: try {
          var v: Types_AppServerV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .appServer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .appServer(v)
          }
        }()
        case 30: try {
          var v: Types_AppV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .app(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .app(v)
          }
        }()
        case 31: try {
          var v: Types_WebSessionV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .snowflakeSession(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .snowflakeSession(v)
          }
        }()
        case 32: try {
          var v: Types_KubernetesServerV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .kubernetesServer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .kubernetesServer(v)
          }
        }()
        case 33: try {
          var v: Types_KubernetesClusterV3?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .kubernetesCluster(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .kubernetesCluster(v)
          }
        }()
        case 34: try {
          var v: Types_InstallerV1?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .installer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .installer(v)
          }
        }()
        case 35: try {
          var v: Types_DatabaseServiceV1?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .databaseService(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .databaseService(v)
          }
        }()
        case 36: try {
          var v: Types_SAMLIdPServiceProviderV1?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .samlidPserviceProvider(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .samlidPserviceProvider(v)
          }
        }()
        case 37: try {
          var v: Types_WebSessionV2?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .samlidPsession(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .samlidPsession(v)
          }
        }()
        case 38: try {
          var v: Types_UserGroupV1?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .userGroup(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .userGroup(v)
          }
        }()
        case 39: try {
          var v: Types_UIConfigV1?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .uiconfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .uiconfig(v)
          }
        }()
        case 40: try {
          var v: Types_OktaImportRuleV1?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .oktaImportRule(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .oktaImportRule(v)
          }
        }()
        case 41: try {
          var v: Types_OktaAssignmentV1?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .oktaAssignment(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .oktaAssignment(v)
          }
        }()
        case 42: try {
          var v: Types_IntegrationV1?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .integration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .integration(v)
          }
        }()
        case 43: try {
          var v: Types_WatchStatusV1?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .watchStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .watchStatus(v)
          }
        }()
        case 44: try {
          var v: Types_HeadlessAuthentication?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .headlessAuthentication(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .headlessAuthentication(v)
          }
        }()
        case 45: try {
          var v: Teleport_Accesslist_V1_AccessList?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .accessList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .accessList(v)
          }
        }()
        case 46: try {
          var v: Teleport_Userloginstate_V1_UserLoginState?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .userLoginState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .userLoginState(v)
          }
        }()
        case 47: try {
          var v: Teleport_Accesslist_V1_Member?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .accessListMember(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .accessListMember(v)
          }
        }()
        case 48: try {
          var v: Teleport_Discoveryconfig_V1_DiscoveryConfig?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .discoveryConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .discoveryConfig(v)
          }
        }()
        case 49: try {
          var v: Teleport_Externalcloudaudit_V1_ExternalCloudAudit?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .externalCloudAudit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .externalCloudAudit(v)
          }
        }()
        case 50: try {
          var v: Teleport_Secreports_V1_AuditQuery?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .auditQuery(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .auditQuery(v)
          }
        }()
        case 51: try {
          var v: Teleport_Secreports_V1_Report?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .report(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .report(v)
          }
        }()
        case 52: try {
          var v: Teleport_Secreports_V1_ReportState?
          var hadOneofValue = false
          if let current = _storage._resource {
            hadOneofValue = true
            if case .reportState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resource = .reportState(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._type != .init_ {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      switch _storage._resource {
      case .resourceHeader?: try {
        guard case .resourceHeader(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .certAuthority?: try {
        guard case .certAuthority(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .staticTokens?: try {
        guard case .staticTokens(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .provisionToken?: try {
        guard case .provisionToken(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .clusterName?: try {
        guard case .clusterName(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .user?: try {
        guard case .user(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .role?: try {
        guard case .role(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .namespace?: try {
        guard case .namespace(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .server?: try {
        guard case .server(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .reverseTunnel?: try {
        guard case .reverseTunnel(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .tunnelConnection?: try {
        guard case .tunnelConnection(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .accessRequest?: try {
        guard case .accessRequest(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .appSession?: try {
        guard case .appSession(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .remoteCluster?: try {
        guard case .remoteCluster(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .databaseServer?: try {
        guard case .databaseServer(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .webSession?: try {
        guard case .webSession(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .webToken?: try {
        guard case .webToken(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .clusterNetworkingConfig?: try {
        guard case .clusterNetworkingConfig(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .sessionRecordingConfig?: try {
        guard case .sessionRecordingConfig(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .authPreference?: try {
        guard case .authPreference(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .clusterAuditConfig?: try {
        guard case .clusterAuditConfig(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .lock?: try {
        guard case .lock(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .networkRestrictions?: try {
        guard case .networkRestrictions(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .windowsDesktopService?: try {
        guard case .windowsDesktopService(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .windowsDesktop?: try {
        guard case .windowsDesktop(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .database?: try {
        guard case .database(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .appServer?: try {
        guard case .appServer(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .app?: try {
        guard case .app(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .snowflakeSession?: try {
        guard case .snowflakeSession(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .kubernetesServer?: try {
        guard case .kubernetesServer(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .kubernetesCluster?: try {
        guard case .kubernetesCluster(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .installer?: try {
        guard case .installer(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .databaseService?: try {
        guard case .databaseService(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .samlidPserviceProvider?: try {
        guard case .samlidPserviceProvider(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .samlidPsession?: try {
        guard case .samlidPsession(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .userGroup?: try {
        guard case .userGroup(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .uiconfig?: try {
        guard case .uiconfig(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .oktaImportRule?: try {
        guard case .oktaImportRule(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .oktaAssignment?: try {
        guard case .oktaAssignment(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .integration?: try {
        guard case .integration(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .watchStatus?: try {
        guard case .watchStatus(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .headlessAuthentication?: try {
        guard case .headlessAuthentication(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }()
      case .accessList?: try {
        guard case .accessList(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      }()
      case .userLoginState?: try {
        guard case .userLoginState(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }()
      case .accessListMember?: try {
        guard case .accessListMember(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }()
      case .discoveryConfig?: try {
        guard case .discoveryConfig(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }()
      case .externalCloudAudit?: try {
        guard case .externalCloudAudit(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      }()
      case .auditQuery?: try {
        guard case .auditQuery(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .report?: try {
        guard case .report(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .reportState?: try {
        guard case .reportState(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Proto_Event, rhs: Proto_Event) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._resource != rhs_storage._resource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
