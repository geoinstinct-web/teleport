// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/legacy/types/events/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2021 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Action communicates what was done in response to the event
enum Events_EventAction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case observed // = 0
  case denied // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .observed
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .observed
    case 1: self = .denied
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .observed: return 0
    case .denied: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Events_EventAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Events_EventAction] = [
    .observed,
    .denied,
  ]
}

#endif  // swift(>=4.2)

/// SFTPAction denotes what type of SFTP request was made.
/// These actions were taken from https://datatracker.ietf.org/doc/html/draft-ietf-secsh-filexfer-02.
enum Events_SFTPAction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case invalid // = 0
  case `open` // = 1
  case close // = 2
  case read // = 3
  case write // = 4
  case lstat // = 5
  case fstat // = 6
  case setstat // = 7
  case fsetstat // = 8
  case opendir // = 9
  case readdir // = 10
  case remove // = 11
  case mkdir // = 12
  case rmdir // = 13
  case realpath // = 14
  case stat // = 15
  case rename // = 16
  case readlink // = 17
  case symlink // = 18
  case link // = 19
  case UNRECOGNIZED(Int)

  init() {
    self = .invalid
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .open
    case 2: self = .close
    case 3: self = .read
    case 4: self = .write
    case 5: self = .lstat
    case 6: self = .fstat
    case 7: self = .setstat
    case 8: self = .fsetstat
    case 9: self = .opendir
    case 10: self = .readdir
    case 11: self = .remove
    case 12: self = .mkdir
    case 13: self = .rmdir
    case 14: self = .realpath
    case 15: self = .stat
    case 16: self = .rename
    case 17: self = .readlink
    case 18: self = .symlink
    case 19: self = .link
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .open: return 1
    case .close: return 2
    case .read: return 3
    case .write: return 4
    case .lstat: return 5
    case .fstat: return 6
    case .setstat: return 7
    case .fsetstat: return 8
    case .opendir: return 9
    case .readdir: return 10
    case .remove: return 11
    case .mkdir: return 12
    case .rmdir: return 13
    case .realpath: return 14
    case .stat: return 15
    case .rename: return 16
    case .readlink: return 17
    case .symlink: return 18
    case .link: return 19
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Events_SFTPAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Events_SFTPAction] = [
    .invalid,
    .open,
    .close,
    .read,
    .write,
    .lstat,
    .fstat,
    .setstat,
    .fsetstat,
    .opendir,
    .readdir,
    .remove,
    .mkdir,
    .rmdir,
    .realpath,
    .stat,
    .rename,
    .readlink,
    .symlink,
    .link,
  ]
}

#endif  // swift(>=4.2)

/// OSType is the same as teleport.devicetrust.v1.OSType.
/// Duplicated because gogo doesn't play well with protoc-gen-go.
enum Events_OSType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// Linux.
  case linux // = 1

  /// macOS.
  case macos // = 2

  /// Windows.
  case windows // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .linux
    case 2: self = .macos
    case 3: self = .windows
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .linux: return 1
    case .macos: return 2
    case .windows: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Events_OSType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Events_OSType] = [
    .unspecified,
    .linux,
    .macos,
    .windows,
  ]
}

#endif  // swift(>=4.2)

/// DeviceOrigin is the same as teleport.devicetrust.v1.DeviceOrigin.
/// Duplicated because gogo doesn't play well with protoc-gen-go.
enum Events_DeviceOrigin: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Unspecified or absent origin.
  case unspecified // = 0

  /// Devices originated from direct API usage.
  case api // = 1

  /// Devices originated from Jamf sync.
  case jamf // = 2

  /// Source originated from Microsoft Intune sync.
  case intune // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .api
    case 2: self = .jamf
    case 3: self = .intune
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .api: return 1
    case .jamf: return 2
    case .intune: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Events_DeviceOrigin: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Events_DeviceOrigin] = [
    .unspecified,
    .api,
    .jamf,
    .intune,
  ]
}

#endif  // swift(>=4.2)

/// ElasticsearchCategory specifies Elasticsearch request category.
enum Events_ElasticsearchCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// ELASTICSEARCH_CATEGORY_GENERAL is for otherwise uncategorized calls.
  case general // = 0

  /// ELASTICSEARCH_CATEGORY_SECURITY is for _security and _ssl APIs.
  case security // = 1

  /// ELASTICSEARCH_CATEGORY_SEARCH is for search-related APIs.
  case search // = 2

  /// ELASTICSEARCH_CATEGORY_SQL covers _sql API.
  case sql // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .general
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .general
    case 1: self = .security
    case 2: self = .search
    case 3: self = .sql
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .general: return 0
    case .security: return 1
    case .search: return 2
    case .sql: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Events_ElasticsearchCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Events_ElasticsearchCategory] = [
    .general,
    .security,
    .search,
    .sql,
  ]
}

#endif  // swift(>=4.2)

/// OpenSearchCategory specifies OpenSearch request category.
enum Events_OpenSearchCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// OPEN_SEARCH_CATEGORY_GENERAL is for otherwise uncategorized calls.
  case general // = 0

  /// OPEN_SEARCH_CATEGORY_SECURITY covers /_plugins/_security API.
  case security // = 1

  /// OPEN_SEARCH_CATEGORY_SEARCH is for search-related APIs.
  case search // = 2

  /// OPEN_SEARCH_CATEGORY_SQL covers /_plugins/_sql and /_plugins/_ppl API.
  case sql // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .general
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .general
    case 1: self = .security
    case 2: self = .search
    case 3: self = .sql
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .general: return 0
    case .security: return 1
    case .search: return 2
    case .sql: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Events_OpenSearchCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Events_OpenSearchCategory] = [
    .general,
    .security,
    .search,
    .sql,
  ]
}

#endif  // swift(>=4.2)

/// Metadata is a common event metadata
struct Events_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index is a monotonically incremented index in the event sequence
  var index: Int64 = 0

  /// Type is the event type
  var type: String = String()

  /// ID is a unique event identifier
  var id: String = String()

  /// Code is a unique event code
  var code: String = String()

  /// Time is event time
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// ClusterName identifies the originating teleport cluster
  var clusterName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// SessionMetadata is a common session event metadata
struct Events_SessionMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is a unique UUID of the session.
  var sessionID: String = String()

  /// WithMFA is a UUID of an MFA device used to start this session.
  var withMfa: String = String()

  /// PrivateKeyPolicy is the private key policy of the private key used to start this session.
  var privateKeyPolicy: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UserMetadata is a common user event metadata
struct Events_UserMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User is teleport user name
  var user: String = String()

  /// Login is OS login
  var login: String = String()

  /// Impersonator is a user acting on behalf of another user
  var impersonator: String = String()

  /// AWSRoleARN is AWS IAM role user assumes when accessing AWS console.
  var awsroleArn: String = String()

  /// AccessRequests are the IDs of access requests created by the user
  var accessRequests: [String] = []

  /// AzureIdentity is the Azure identity user assumes when accessing Azure API.
  var azureIdentity: String = String()

  /// GCPServiceAccount is the GCP service account user assumes when accessing GCP API.
  var gcpserviceAccount: String = String()

  /// TrustedDevice contains information about the users' trusted device.
  /// Requires a registered and enrolled device to be used during authentication.
  var trustedDevice: Events_DeviceMetadata {
    get {return _trustedDevice ?? Events_DeviceMetadata()}
    set {_trustedDevice = newValue}
  }
  /// Returns true if `trustedDevice` has been explicitly set.
  var hasTrustedDevice: Bool {return self._trustedDevice != nil}
  /// Clears the value of `trustedDevice`. Subsequent reads from it will return its default value.
  mutating func clearTrustedDevice() {self._trustedDevice = nil}

  /// RequiredPrivateKeyPolicy is the private key policy enforced for this login.
  var requiredPrivateKeyPolicy: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _trustedDevice: Events_DeviceMetadata? = nil
}

/// Server is a server metadata
struct Events_ServerMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ServerNamespace is a namespace of the server event
  var serverNamespace: String = String()

  /// ServerID is the UUID of the server the session occurred on.
  var serverID: String = String()

  /// ServerHostname is the hostname of the server the session occurred on.
  var serverHostname: String = String()

  /// ServerAddr is the address of the server the session occurred on.
  var serverAddr: String = String()

  /// ServerLabels are the labels (static and dynamic) of the server the
  /// session occurred on.
  var serverLabels: Dictionary<String,String> = [:]

  /// ForwardedBy tells us if the metadata was sent by the node itself or by another node in it's
  /// place. We can't verify emit permissions fully for these events so care should be taken with
  /// them.
  var forwardedBy: String = String()

  /// ServerSubKind is the sub kind of the server the session occurred on.
  var serverSubKind: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Connection contains connection info
struct Events_ConnectionMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// LocalAddr is a target address on the host
  var localAddr: String = String()

  /// RemoteAddr is a client (user's) address
  var remoteAddr: String = String()

  /// Protocol specifies protocol that was captured
  var `protocol`: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ClientMetadata identifies the originating client for an event.
struct Events_ClientMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UserAgent identifies the type of client that attempted the event.
  var userAgent: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// KubernetesClusterMetadata contains common metadata for kubernetes-related
/// events.
struct Events_KubernetesClusterMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// KubernetesCluster is a kubernetes cluster name.
  var kubernetesCluster: String = String()

  /// KubernetesUsers is a list of kubernetes usernames for the user.
  var kubernetesUsers: [String] = []

  /// KubernetesGroups is a list of kubernetes groups for the user.
  var kubernetesGroups: [String] = []

  /// KubernetesLabels are the labels (static and dynamic) of the kubernetes cluster the
  /// session occurred on.
  var kubernetesLabels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// KubernetesPodMetadata contains common metadata for kubernetes pod-related
/// events.
struct Events_KubernetesPodMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// KubernetesPodName is the name of the pod.
  var kubernetesPodName: String = String()

  /// KubernetesPodNamespace is the namespace of the pod.
  var kubernetesPodNamespace: String = String()

  /// KubernetesContainerName is the name of the container within the pod.
  var kubernetesContainerName: String = String()

  /// KubernetesContainerImage is the image of the container within the pod.
  var kubernetesContainerImage: String = String()

  /// KubernetesNodeName is the node that runs the pod.
  var kubernetesNodeName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SAMLIdPServiceProviderMetadata contains common metadata for SAML IdP service provider
/// events.
struct Events_SAMLIdPServiceProviderMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ServiceProviderEntityID is the entity ID of the service provider.
  var serviceProviderEntityID: String = String()

  /// ServiceProviderShortcut is the shortcut name of a service provider.
  var serviceProviderShortcut: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OktaResourcesUpdatedMetadata contains common metadata for Okta resources updated events.
struct Events_OktaResourcesUpdatedMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Added is the number of resources added.
  var added: Int32 = 0

  /// Updated is the number of resources updated.
  var updated: Int32 = 0

  /// Deleted is the number of resources deleted.
  var deleted: Int32 = 0

  /// AddedResources is a list of the actual resources that were added.
  var addedResources: [Events_OktaResource] = []

  /// UpdatedResources is a list of the actual resources that were updated.
  var updatedResources: [Events_OktaResource] = []

  /// DeletedResources is a list of the actual resources that were deleted.
  var deletedResources: [Events_OktaResource] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OktaResource is a descriptor of an Okta resource.
struct Events_OktaResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the identifier of the Okta resource.
  var id: String = String()

  /// Description is the description of the Okta resource.
  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OktaAssignmentMetadata contains common metadata for Okta assignment events.
struct Events_OktaAssignmentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Source is the source of the Okta assignment.
  var source: String = String()

  /// User is the user the Okta assignment is for.
  var user: String = String()

  /// StartingStatus is the starting status of the assignment.
  var startingStatus: String = String()

  /// EndingStatus is the ending status of the assignment.
  var endingStatus: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessListMemberMetadata contains common metadata for access list member resource events.
struct Events_AccessListMemberMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AccessListName is the name of the access list the members are being added to or removed from.
  var accessListName: String = String()

  /// Members are all members affected by the access list membership change.
  var members: [Events_AccessListMember] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessListMember is metadata surrounding an individual access list member.
struct Events_AccessListMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// JoinedOn is the date that the member joined.
  var joinedOn: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _joinedOn ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_joinedOn = newValue}
  }
  /// Returns true if `joinedOn` has been explicitly set.
  var hasJoinedOn: Bool {return self._joinedOn != nil}
  /// Clears the value of `joinedOn`. Subsequent reads from it will return its default value.
  mutating func clearJoinedOn() {self._joinedOn = nil}

  /// RemovedOn is the date that the access list member was removed. Will only be populated for deletion.
  var removedOn: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _removedOn ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_removedOn = newValue}
  }
  /// Returns true if `removedOn` has been explicitly set.
  var hasRemovedOn: Bool {return self._removedOn != nil}
  /// Clears the value of `removedOn`. Subsequent reads from it will return its default value.
  mutating func clearRemovedOn() {self._removedOn = nil}

  /// Reason is the reason that the member was added, modified, or removed.
  var reason: String = String()

  /// MemberName is the name of the member.
  var memberName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _joinedOn: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _removedOn: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// AccessListReviewMembershipRequirementsChanged contains information for when membership requirements change as part of a review.
struct Events_AccessListReviewMembershipRequirementsChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roles are the roles that changed as part of a review.
  var roles: [String] = []

  /// Traits are the traits that changed as part of a review.
  var traits: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessListReviewMetadata contains metadata for access list review events.
struct Events_AccessListReviewMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Message is the message that was supplied during the review.
  var message: String = String()

  /// ReviewID is the ID of the review.
  var reviewID: String = String()

  /// MembershipRequirementsChanged is populated if the memrship requirements have changed..
  var membershipRequirementsChanged: Events_AccessListReviewMembershipRequirementsChanged {
    get {return _membershipRequirementsChanged ?? Events_AccessListReviewMembershipRequirementsChanged()}
    set {_membershipRequirementsChanged = newValue}
  }
  /// Returns true if `membershipRequirementsChanged` has been explicitly set.
  var hasMembershipRequirementsChanged: Bool {return self._membershipRequirementsChanged != nil}
  /// Clears the value of `membershipRequirementsChanged`. Subsequent reads from it will return its default value.
  mutating func clearMembershipRequirementsChanged() {self._membershipRequirementsChanged = nil}

  /// ReviewFrequencyChanged is populated if the review frequency has changed.
  var reviewFrequencyChanged: String = String()

  /// ReviewDayOfMonthChanged is populated if the review day of month has changed.
  var reviewDayOfMonthChanged: String = String()

  /// RemovedMembers are the members that were removed as part of the review.
  var removedMembers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _membershipRequirementsChanged: Events_AccessListReviewMembershipRequirementsChanged? = nil
}

/// SessionStart is a session start event
struct Events_SessionStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// TerminalSize is expressed as 'W:H'
  var terminalSize: String {
    get {return _storage._terminalSize}
    set {_uniqueStorage()._terminalSize = newValue}
  }

  /// KubernetesCluster has information about a kubernetes cluster, if
  /// applicable.
  var kubernetesCluster: Events_KubernetesClusterMetadata {
    get {return _storage._kubernetesCluster ?? Events_KubernetesClusterMetadata()}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }
  /// Returns true if `kubernetesCluster` has been explicitly set.
  var hasKubernetesCluster: Bool {return _storage._kubernetesCluster != nil}
  /// Clears the value of `kubernetesCluster`. Subsequent reads from it will return its default value.
  mutating func clearKubernetesCluster() {_uniqueStorage()._kubernetesCluster = nil}

  /// KubernetesPod has information about a kubernetes pod, if applicable.
  var kubernetesPod: Events_KubernetesPodMetadata {
    get {return _storage._kubernetesPod ?? Events_KubernetesPodMetadata()}
    set {_uniqueStorage()._kubernetesPod = newValue}
  }
  /// Returns true if `kubernetesPod` has been explicitly set.
  var hasKubernetesPod: Bool {return _storage._kubernetesPod != nil}
  /// Clears the value of `kubernetesPod`. Subsequent reads from it will return its default value.
  mutating func clearKubernetesPod() {_uniqueStorage()._kubernetesPod = nil}

  /// InitialCommand is the command used to start this session.
  var initialCommand: [String] {
    get {return _storage._initialCommand}
    set {_uniqueStorage()._initialCommand = newValue}
  }

  /// SessionRecording is the type of session recording.
  var sessionRecording: String {
    get {return _storage._sessionRecording}
    set {_uniqueStorage()._sessionRecording = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionJoin emitted when another user joins a session
struct Events_SessionJoin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// KubernetesCluster has information about a kubernetes cluster, if
  /// applicable.
  var kubernetesCluster: Events_KubernetesClusterMetadata {
    get {return _storage._kubernetesCluster ?? Events_KubernetesClusterMetadata()}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }
  /// Returns true if `kubernetesCluster` has been explicitly set.
  var hasKubernetesCluster: Bool {return _storage._kubernetesCluster != nil}
  /// Clears the value of `kubernetesCluster`. Subsequent reads from it will return its default value.
  mutating func clearKubernetesCluster() {_uniqueStorage()._kubernetesCluster = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionPrint event happens every time a write occurs to
/// terminal I/O during a session
struct Events_SessionPrint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// ChunkIndex is a monotonically incremented index for ordering print events
  var chunkIndex: Int64 = 0

  /// Data is data transferred, it is not marshaled to JSON format
  var data: Data = Data()

  /// Bytes says how many bytes have been written into the session
  /// during "print" event
  var bytes: Int64 = 0

  /// DelayMilliseconds is the delay in milliseconds from the start of the session
  var delayMilliseconds: Int64 = 0

  /// Offset is the offset in bytes in the session file
  var offset: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
}

/// DesktopRecording happens when a Teleport Desktop Protocol message
/// is captured during a Desktop Access Session.
struct Events_DesktopRecording {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Message is the encoded TDP message.
  var message: Data = Data()

  /// DelayMilliseconds is the delay in milliseconds from the start of the session
  var delayMilliseconds: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
}

/// DesktopClipboardReceive is emitted when Teleport receives
/// clipboard data from a remote desktop.
struct Events_DesktopClipboardReceive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Session is common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Connection holds information about the connection.
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// DesktopAddr is the address of the desktop being accessed.
  var desktopAddr: String {
    get {return _storage._desktopAddr}
    set {_uniqueStorage()._desktopAddr = newValue}
  }

  /// Length is the number of bytes of data received from the remote clipboard.
  var length: Int32 {
    get {return _storage._length}
    set {_uniqueStorage()._length = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DesktopClipboardSend is emitted when clipboard data is
/// sent from a user's workstation to Teleport.
struct Events_DesktopClipboardSend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Session is common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Connection holds information about the connection.
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// DesktopAddr is the address of the desktop being accessed.
  var desktopAddr: String {
    get {return _storage._desktopAddr}
    set {_uniqueStorage()._desktopAddr = newValue}
  }

  /// Length is the number of bytes of data sent.
  var length: Int32 {
    get {return _storage._length}
    set {_uniqueStorage()._length = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DesktopSharedDirectoryStart is emitted when Teleport
/// successfully begins sharing a new directory to a remote desktop.
struct Events_DesktopSharedDirectoryStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Session is common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Connection holds information about the connection.
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// Status indicates whether the directory sharing initialization was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// DesktopAddr is the address of the desktop being accessed.
  var desktopAddr: String {
    get {return _storage._desktopAddr}
    set {_uniqueStorage()._desktopAddr = newValue}
  }

  /// DirectoryName is the name of the directory being shared.
  var directoryName: String {
    get {return _storage._directoryName}
    set {_uniqueStorage()._directoryName = newValue}
  }

  /// DirectoryID is the ID of the directory being shared (unique to the Windows Desktop Session).
  var directoryID: UInt32 {
    get {return _storage._directoryID}
    set {_uniqueStorage()._directoryID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DesktopSharedDirectoryRead is emitted when Teleport
/// attempts to read from a file in a shared directory at
/// the behest of the remote desktop.
struct Events_DesktopSharedDirectoryRead {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Session is common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Connection holds information about the connection.
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// Status indicates whether the read was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// DesktopAddr is the address of the desktop being accessed.
  var desktopAddr: String {
    get {return _storage._desktopAddr}
    set {_uniqueStorage()._desktopAddr = newValue}
  }

  /// DirectoryName is the name of the directory being shared.
  var directoryName: String {
    get {return _storage._directoryName}
    set {_uniqueStorage()._directoryName = newValue}
  }

  /// DirectoryID is the ID of the directory being shared (unique to the Windows Desktop Session).
  var directoryID: UInt32 {
    get {return _storage._directoryID}
    set {_uniqueStorage()._directoryID = newValue}
  }

  /// Path is the path within the shared directory where the file is located.
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// Length is the number of bytes read.
  var length: UInt32 {
    get {return _storage._length}
    set {_uniqueStorage()._length = newValue}
  }

  /// Offset is the offset the bytes were read from.
  var offset: UInt64 {
    get {return _storage._offset}
    set {_uniqueStorage()._offset = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DesktopSharedDirectoryWrite is emitted when Teleport
/// attempts to write to a file in a shared directory at
/// the behest of the remote desktop.
struct Events_DesktopSharedDirectoryWrite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Session is common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Connection holds information about the connection.
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// Status indicates whether the write was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// DesktopAddr is the address of the desktop being accessed.
  var desktopAddr: String {
    get {return _storage._desktopAddr}
    set {_uniqueStorage()._desktopAddr = newValue}
  }

  /// DirectoryName is the name of the directory being shared.
  var directoryName: String {
    get {return _storage._directoryName}
    set {_uniqueStorage()._directoryName = newValue}
  }

  /// DirectoryID is the ID of the directory being shared (unique to the Windows Desktop Session).
  var directoryID: UInt32 {
    get {return _storage._directoryID}
    set {_uniqueStorage()._directoryID = newValue}
  }

  /// Path is the path within the shared directory where the file is located.
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// Length is the number of bytes written.
  var length: UInt32 {
    get {return _storage._length}
    set {_uniqueStorage()._length = newValue}
  }

  /// Offset is the offset the bytes were written to.
  var offset: UInt64 {
    get {return _storage._offset}
    set {_uniqueStorage()._offset = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionReject event happens when a user hits a session control restriction.
struct Events_SessionReject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// Reason is a field that specifies reason for event, e.g. in disconnect
  /// event it explains why server disconnected the client
  var reason: String {
    get {return _storage._reason}
    set {_uniqueStorage()._reason = newValue}
  }

  /// Maximum is an event field specifying a maximal value (e.g. the value
  /// of `max_connections` for a `session.rejected` event).
  var maximum: Int64 {
    get {return _storage._maximum}
    set {_uniqueStorage()._maximum = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionConnect is emitted when a non-Teleport connection is made over net.Dial.
struct Events_SessionConnect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// FileTransferRequestEvent happens when a FileTransferRequest is created, updated, approved, or denied.
struct Events_FileTransferRequestEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _session ?? Events_SessionMetadata()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  /// RequestID is the ID for the FileTransferRequest
  var requestID: String = String()

  /// Approvers is a slice containing the Teleport users who have approved the request
  var approvers: [String] = []

  /// Requester is the Teleport user who requested the file transfer
  var requester: String = String()

  /// Location is the location of the file to be downloaded, or the directory of the upload
  var location: String = String()

  /// Download is true if the requested file transfer is a download, false if an upload
  var download: Bool = false

  /// Filename is the name of the file to be uploaded to the Location. Only present in uploads.
  var filename: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _session: Events_SessionMetadata? = nil
}

/// Resize means that some user resized PTY on the client
struct Events_Resize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// TerminalSize is expressed as 'W:H'
  var terminalSize: String {
    get {return _storage._terminalSize}
    set {_uniqueStorage()._terminalSize = newValue}
  }

  /// KubernetesCluster has information about a kubernetes cluster, if
  /// applicable.
  var kubernetesCluster: Events_KubernetesClusterMetadata {
    get {return _storage._kubernetesCluster ?? Events_KubernetesClusterMetadata()}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }
  /// Returns true if `kubernetesCluster` has been explicitly set.
  var hasKubernetesCluster: Bool {return _storage._kubernetesCluster != nil}
  /// Clears the value of `kubernetesCluster`. Subsequent reads from it will return its default value.
  mutating func clearKubernetesCluster() {_uniqueStorage()._kubernetesCluster = nil}

  /// KubernetesPod has information about a kubernetes pod, if applicable.
  var kubernetesPod: Events_KubernetesPodMetadata {
    get {return _storage._kubernetesPod ?? Events_KubernetesPodMetadata()}
    set {_uniqueStorage()._kubernetesPod = newValue}
  }
  /// Returns true if `kubernetesPod` has been explicitly set.
  var hasKubernetesPod: Bool {return _storage._kubernetesPod != nil}
  /// Clears the value of `kubernetesPod`. Subsequent reads from it will return its default value.
  mutating func clearKubernetesPod() {_uniqueStorage()._kubernetesPod = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionEnd is a session end event
struct Events_SessionEnd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// EnhancedRecording is used to indicate if the recording was an
  /// enhanced recording or not.
  var enhancedRecording: Bool {
    get {return _storage._enhancedRecording}
    set {_uniqueStorage()._enhancedRecording = newValue}
  }

  /// Interactive is used to indicate if the session was interactive
  /// (has PTY attached) or not (exec session).
  var interactive: Bool {
    get {return _storage._interactive}
    set {_uniqueStorage()._interactive = newValue}
  }

  /// Participants is a list of participants in the session.
  var participants: [String] {
    get {return _storage._participants}
    set {_uniqueStorage()._participants = newValue}
  }

  /// StartTime is the timestamp at which the session began.
  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// EndTime is the timestamp at which the session ended.
  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// KubernetesCluster has information about a kubernetes cluster, if
  /// applicable.
  var kubernetesCluster: Events_KubernetesClusterMetadata {
    get {return _storage._kubernetesCluster ?? Events_KubernetesClusterMetadata()}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }
  /// Returns true if `kubernetesCluster` has been explicitly set.
  var hasKubernetesCluster: Bool {return _storage._kubernetesCluster != nil}
  /// Clears the value of `kubernetesCluster`. Subsequent reads from it will return its default value.
  mutating func clearKubernetesCluster() {_uniqueStorage()._kubernetesCluster = nil}

  /// KubernetesPod has information about a kubernetes pod, if applicable.
  var kubernetesPod: Events_KubernetesPodMetadata {
    get {return _storage._kubernetesPod ?? Events_KubernetesPodMetadata()}
    set {_uniqueStorage()._kubernetesPod = newValue}
  }
  /// Returns true if `kubernetesPod` has been explicitly set.
  var hasKubernetesPod: Bool {return _storage._kubernetesPod != nil}
  /// Clears the value of `kubernetesPod`. Subsequent reads from it will return its default value.
  mutating func clearKubernetesPod() {_uniqueStorage()._kubernetesPod = nil}

  /// InitialCommand is the command used to start this session.
  var initialCommand: [String] {
    get {return _storage._initialCommand}
    set {_uniqueStorage()._initialCommand = newValue}
  }

  /// SessionRecording is the type of session recording.
  var sessionRecording: String {
    get {return _storage._sessionRecording}
    set {_uniqueStorage()._sessionRecording = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BPFMetadata is a common BPF process metadata
struct Events_BPFMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PID is the ID of the process.
  var pid: UInt64 = 0

  /// CgroupID is the internal cgroupv2 ID of the event.
  var cgroupID: UInt64 = 0

  /// Program is name of the executable.
  var program: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Status contains common command or operation status fields
struct Events_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success indicates the success or failure of the operation
  var success: Bool = false

  /// Error includes system error message for the failed attempt
  var error: String = String()

  /// UserMessage is a user-friendly message for successfull or unsuccessfull auth attempt
  var userMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SessionCommand is a session command event
struct Events_SessionCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// BPFMetadata is a common BPF subsystem metadata
  var bpf: Events_BPFMetadata {
    get {return _storage._bpf ?? Events_BPFMetadata()}
    set {_uniqueStorage()._bpf = newValue}
  }
  /// Returns true if `bpf` has been explicitly set.
  var hasBpf: Bool {return _storage._bpf != nil}
  /// Clears the value of `bpf`. Subsequent reads from it will return its default value.
  mutating func clearBpf() {_uniqueStorage()._bpf = nil}

  /// PPID is the PID of the parent process.
  var ppid: UInt64 {
    get {return _storage._ppid}
    set {_uniqueStorage()._ppid = newValue}
  }

  /// Path is the full path to the executable.
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// Argv is the list of arguments to the program. Note, the first element does
  /// not contain the name of the process.
  var argv: [String] {
    get {return _storage._argv}
    set {_uniqueStorage()._argv = newValue}
  }

  /// ReturnCode is the return code of execve.
  var returnCode: Int32 {
    get {return _storage._returnCode}
    set {_uniqueStorage()._returnCode = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionDisk is a session disk access event
struct Events_SessionDisk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// BPFMetadata is a common BPF subsystem metadata
  var bpf: Events_BPFMetadata {
    get {return _storage._bpf ?? Events_BPFMetadata()}
    set {_uniqueStorage()._bpf = newValue}
  }
  /// Returns true if `bpf` has been explicitly set.
  var hasBpf: Bool {return _storage._bpf != nil}
  /// Clears the value of `bpf`. Subsequent reads from it will return its default value.
  mutating func clearBpf() {_uniqueStorage()._bpf = nil}

  /// Path is the full path to the executable.
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// Flags are the flags passed to open.
  var flags: Int32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  /// ReturnCode is the return code of disk open
  var returnCode: Int32 {
    get {return _storage._returnCode}
    set {_uniqueStorage()._returnCode = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionNetwork is a network event
struct Events_SessionNetwork {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// BPFMetadata is a common BPF subsystem metadata
  var bpf: Events_BPFMetadata {
    get {return _storage._bpf ?? Events_BPFMetadata()}
    set {_uniqueStorage()._bpf = newValue}
  }
  /// Returns true if `bpf` has been explicitly set.
  var hasBpf: Bool {return _storage._bpf != nil}
  /// Clears the value of `bpf`. Subsequent reads from it will return its default value.
  mutating func clearBpf() {_uniqueStorage()._bpf = nil}

  /// SrcAddr is the source IP address of the connection.
  var srcAddr: String {
    get {return _storage._srcAddr}
    set {_uniqueStorage()._srcAddr = newValue}
  }

  /// DstAddr is the destination IP address of the connection.
  var dstAddr: String {
    get {return _storage._dstAddr}
    set {_uniqueStorage()._dstAddr = newValue}
  }

  /// DstPort is the destination port of the connection.
  var dstPort: Int32 {
    get {return _storage._dstPort}
    set {_uniqueStorage()._dstPort = newValue}
  }

  /// TCPVersion is the version of TCP (4 or 6).
  var tcpversion: Int32 {
    get {return _storage._tcpversion}
    set {_uniqueStorage()._tcpversion = newValue}
  }

  /// Operation denotes what network operation was performed (e.g. connect)
  var operation: Events_SessionNetwork.NetworkOperation {
    get {return _storage._operation}
    set {_uniqueStorage()._operation = newValue}
  }

  /// Action denotes what happened in response to the event
  var action: Events_EventAction {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Operation is the network operation that was performed or attempted
  enum NetworkOperation: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// TCP connection establishment or binding a UDP socket to a remote address
    case connect // = 0

    /// Transmission of data to a remote endpoint
    case send // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .connect
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .connect
      case 1: self = .send
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .connect: return 0
      case .send: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Events_SessionNetwork.NetworkOperation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Events_SessionNetwork.NetworkOperation] = [
    .connect,
    .send,
  ]
}

#endif  // swift(>=4.2)

/// SessionData is emitted to report session data usage.
struct Events_SessionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// BytesTransmitted is the amount of bytes transmitted
  var bytesTransmitted: UInt64 {
    get {return _storage._bytesTransmitted}
    set {_uniqueStorage()._bytesTransmitted = newValue}
  }

  /// BytesReceived is the amount of bytes received
  var bytesReceived: UInt64 {
    get {return _storage._bytesReceived}
    set {_uniqueStorage()._bytesReceived = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionLeave is emitted to report that a user left the session
struct Events_SessionLeave {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// UserLogin records a successfully or failed user login event
struct Events_UserLogin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Status contains common command or operation status fields
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Method is the event field indicating how the login was performed
  var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  /// IdentityAttributes is a map of user attributes received from identity provider
  var identityAttributes: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._identityAttributes ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._identityAttributes = newValue}
  }
  /// Returns true if `identityAttributes` has been explicitly set.
  var hasIdentityAttributes: Bool {return _storage._identityAttributes != nil}
  /// Clears the value of `identityAttributes`. Subsequent reads from it will return its default value.
  mutating func clearIdentityAttributes() {_uniqueStorage()._identityAttributes = nil}

  /// MFA is the MFA device used during the login.
  var mfadevice: Events_MFADeviceMetadata {
    get {return _storage._mfadevice ?? Events_MFADeviceMetadata()}
    set {_uniqueStorage()._mfadevice = newValue}
  }
  /// Returns true if `mfadevice` has been explicitly set.
  var hasMfadevice: Bool {return _storage._mfadevice != nil}
  /// Clears the value of `mfadevice`. Subsequent reads from it will return its default value.
  mutating func clearMfadevice() {_uniqueStorage()._mfadevice = nil}

  /// Client is the common client event metadata
  var client: Events_ClientMetadata {
    get {return _storage._client ?? Events_ClientMetadata()}
    set {_uniqueStorage()._client = newValue}
  }
  /// Returns true if `client` has been explicitly set.
  var hasClient: Bool {return _storage._client != nil}
  /// Clears the value of `client`. Subsequent reads from it will return its default value.
  mutating func clearClient() {_uniqueStorage()._client = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// AppliedLoginRules stores the name of each login rule that was applied
  /// during the login.
  var appliedLoginRules: [String] {
    get {return _storage._appliedLoginRules}
    set {_uniqueStorage()._appliedLoginRules = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ResourceMetadata is a common resource metadata
struct Events_ResourceMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ResourceName is a resource name
  var name: String = String()

  /// Expires is set if resource expires
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// UpdatedBy if set indicates the user who modified the resource
  var updatedBy: String = String()

  /// TTL is a TTL of reset password token represented as duration, e.g. "10m"
  /// used for compatibility purposes for some events, Expires should be used instead
  /// as it's more useful (contains exact expiration date/time)
  var ttl: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// UserCreate is emitted when the user is created or upserted.
struct Events_UserCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// Roles is a list of roles for the user.
  var roles: [String] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  /// Connector is the connector used to create the user.
  var connector: String {
    get {return _storage._connector}
    set {_uniqueStorage()._connector = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// UserUpdate is emitted when the user is updated.
struct Events_UserUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// Roles is a list of roles for the user.
  var roles: [String] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  /// Connector is the connector used to create the user.
  var connector: String {
    get {return _storage._connector}
    set {_uniqueStorage()._connector = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// UserDelete is emitted when a user gets deleted
struct Events_UserDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// UserPasswordChange is emitted when the user changes their own password.
struct Events_UserPasswordChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AccessRequestCreate is emitted when access request has been created or updated
struct Events_AccessRequestCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// Roles is a list of roles for the user.
  var roles: [String] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  /// RequestID is access request ID
  var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// RequestState is access request state (in the access_request.review variant of
  /// the event this represents the post-review state of the request).
  var requestState: String {
    get {return _storage._requestState}
    set {_uniqueStorage()._requestState = newValue}
  }

  /// Delegator is used by teleport plugins to indicate the identity
  /// which caused them to update state.
  var delegator: String {
    get {return _storage._delegator}
    set {_uniqueStorage()._delegator = newValue}
  }

  /// Reason is an optional description of why the request is being
  /// created or updated.
  var reason: String {
    get {return _storage._reason}
    set {_uniqueStorage()._reason = newValue}
  }

  /// Annotations is an optional set of attributes supplied by a plugin during
  /// approval/denial of the request.
  var annotations: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._annotations ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._annotations = newValue}
  }
  /// Returns true if `annotations` has been explicitly set.
  var hasAnnotations: Bool {return _storage._annotations != nil}
  /// Clears the value of `annotations`. Subsequent reads from it will return its default value.
  mutating func clearAnnotations() {_uniqueStorage()._annotations = nil}

  /// Reviewer is the author of the review (only used in the access_request.review event variant).
  var reviewer: String {
    get {return _storage._reviewer}
    set {_uniqueStorage()._reviewer = newValue}
  }

  /// ProposedState is the state proposed by a review (only used in the access_request.review event
  /// variant).
  var proposedState: String {
    get {return _storage._proposedState}
    set {_uniqueStorage()._proposedState = newValue}
  }

  /// RequestedResourceIDs is the set of resources to which access is being requested.
  var requestedResourceIds: [Events_ResourceID] {
    get {return _storage._requestedResourceIds}
    set {_uniqueStorage()._requestedResourceIds = newValue}
  }

  /// MaxDuration indicates how long the access should be granted for.
  var maxDuration: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._maxDuration ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._maxDuration = newValue}
  }
  /// Returns true if `maxDuration` has been explicitly set.
  var hasMaxDuration: Bool {return _storage._maxDuration != nil}
  /// Clears the value of `maxDuration`. Subsequent reads from it will return its default value.
  mutating func clearMaxDuration() {_uniqueStorage()._maxDuration = nil}

  /// PromotedAccessListName is the name of the access list that this request
  /// was promoted to.
  /// This field is only populated when the request is in the PROMOTED state.
  var promotedAccessListName: String {
    get {return _storage._promotedAccessListName}
    set {_uniqueStorage()._promotedAccessListName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ResourceID is a unique identifier for a teleport resource. This is duplicated
/// from api/types/types.proto to decouple the api and events types and because
/// neither file currently imports the other.
struct Events_ResourceID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusterName is the name of the cluster the resource is in.
  var clusterName: String = String()

  /// Kind is the resource kind.
  var kind: String = String()

  /// Name is the name of the specific resource.
  var name: String = String()

  /// SubResourceName is the resource belonging to resource identified by "Name"
  /// that the user is allowed to access to.
  /// When granting access to a subresource, access to other resources is limited.
  /// Currently it just supports resources of Kind=pod and the format is the following
  /// "<kube_namespace>/<kube_pod>".
  var subResourceName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestDelete is emitted when an access request has been deleted.
struct Events_AccessRequestDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// RequestID is access request ID
  var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PortForward is emitted when a user requests port forwarding.
struct Events_PortForward {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// Status contains operation success or failure status
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Addr is a target port forwarding address
  var addr: String {
    get {return _storage._addr}
    set {_uniqueStorage()._addr = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// X11Forward is emitted when a user requests X11 protocol forwarding
struct Events_X11Forward {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// Status contains operation success or failure status
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// CommandMetadata specifies common command fields
struct Events_CommandMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Command is the executed command name
  var command: String = String()

  /// ExitCode specifies command exit code
  var exitCode: String = String()

  /// Error is an optional exit error, set if command has failed
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Exec specifies command exec event
struct Events_Exec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// CommandMetadata is a common command metadata
  var command: Events_CommandMetadata {
    get {return _storage._command ?? Events_CommandMetadata()}
    set {_uniqueStorage()._command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return _storage._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {_uniqueStorage()._command = nil}

  /// KubernetesCluster has information about a kubernetes cluster, if
  /// applicable.
  var kubernetesCluster: Events_KubernetesClusterMetadata {
    get {return _storage._kubernetesCluster ?? Events_KubernetesClusterMetadata()}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }
  /// Returns true if `kubernetesCluster` has been explicitly set.
  var hasKubernetesCluster: Bool {return _storage._kubernetesCluster != nil}
  /// Clears the value of `kubernetesCluster`. Subsequent reads from it will return its default value.
  mutating func clearKubernetesCluster() {_uniqueStorage()._kubernetesCluster = nil}

  /// KubernetesPod has information about a kubernetes pod, if applicable.
  var kubernetesPod: Events_KubernetesPodMetadata {
    get {return _storage._kubernetesPod ?? Events_KubernetesPodMetadata()}
    set {_uniqueStorage()._kubernetesPod = newValue}
  }
  /// Returns true if `kubernetesPod` has been explicitly set.
  var hasKubernetesPod: Bool {return _storage._kubernetesPod != nil}
  /// Clears the value of `kubernetesPod`. Subsequent reads from it will return its default value.
  mutating func clearKubernetesPod() {_uniqueStorage()._kubernetesPod = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SCP is emitted when data transfer has occurred between server and client
struct Events_SCP {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// CommandMetadata is a common command metadata
  var command: Events_CommandMetadata {
    get {return _storage._command ?? Events_CommandMetadata()}
    set {_uniqueStorage()._command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return _storage._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {_uniqueStorage()._command = nil}

  /// Path is a copy path
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// Action is upload or download
  var action: String {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SFTPAttributes are file metadata sent over SFTP
struct Events_SFTPAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// FileSize is file size
  var fileSize: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _fileSize ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_fileSize = newValue}
  }
  /// Returns true if `fileSize` has been explicitly set.
  var hasFileSize: Bool {return self._fileSize != nil}
  /// Clears the value of `fileSize`. Subsequent reads from it will return its default value.
  mutating func clearFileSize() {self._fileSize = nil}

  /// UID is the user owner of a file
  var uid: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _uid ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  /// GID is the group owner of the file
  var gid: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _gid ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_gid = newValue}
  }
  /// Returns true if `gid` has been explicitly set.
  var hasGid: Bool {return self._gid != nil}
  /// Clears the value of `gid`. Subsequent reads from it will return its default value.
  mutating func clearGid() {self._gid = nil}

  /// Permissions is the file permissions
  var permissions: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _permissions ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_permissions = newValue}
  }
  /// Returns true if `permissions` has been explicitly set.
  var hasPermissions: Bool {return self._permissions != nil}
  /// Clears the value of `permissions`. Subsequent reads from it will return its default value.
  mutating func clearPermissions() {self._permissions = nil}

  /// AccessTime is when the file was last read
  var accessTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _accessTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_accessTime = newValue}
  }
  /// Returns true if `accessTime` has been explicitly set.
  var hasAccessTime: Bool {return self._accessTime != nil}
  /// Clears the value of `accessTime`. Subsequent reads from it will return its default value.
  mutating func clearAccessTime() {self._accessTime = nil}

  /// ModificationTime was when the file was last changed
  var modificationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _modificationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_modificationTime = newValue}
  }
  /// Returns true if `modificationTime` has been explicitly set.
  var hasModificationTime: Bool {return self._modificationTime != nil}
  /// Clears the value of `modificationTime`. Subsequent reads from it will return its default value.
  mutating func clearModificationTime() {self._modificationTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fileSize: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
  fileprivate var _uid: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _gid: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _permissions: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _accessTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _modificationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// SFTP is emitted when file operations have occurred between server and client
struct Events_SFTP {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// WorkingDirectory is the current directory the SFTP server is in
  var workingDirectory: String {
    get {return _storage._workingDirectory}
    set {_uniqueStorage()._workingDirectory = newValue}
  }

  /// Path is the filepath that was operated on. It is the exact path that
  /// was sent by the client, so it may be relative or absolute.
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// TargetPath is the new path in file renames, or the path of the symlink
  /// when creating symlinks. It is the exact path that wassent by the client,
  /// so it may be relative or absolute.
  var targetPath: String {
    get {return _storage._targetPath}
    set {_uniqueStorage()._targetPath = newValue}
  }

  /// Flags is options that were passed that affect file creation events
  var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  /// Attributes is file metadata that the user requested to be changed
  var attributes: Events_SFTPAttributes {
    get {return _storage._attributes ?? Events_SFTPAttributes()}
    set {_uniqueStorage()._attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  var hasAttributes: Bool {return _storage._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  mutating func clearAttributes() {_uniqueStorage()._attributes = nil}

  /// Action is what kind of file operation
  var action: Events_SFTPAction {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  /// Error is the optional error that may have occurred
  var error: String {
    get {return _storage._error}
    set {_uniqueStorage()._error = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Subsystem is emitted when a user requests a new subsystem.
struct Events_Subsystem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// Name is a subsystem name
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Error contains error in case of unsucessfull attempt
  var error: String {
    get {return _storage._error}
    set {_uniqueStorage()._error = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ClientDisconnect is emitted when client is disconnected
/// by the server due to inactivity or any other reason
struct Events_ClientDisconnect {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// Reason is a field that specifies reason for event, e.g. in disconnect
  /// event it explains why server disconnected the client
  var reason: String {
    get {return _storage._reason}
    set {_uniqueStorage()._reason = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AuthAttempt is emitted upon a failed or successfull authentication attempt.
struct Events_AuthAttempt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// Status contains common command or operation status fields
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// UserTokenCreate is emitted when a user token is created.
struct Events_UserTokenCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RoleCreate is emitted when a role is created/updated.
struct Events_RoleCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RoleUpdate is emitted when a role is updated.
struct Events_RoleUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RoleDelete is emitted when a role is deleted
struct Events_RoleDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TrustedClusterCreate is the event for creating a trusted cluster.
struct Events_TrustedClusterCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TrustedClusterDelete is the event for removing a trusted cluster.
struct Events_TrustedClusterDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ProvisionTokenCreate event is emitted when a provisioning token (a.k.a. join
/// token) of any role is created.
struct Events_ProvisionTokenCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var roles: [String] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  var joinMethod: String {
    get {return _storage._joinMethod}
    set {_uniqueStorage()._joinMethod = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TrustedClusterTokenCreate event is emitted (in addition to
/// ProvisionTokenCreate) when a token of a "Trusted_cluster" role is created.
///
/// Deprecated: redundant, since we also emit ProvisionTokenCreate.
struct Events_TrustedClusterTokenCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GithubConnectorCreate fires when a Github connector is created.
struct Events_GithubConnectorCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GithubConnectorUpdate fires when a Github connector is updated.
struct Events_GithubConnectorUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GithubConnectorDelete fires when a Github connector is deleted.
struct Events_GithubConnectorDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OIDCConnectorCreate fires when OIDC connector is created.
struct Events_OIDCConnectorCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OIDCConnectorUpdate fires when OIDC connector is updated.
struct Events_OIDCConnectorUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OIDCConnectorDelete fires when OIDC connector is deleted.
struct Events_OIDCConnectorDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SAMLConnectorCreate fires when SAML connector is created/updated.
struct Events_SAMLConnectorCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SAMLConnectorUpdate fires when SAML connector is updated.
struct Events_SAMLConnectorUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SAMLConnectorDelete fires when SAML connector is deleted.
struct Events_SAMLConnectorDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// KubeRequest specifies a Kubernetes API request event.
struct Events_KubeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// RequestPath is the raw request URL path.
  var requestPath: String {
    get {return _storage._requestPath}
    set {_uniqueStorage()._requestPath = newValue}
  }

  /// Verb is the HTTP verb used for this request (e.g. GET, POST, etc)
  var verb: String {
    get {return _storage._verb}
    set {_uniqueStorage()._verb = newValue}
  }

  /// ResourceAPIGroup is the resource API group.
  var resourceApigroup: String {
    get {return _storage._resourceApigroup}
    set {_uniqueStorage()._resourceApigroup = newValue}
  }

  /// ResourceNamespace is the resource namespace.
  var resourceNamespace: String {
    get {return _storage._resourceNamespace}
    set {_uniqueStorage()._resourceNamespace = newValue}
  }

  /// ResourceKind is the API resource kind (e.g. "pod", "service", etc).
  var resourceKind: String {
    get {return _storage._resourceKind}
    set {_uniqueStorage()._resourceKind = newValue}
  }

  /// ResourceName is the API resource name.
  var resourceName: String {
    get {return _storage._resourceName}
    set {_uniqueStorage()._resourceName = newValue}
  }

  /// ResponseCode is the HTTP response code for this request.
  var responseCode: Int32 {
    get {return _storage._responseCode}
    set {_uniqueStorage()._responseCode = newValue}
  }

  /// Kubernetes has information about a kubernetes cluster, if applicable.
  var kubernetes: Events_KubernetesClusterMetadata {
    get {return _storage._kubernetes ?? Events_KubernetesClusterMetadata()}
    set {_uniqueStorage()._kubernetes = newValue}
  }
  /// Returns true if `kubernetes` has been explicitly set.
  var hasKubernetes: Bool {return _storage._kubernetes != nil}
  /// Clears the value of `kubernetes`. Subsequent reads from it will return its default value.
  mutating func clearKubernetes() {_uniqueStorage()._kubernetes = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AppMetadata contains common application information.
struct Events_AppMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AppURI is the application endpoint.
  var appUri: String = String()

  /// AppPublicAddr is the configured application public address.
  var appPublicAddr: String = String()

  /// AppLabels are the configured application labels.
  var appLabels: Dictionary<String,String> = [:]

  /// AppName is the configured application name.
  var appName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AppCreate is emitted when a new application resource is created.
struct Events_AppCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata.
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// AppMetadata is a common application resource metadata.
  var app: Events_AppMetadata {
    get {return _storage._app ?? Events_AppMetadata()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  mutating func clearApp() {_uniqueStorage()._app = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AppUpdate is emitted when an existing application resource is updated.
struct Events_AppUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata.
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// AppMetadata is a common application resource metadata.
  var app: Events_AppMetadata {
    get {return _storage._app ?? Events_AppMetadata()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  mutating func clearApp() {_uniqueStorage()._app = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AppDelete is emitted when an application resource is deleted.
struct Events_AppDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata.
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AppSessionStart is emitted when a user is issued an application certificate.
struct Events_AppSessionStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// PublicAddr is the public address of the application being requested.
  /// DELETE IN 10.0: this information is also present on the AppMetadata.
  var publicAddr: String {
    get {return _storage._publicAddr}
    set {_uniqueStorage()._publicAddr = newValue}
  }

  /// App is a common application resource metadata.
  var app: Events_AppMetadata {
    get {return _storage._app ?? Events_AppMetadata()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  mutating func clearApp() {_uniqueStorage()._app = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AppSessionEnd is emitted when an application session ends.
struct Events_AppSessionEnd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// App is a common application resource metadata.
  var app: Events_AppMetadata {
    get {return _storage._app ?? Events_AppMetadata()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  mutating func clearApp() {_uniqueStorage()._app = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AppSessionChunk is emitted at the start of a 5 minute chunk on each
/// proxy. This chunk is used to buffer 5 minutes of audit events at a time
/// for applications.
struct Events_AppSessionChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// ServerMetadata is a common server metadata
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// ConnectionMetadata holds information about the connection
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// SessionChunkID is the ID of the session that was created for this 5 minute
  /// application log chunk.
  var sessionChunkID: String {
    get {return _storage._sessionChunkID}
    set {_uniqueStorage()._sessionChunkID = newValue}
  }

  /// App is a common application resource metadata.
  var app: Events_AppMetadata {
    get {return _storage._app ?? Events_AppMetadata()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  mutating func clearApp() {_uniqueStorage()._app = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AppSessionRequest is an HTTP request and response.
struct Events_AppSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// StatusCode the HTTP response code for the request.
  var statusCode: UInt32 {
    get {return _storage._statusCode}
    set {_uniqueStorage()._statusCode = newValue}
  }

  /// Path is relative path in the URL.
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// RawQuery are the encoded query values.
  var rawQuery: String {
    get {return _storage._rawQuery}
    set {_uniqueStorage()._rawQuery = newValue}
  }

  /// Method is the request HTTP method, like GET/POST/DELETE/etc.
  var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  /// App is a common application resource metadata.
  var app: Events_AppMetadata {
    get {return _storage._app ?? Events_AppMetadata()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  mutating func clearApp() {_uniqueStorage()._app = nil}

  /// AWS contains extra AWS metadata of the request.
  var aws: Events_AWSRequestMetadata {
    get {return _storage._aws ?? Events_AWSRequestMetadata()}
    set {_uniqueStorage()._aws = newValue}
  }
  /// Returns true if `aws` has been explicitly set.
  var hasAws: Bool {return _storage._aws != nil}
  /// Clears the value of `aws`. Subsequent reads from it will return its default value.
  mutating func clearAws() {_uniqueStorage()._aws = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AWSRequestMetadata contains extra AWS metadata of an AppSessionRequest.
struct Events_AWSRequestMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AWSRegion is the requested AWS region.
  var awsregion: String = String()

  /// AWSService is the requested AWS service name.
  var awsservice: String = String()

  /// AWSHost is the requested host of the AWS service.
  var awshost: String = String()

  /// AWSAssumedRole is the assumed role that signed this request.
  var awsassumedRole: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DatabaseMetadata contains common database information.
struct Events_DatabaseMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DatabaseService is the name of the database service proxying the database.
  var databaseService: String = String()

  /// DatabaseProtocol is the database type, e.g. postgres or mysql.
  var databaseProtocol: String = String()

  /// DatabaseURI is the database URI to connect to.
  var databaseUri: String = String()

  /// DatabaseName is the name of the database a user is connecting to.
  var databaseName: String = String()

  /// DatabaseUser is the database username used to connect.
  var databaseUser: String = String()

  /// DatabaseLabels is the database resource labels.
  var databaseLabels: Dictionary<String,String> = [:]

  /// DatabaseAWSRegion is AWS regions for AWS hosted databases.
  var databaseAwsregion: String = String()

  /// DatabaseAWSRegion is cluster ID for Redshift databases.
  var databaseAwsredshiftClusterID: String = String()

  /// DatabaseGCPProjectID is project ID for GCP hosted databases.
  var databaseGcpprojectID: String = String()

  /// DatabaseGCPInstanceID is instance ID for GCP hosted databases.
  var databaseGcpinstanceID: String = String()

  /// DatabaseRoles is a list of database roles for auto-provisioned users.
  var databaseRoles: [String] = []

  /// DatabaseType is the database type.
  var databaseType: String = String()

  /// DatabaseOrigin is the database origin source.
  var databaseOrigin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DatabaseCreate is emitted when a new database resource is created.
struct Events_DatabaseCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata.
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// DatabaseMetadata is a common database resource metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DatabaseUpdate is emitted when an existing database resource is updated.
struct Events_DatabaseUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata.
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// DatabaseMetadata is a common database resource metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DatabaseDelete is emitted when a database resource is deleted.
struct Events_DatabaseDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata.
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DatabaseSessionStart is emitted when a user connects to a database.
struct Events_DatabaseSessionStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Session is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Server is a common server metadata.
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// Connection holds information about the connection.
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// Status indicates whether the connection was successful or denied.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DatabaseSessionQuery is emitted when a user executes a database query.
struct Events_DatabaseSessionQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// DatabaseQuery is the executed query string.
  var databaseQuery: String {
    get {return _storage._databaseQuery}
    set {_uniqueStorage()._databaseQuery = newValue}
  }

  /// DatabaseQueryParameters are the query parameters for prepared statements.
  var databaseQueryParameters: [String] {
    get {return _storage._databaseQueryParameters}
    set {_uniqueStorage()._databaseQueryParameters = newValue}
  }

  /// Status indicates whether the query was successfully sent to the database.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PostgresParse is emitted when a Postgres client creates a prepared statement
/// using extended query protocol.
struct Events_PostgresParse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// StatementName is the prepared statement name.
  var statementName: String {
    get {return _storage._statementName}
    set {_uniqueStorage()._statementName = newValue}
  }

  /// Query is the prepared statement query.
  var query: String {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PostgresBind is emitted when a Postgres client readies a prepared statement
/// for execution and binds it to parameters.
struct Events_PostgresBind {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// StatementName is the name of prepared statement that's being bound to parameters.
  var statementName: String {
    get {return _storage._statementName}
    set {_uniqueStorage()._statementName = newValue}
  }

  /// PortalName is the destination portal name that binds statement to parameters.
  var portalName: String {
    get {return _storage._portalName}
    set {_uniqueStorage()._portalName = newValue}
  }

  /// Parameters are the query bind parameters.
  var parameters: [String] {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PostgresExecute is emitted when a Postgres client executes a previously
/// bound prepared statement.
struct Events_PostgresExecute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// PortalName is the name of destination portal that's being executed.
  var portalName: String {
    get {return _storage._portalName}
    set {_uniqueStorage()._portalName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PostgresClose is emitted when a Postgres client closes an existing prepared
/// statement.
struct Events_PostgresClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// StatementName is the name of prepared statement that's being closed.
  var statementName: String {
    get {return _storage._statementName}
    set {_uniqueStorage()._statementName = newValue}
  }

  /// PortalName is the name of destination portal that's being closed.
  var portalName: String {
    get {return _storage._portalName}
    set {_uniqueStorage()._portalName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// PostgresFunctionCall is emitted when a Postgres client calls internal
/// database function.
struct Events_PostgresFunctionCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// FunctionOID is the Postgres object ID of the called function.
  var functionOid: UInt32 {
    get {return _storage._functionOid}
    set {_uniqueStorage()._functionOid = newValue}
  }

  /// FunctionArgs contains formatted function arguments.
  var functionArgs: [String] {
    get {return _storage._functionArgs}
    set {_uniqueStorage()._functionArgs = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WindowsDesktopSessionStart is emitted when a user connects to a desktop.
struct Events_WindowsDesktopSessionStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Session is common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Connection holds information about the connection.
  var connection: Events_ConnectionMetadata {
    get {return _storage._connection ?? Events_ConnectionMetadata()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// Status indicates whether the connection was successful or denied.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// WindowsDesktopService is the name of the service proxying the RDP session.
  var windowsDesktopService: String {
    get {return _storage._windowsDesktopService}
    set {_uniqueStorage()._windowsDesktopService = newValue}
  }

  /// DesktopAddr is the address of the desktop being accessed.
  var desktopAddr: String {
    get {return _storage._desktopAddr}
    set {_uniqueStorage()._desktopAddr = newValue}
  }

  /// Domain is the Active Directory domain of the desktop being accessed.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// WindowsUser is the Windows username used to connect.
  var windowsUser: String {
    get {return _storage._windowsUser}
    set {_uniqueStorage()._windowsUser = newValue}
  }

  /// DesktopLabels are the labels on the desktop resource.
  var desktopLabels: Dictionary<String,String> {
    get {return _storage._desktopLabels}
    set {_uniqueStorage()._desktopLabels = newValue}
  }

  /// DesktopName is the name of the desktop resource.
  var desktopName: String {
    get {return _storage._desktopName}
    set {_uniqueStorage()._desktopName = newValue}
  }

  /// AllowUserCreation indicates whether automatic local user creation
  /// is allowed for this session.
  var allowUserCreation: Bool {
    get {return _storage._allowUserCreation}
    set {_uniqueStorage()._allowUserCreation = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DatabaseSessionEnd is emitted when a user ends the database session.
struct Events_DatabaseSessionEnd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Session is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MFADeviceMetadata is a common MFA device metadata.
struct Events_MFADeviceMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the user-specified name of the MFA device.
  var deviceName: String = String()

  /// ID is the UUID of the MFA device generated by Teleport.
  var deviceID: String = String()

  /// Type is the type of this MFA device.
  var deviceType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MFADeviceAdd is emitted when a user adds an MFA device.
struct Events_MFADeviceAdd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Device is the new MFA device added by the user.
  var device: Events_MFADeviceMetadata {
    get {return _storage._device ?? Events_MFADeviceMetadata()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {_uniqueStorage()._device = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MFADeviceDelete is emitted when a user deletes an MFA device.
struct Events_MFADeviceDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Device is the MFA device deleted by the user.
  var device: Events_MFADeviceMetadata {
    get {return _storage._device ?? Events_MFADeviceMetadata()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {_uniqueStorage()._device = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BillingInformationUpdate is emitted when a user updates the billing information.
struct Events_BillingInformationUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BillingCardCreate is emitted when a user creates or updates a credit card.
struct Events_BillingCardCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BillingCardDelete is emitted when a user deletes a credit card.
struct Events_BillingCardDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LockCreate is emitted when a lock is created/updated.
/// Locks are used to restrict access to a Teleport environment by disabling
/// interactions involving a user, an RBAC role, a node, etc.
/// See rfd/0009-locking.md for more details.
struct Events_LockCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Target describes the set of interactions that the lock applies to
  var target: Types_LockTarget {
    get {return _storage._target ?? Types_LockTarget()}
    set {_uniqueStorage()._target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return _storage._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {_uniqueStorage()._target = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LockDelete is emitted when a lock is deleted
struct Events_LockDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RecoveryCodeGenerate is emitted when a user's new recovery codes are generated and updated.
struct Events_RecoveryCodeGenerate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RecoveryCodeUsed is emitted when a user's recovery code was used successfully or
/// unsuccessfully.
struct Events_RecoveryCodeUsed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Status contains fields to indicate whether attempt was successful or not.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WindowsDesktopSessionEnd is emitted when a user ends a Windows desktop session.
struct Events_WindowsDesktopSessionEnd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Session is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// WindowsDesktopService is the name of the service proxying the RDP session.
  var windowsDesktopService: String {
    get {return _storage._windowsDesktopService}
    set {_uniqueStorage()._windowsDesktopService = newValue}
  }

  /// DesktopAddr is the address of the desktop being accessed.
  var desktopAddr: String {
    get {return _storage._desktopAddr}
    set {_uniqueStorage()._desktopAddr = newValue}
  }

  /// Domain is the Active Directory domain of the desktop being accessed.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// WindowsUser is the Windows username used to connect.
  var windowsUser: String {
    get {return _storage._windowsUser}
    set {_uniqueStorage()._windowsUser = newValue}
  }

  /// DesktopLabels are the labels on the desktop resource.
  var desktopLabels: Dictionary<String,String> {
    get {return _storage._desktopLabels}
    set {_uniqueStorage()._desktopLabels = newValue}
  }

  /// StartTime is the timestamp at which the session began.
  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// EndTime is the timestamp at which the session ended.
  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// DesktopName is the name of the desktop resource.
  var desktopName: String {
    get {return _storage._desktopName}
    set {_uniqueStorage()._desktopName = newValue}
  }

  /// Recorded is true if the session was recorded, false otherwise.
  var recorded: Bool {
    get {return _storage._recorded}
    set {_uniqueStorage()._recorded = newValue}
  }

  /// Participants is a list of participants in the session.
  var participants: [String] {
    get {return _storage._participants}
    set {_uniqueStorage()._participants = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// CertificateCreate is emitted when a certificate is issued.
struct Events_CertificateCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// CertificateType is the type of certificate that was just issued.
  var certificateType: String = String()

  /// Identity is the identity associated with the certificate, as interpreted by Teleport.
  var identity: Events_Identity {
    get {return _identity ?? Events_Identity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  mutating func clearIdentity() {self._identity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _identity: Events_Identity? = nil
}

/// RenewableCertificateGenerationMismatch is emitted when a renewable
/// certificate's generation counter fails to validate, possibly indicating a
/// stolen certificate and an invalid renewal attempt.
struct Events_RenewableCertificateGenerationMismatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// UserMetadata is a common user event metadata.
  var userMetadata: Events_UserMetadata {
    get {return _storage._userMetadata ?? Events_UserMetadata()}
    set {_uniqueStorage()._userMetadata = newValue}
  }
  /// Returns true if `userMetadata` has been explicitly set.
  var hasUserMetadata: Bool {return _storage._userMetadata != nil}
  /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
  mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BotJoin records a bot join event.
struct Events_BotJoin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Status contains common command or operation status fields.
  var status: Events_Status {
    get {return _status ?? Events_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// BotName is the name of the bot which has joined.
  var botName: String = String()

  /// Method is the event field indicating what join method was used.
  var method: String = String()

  /// TokenName is the name of the provision token used to join.
  var tokenName: String = String()

  /// Attributes is a map of attributes received from the join method provider.
  var attributes: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _attributes ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  var hasAttributes: Bool {return self._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  mutating func clearAttributes() {self._attributes = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _status: Events_Status? = nil
  fileprivate var _attributes: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// InstanceJoin records an instance join event.
struct Events_InstanceJoin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Status contains common command or operation status fields.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// HostID is the unique host ID of the instance which attempted to join.
  var hostID: String {
    get {return _storage._hostID}
    set {_uniqueStorage()._hostID = newValue}
  }

  /// NodeName is the name of the instance which attempted to join.
  var nodeName: String {
    get {return _storage._nodeName}
    set {_uniqueStorage()._nodeName = newValue}
  }

  /// Role is the role that the node requested when attempting to join.
  var role: String {
    get {return _storage._role}
    set {_uniqueStorage()._role = newValue}
  }

  /// Method is the event field indicating what join method was used.
  var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  /// TokenName is the name of the token used to join. This will be omitted
  /// for the 'token' join method where the token name is a secret value.
  var tokenName: String {
    get {return _storage._tokenName}
    set {_uniqueStorage()._tokenName = newValue}
  }

  /// Attributes is a map of attributes received from the join method provider.
  var attributes: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._attributes ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  var hasAttributes: Bool {return _storage._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  mutating func clearAttributes() {_uniqueStorage()._attributes = nil}

  /// TokenExpires contain information about token expiration time.
  /// In case of static token the TokenExpiration time is to the Unix epoch start time.
  var tokenExpires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._tokenExpires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._tokenExpires = newValue}
  }
  /// Returns true if `tokenExpires` has been explicitly set.
  var hasTokenExpires: Bool {return _storage._tokenExpires != nil}
  /// Clears the value of `tokenExpires`. Subsequent reads from it will return its default value.
  mutating func clearTokenExpires() {_uniqueStorage()._tokenExpires = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Unknown is a fallback event used when we don't recognize an event from the backend.
struct Events_Unknown {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// UnknownType is the event type extracted from the unknown event.
  var unknownType: String = String()

  /// UnknownCode is the event code extracted from the unknown event.
  var unknownCode: String = String()

  /// Data is the serialized JSON data of the unknown event.
  var data: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
}

/// DeviceMetadata groups device information for events.
struct Events_DeviceMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the device.
  var deviceID: String = String()

  /// OS of the device.
  var osType: Events_OSType = .unspecified

  /// Device inventory identifier.
  var assetTag: String = String()

  /// Device credential identifier.
  var credentialID: String = String()

  /// Device origin.
  var deviceOrigin: Events_DeviceOrigin = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeviceEvent is a device-related event.
/// The event type (Metadata.Type) for device events is always "device". See the
/// event code (Metadata.Code) for its meaning.
/// Deprecated: Use DeviceEvent2 instead.
struct Events_DeviceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata holds common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Status indicates the outcome of the event.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// DeviceMetadata holds metadata about the user device.
  var device: Events_DeviceMetadata {
    get {return _storage._device ?? Events_DeviceMetadata()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {_uniqueStorage()._device = nil}

  /// UserMetadata holds metadata about the user behind the event.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeviceEvent2 is a device-related event.
/// See the "lib/events.Device*Event" and "lib/events.Device*Code" for the
/// various event types and codes, respectively.
/// Replaces the previous [DeviceEvent] proto, presenting a more standard event
/// interface with various embeds.
struct Events_DeviceEvent2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata holds common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// DeviceMetadata holds metadata about the user device.
  var device: Events_DeviceMetadata {
    get {return _storage._device ?? Events_DeviceMetadata()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {_uniqueStorage()._device = nil}

  /// Status indicates the outcome of the event.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// UserMetadata holds metadata about the user behind the event.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OneOf is a union of one of audit events submitted to the auth service
struct Events_OneOf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Event is one of the audit events
  var event: Events_OneOf.OneOf_Event? = nil

  var userLogin: Events_UserLogin {
    get {
      if case .userLogin(let v)? = event {return v}
      return Events_UserLogin()
    }
    set {event = .userLogin(newValue)}
  }

  var userCreate: Events_UserCreate {
    get {
      if case .userCreate(let v)? = event {return v}
      return Events_UserCreate()
    }
    set {event = .userCreate(newValue)}
  }

  var userDelete: Events_UserDelete {
    get {
      if case .userDelete(let v)? = event {return v}
      return Events_UserDelete()
    }
    set {event = .userDelete(newValue)}
  }

  var userPasswordChange: Events_UserPasswordChange {
    get {
      if case .userPasswordChange(let v)? = event {return v}
      return Events_UserPasswordChange()
    }
    set {event = .userPasswordChange(newValue)}
  }

  var sessionStart: Events_SessionStart {
    get {
      if case .sessionStart(let v)? = event {return v}
      return Events_SessionStart()
    }
    set {event = .sessionStart(newValue)}
  }

  var sessionJoin: Events_SessionJoin {
    get {
      if case .sessionJoin(let v)? = event {return v}
      return Events_SessionJoin()
    }
    set {event = .sessionJoin(newValue)}
  }

  var sessionPrint: Events_SessionPrint {
    get {
      if case .sessionPrint(let v)? = event {return v}
      return Events_SessionPrint()
    }
    set {event = .sessionPrint(newValue)}
  }

  var sessionReject: Events_SessionReject {
    get {
      if case .sessionReject(let v)? = event {return v}
      return Events_SessionReject()
    }
    set {event = .sessionReject(newValue)}
  }

  var resize: Events_Resize {
    get {
      if case .resize(let v)? = event {return v}
      return Events_Resize()
    }
    set {event = .resize(newValue)}
  }

  var sessionEnd: Events_SessionEnd {
    get {
      if case .sessionEnd(let v)? = event {return v}
      return Events_SessionEnd()
    }
    set {event = .sessionEnd(newValue)}
  }

  var sessionCommand: Events_SessionCommand {
    get {
      if case .sessionCommand(let v)? = event {return v}
      return Events_SessionCommand()
    }
    set {event = .sessionCommand(newValue)}
  }

  var sessionDisk: Events_SessionDisk {
    get {
      if case .sessionDisk(let v)? = event {return v}
      return Events_SessionDisk()
    }
    set {event = .sessionDisk(newValue)}
  }

  var sessionNetwork: Events_SessionNetwork {
    get {
      if case .sessionNetwork(let v)? = event {return v}
      return Events_SessionNetwork()
    }
    set {event = .sessionNetwork(newValue)}
  }

  var sessionData: Events_SessionData {
    get {
      if case .sessionData(let v)? = event {return v}
      return Events_SessionData()
    }
    set {event = .sessionData(newValue)}
  }

  var sessionLeave: Events_SessionLeave {
    get {
      if case .sessionLeave(let v)? = event {return v}
      return Events_SessionLeave()
    }
    set {event = .sessionLeave(newValue)}
  }

  var portForward: Events_PortForward {
    get {
      if case .portForward(let v)? = event {return v}
      return Events_PortForward()
    }
    set {event = .portForward(newValue)}
  }

  var x11Forward: Events_X11Forward {
    get {
      if case .x11Forward(let v)? = event {return v}
      return Events_X11Forward()
    }
    set {event = .x11Forward(newValue)}
  }

  var scp: Events_SCP {
    get {
      if case .scp(let v)? = event {return v}
      return Events_SCP()
    }
    set {event = .scp(newValue)}
  }

  var exec: Events_Exec {
    get {
      if case .exec(let v)? = event {return v}
      return Events_Exec()
    }
    set {event = .exec(newValue)}
  }

  var subsystem: Events_Subsystem {
    get {
      if case .subsystem(let v)? = event {return v}
      return Events_Subsystem()
    }
    set {event = .subsystem(newValue)}
  }

  var clientDisconnect: Events_ClientDisconnect {
    get {
      if case .clientDisconnect(let v)? = event {return v}
      return Events_ClientDisconnect()
    }
    set {event = .clientDisconnect(newValue)}
  }

  var authAttempt: Events_AuthAttempt {
    get {
      if case .authAttempt(let v)? = event {return v}
      return Events_AuthAttempt()
    }
    set {event = .authAttempt(newValue)}
  }

  var accessRequestCreate: Events_AccessRequestCreate {
    get {
      if case .accessRequestCreate(let v)? = event {return v}
      return Events_AccessRequestCreate()
    }
    set {event = .accessRequestCreate(newValue)}
  }

  var userTokenCreate: Events_UserTokenCreate {
    get {
      if case .userTokenCreate(let v)? = event {return v}
      return Events_UserTokenCreate()
    }
    set {event = .userTokenCreate(newValue)}
  }

  var roleCreate: Events_RoleCreate {
    get {
      if case .roleCreate(let v)? = event {return v}
      return Events_RoleCreate()
    }
    set {event = .roleCreate(newValue)}
  }

  var roleDelete: Events_RoleDelete {
    get {
      if case .roleDelete(let v)? = event {return v}
      return Events_RoleDelete()
    }
    set {event = .roleDelete(newValue)}
  }

  var trustedClusterCreate: Events_TrustedClusterCreate {
    get {
      if case .trustedClusterCreate(let v)? = event {return v}
      return Events_TrustedClusterCreate()
    }
    set {event = .trustedClusterCreate(newValue)}
  }

  var trustedClusterDelete: Events_TrustedClusterDelete {
    get {
      if case .trustedClusterDelete(let v)? = event {return v}
      return Events_TrustedClusterDelete()
    }
    set {event = .trustedClusterDelete(newValue)}
  }

  var trustedClusterTokenCreate: Events_TrustedClusterTokenCreate {
    get {
      if case .trustedClusterTokenCreate(let v)? = event {return v}
      return Events_TrustedClusterTokenCreate()
    }
    set {event = .trustedClusterTokenCreate(newValue)}
  }

  var githubConnectorCreate: Events_GithubConnectorCreate {
    get {
      if case .githubConnectorCreate(let v)? = event {return v}
      return Events_GithubConnectorCreate()
    }
    set {event = .githubConnectorCreate(newValue)}
  }

  var githubConnectorDelete: Events_GithubConnectorDelete {
    get {
      if case .githubConnectorDelete(let v)? = event {return v}
      return Events_GithubConnectorDelete()
    }
    set {event = .githubConnectorDelete(newValue)}
  }

  var oidcconnectorCreate: Events_OIDCConnectorCreate {
    get {
      if case .oidcconnectorCreate(let v)? = event {return v}
      return Events_OIDCConnectorCreate()
    }
    set {event = .oidcconnectorCreate(newValue)}
  }

  var oidcconnectorDelete: Events_OIDCConnectorDelete {
    get {
      if case .oidcconnectorDelete(let v)? = event {return v}
      return Events_OIDCConnectorDelete()
    }
    set {event = .oidcconnectorDelete(newValue)}
  }

  var samlconnectorCreate: Events_SAMLConnectorCreate {
    get {
      if case .samlconnectorCreate(let v)? = event {return v}
      return Events_SAMLConnectorCreate()
    }
    set {event = .samlconnectorCreate(newValue)}
  }

  var samlconnectorDelete: Events_SAMLConnectorDelete {
    get {
      if case .samlconnectorDelete(let v)? = event {return v}
      return Events_SAMLConnectorDelete()
    }
    set {event = .samlconnectorDelete(newValue)}
  }

  var kubeRequest: Events_KubeRequest {
    get {
      if case .kubeRequest(let v)? = event {return v}
      return Events_KubeRequest()
    }
    set {event = .kubeRequest(newValue)}
  }

  var appSessionStart: Events_AppSessionStart {
    get {
      if case .appSessionStart(let v)? = event {return v}
      return Events_AppSessionStart()
    }
    set {event = .appSessionStart(newValue)}
  }

  var appSessionChunk: Events_AppSessionChunk {
    get {
      if case .appSessionChunk(let v)? = event {return v}
      return Events_AppSessionChunk()
    }
    set {event = .appSessionChunk(newValue)}
  }

  var appSessionRequest: Events_AppSessionRequest {
    get {
      if case .appSessionRequest(let v)? = event {return v}
      return Events_AppSessionRequest()
    }
    set {event = .appSessionRequest(newValue)}
  }

  var databaseSessionStart: Events_DatabaseSessionStart {
    get {
      if case .databaseSessionStart(let v)? = event {return v}
      return Events_DatabaseSessionStart()
    }
    set {event = .databaseSessionStart(newValue)}
  }

  var databaseSessionEnd: Events_DatabaseSessionEnd {
    get {
      if case .databaseSessionEnd(let v)? = event {return v}
      return Events_DatabaseSessionEnd()
    }
    set {event = .databaseSessionEnd(newValue)}
  }

  var databaseSessionQuery: Events_DatabaseSessionQuery {
    get {
      if case .databaseSessionQuery(let v)? = event {return v}
      return Events_DatabaseSessionQuery()
    }
    set {event = .databaseSessionQuery(newValue)}
  }

  var sessionUpload: Events_SessionUpload {
    get {
      if case .sessionUpload(let v)? = event {return v}
      return Events_SessionUpload()
    }
    set {event = .sessionUpload(newValue)}
  }

  var mfadeviceAdd: Events_MFADeviceAdd {
    get {
      if case .mfadeviceAdd(let v)? = event {return v}
      return Events_MFADeviceAdd()
    }
    set {event = .mfadeviceAdd(newValue)}
  }

  var mfadeviceDelete: Events_MFADeviceDelete {
    get {
      if case .mfadeviceDelete(let v)? = event {return v}
      return Events_MFADeviceDelete()
    }
    set {event = .mfadeviceDelete(newValue)}
  }

  var billingInformationUpdate: Events_BillingInformationUpdate {
    get {
      if case .billingInformationUpdate(let v)? = event {return v}
      return Events_BillingInformationUpdate()
    }
    set {event = .billingInformationUpdate(newValue)}
  }

  var billingCardCreate: Events_BillingCardCreate {
    get {
      if case .billingCardCreate(let v)? = event {return v}
      return Events_BillingCardCreate()
    }
    set {event = .billingCardCreate(newValue)}
  }

  var billingCardDelete: Events_BillingCardDelete {
    get {
      if case .billingCardDelete(let v)? = event {return v}
      return Events_BillingCardDelete()
    }
    set {event = .billingCardDelete(newValue)}
  }

  var lockCreate: Events_LockCreate {
    get {
      if case .lockCreate(let v)? = event {return v}
      return Events_LockCreate()
    }
    set {event = .lockCreate(newValue)}
  }

  var lockDelete: Events_LockDelete {
    get {
      if case .lockDelete(let v)? = event {return v}
      return Events_LockDelete()
    }
    set {event = .lockDelete(newValue)}
  }

  var recoveryCodeGenerate: Events_RecoveryCodeGenerate {
    get {
      if case .recoveryCodeGenerate(let v)? = event {return v}
      return Events_RecoveryCodeGenerate()
    }
    set {event = .recoveryCodeGenerate(newValue)}
  }

  var recoveryCodeUsed: Events_RecoveryCodeUsed {
    get {
      if case .recoveryCodeUsed(let v)? = event {return v}
      return Events_RecoveryCodeUsed()
    }
    set {event = .recoveryCodeUsed(newValue)}
  }

  var databaseCreate: Events_DatabaseCreate {
    get {
      if case .databaseCreate(let v)? = event {return v}
      return Events_DatabaseCreate()
    }
    set {event = .databaseCreate(newValue)}
  }

  var databaseUpdate: Events_DatabaseUpdate {
    get {
      if case .databaseUpdate(let v)? = event {return v}
      return Events_DatabaseUpdate()
    }
    set {event = .databaseUpdate(newValue)}
  }

  var databaseDelete: Events_DatabaseDelete {
    get {
      if case .databaseDelete(let v)? = event {return v}
      return Events_DatabaseDelete()
    }
    set {event = .databaseDelete(newValue)}
  }

  var appCreate: Events_AppCreate {
    get {
      if case .appCreate(let v)? = event {return v}
      return Events_AppCreate()
    }
    set {event = .appCreate(newValue)}
  }

  var appUpdate: Events_AppUpdate {
    get {
      if case .appUpdate(let v)? = event {return v}
      return Events_AppUpdate()
    }
    set {event = .appUpdate(newValue)}
  }

  var appDelete: Events_AppDelete {
    get {
      if case .appDelete(let v)? = event {return v}
      return Events_AppDelete()
    }
    set {event = .appDelete(newValue)}
  }

  var windowsDesktopSessionStart: Events_WindowsDesktopSessionStart {
    get {
      if case .windowsDesktopSessionStart(let v)? = event {return v}
      return Events_WindowsDesktopSessionStart()
    }
    set {event = .windowsDesktopSessionStart(newValue)}
  }

  var windowsDesktopSessionEnd: Events_WindowsDesktopSessionEnd {
    get {
      if case .windowsDesktopSessionEnd(let v)? = event {return v}
      return Events_WindowsDesktopSessionEnd()
    }
    set {event = .windowsDesktopSessionEnd(newValue)}
  }

  var postgresParse: Events_PostgresParse {
    get {
      if case .postgresParse(let v)? = event {return v}
      return Events_PostgresParse()
    }
    set {event = .postgresParse(newValue)}
  }

  var postgresBind: Events_PostgresBind {
    get {
      if case .postgresBind(let v)? = event {return v}
      return Events_PostgresBind()
    }
    set {event = .postgresBind(newValue)}
  }

  var postgresExecute: Events_PostgresExecute {
    get {
      if case .postgresExecute(let v)? = event {return v}
      return Events_PostgresExecute()
    }
    set {event = .postgresExecute(newValue)}
  }

  var postgresClose: Events_PostgresClose {
    get {
      if case .postgresClose(let v)? = event {return v}
      return Events_PostgresClose()
    }
    set {event = .postgresClose(newValue)}
  }

  var postgresFunctionCall: Events_PostgresFunctionCall {
    get {
      if case .postgresFunctionCall(let v)? = event {return v}
      return Events_PostgresFunctionCall()
    }
    set {event = .postgresFunctionCall(newValue)}
  }

  var accessRequestDelete: Events_AccessRequestDelete {
    get {
      if case .accessRequestDelete(let v)? = event {return v}
      return Events_AccessRequestDelete()
    }
    set {event = .accessRequestDelete(newValue)}
  }

  var sessionConnect: Events_SessionConnect {
    get {
      if case .sessionConnect(let v)? = event {return v}
      return Events_SessionConnect()
    }
    set {event = .sessionConnect(newValue)}
  }

  var certificateCreate: Events_CertificateCreate {
    get {
      if case .certificateCreate(let v)? = event {return v}
      return Events_CertificateCreate()
    }
    set {event = .certificateCreate(newValue)}
  }

  var desktopRecording: Events_DesktopRecording {
    get {
      if case .desktopRecording(let v)? = event {return v}
      return Events_DesktopRecording()
    }
    set {event = .desktopRecording(newValue)}
  }

  var desktopClipboardSend: Events_DesktopClipboardSend {
    get {
      if case .desktopClipboardSend(let v)? = event {return v}
      return Events_DesktopClipboardSend()
    }
    set {event = .desktopClipboardSend(newValue)}
  }

  var desktopClipboardReceive: Events_DesktopClipboardReceive {
    get {
      if case .desktopClipboardReceive(let v)? = event {return v}
      return Events_DesktopClipboardReceive()
    }
    set {event = .desktopClipboardReceive(newValue)}
  }

  var mySqlstatementPrepare: Events_MySQLStatementPrepare {
    get {
      if case .mySqlstatementPrepare(let v)? = event {return v}
      return Events_MySQLStatementPrepare()
    }
    set {event = .mySqlstatementPrepare(newValue)}
  }

  var mySqlstatementExecute: Events_MySQLStatementExecute {
    get {
      if case .mySqlstatementExecute(let v)? = event {return v}
      return Events_MySQLStatementExecute()
    }
    set {event = .mySqlstatementExecute(newValue)}
  }

  var mySqlstatementSendLongData: Events_MySQLStatementSendLongData {
    get {
      if case .mySqlstatementSendLongData(let v)? = event {return v}
      return Events_MySQLStatementSendLongData()
    }
    set {event = .mySqlstatementSendLongData(newValue)}
  }

  var mySqlstatementClose: Events_MySQLStatementClose {
    get {
      if case .mySqlstatementClose(let v)? = event {return v}
      return Events_MySQLStatementClose()
    }
    set {event = .mySqlstatementClose(newValue)}
  }

  var mySqlstatementReset: Events_MySQLStatementReset {
    get {
      if case .mySqlstatementReset(let v)? = event {return v}
      return Events_MySQLStatementReset()
    }
    set {event = .mySqlstatementReset(newValue)}
  }

  var mySqlstatementFetch: Events_MySQLStatementFetch {
    get {
      if case .mySqlstatementFetch(let v)? = event {return v}
      return Events_MySQLStatementFetch()
    }
    set {event = .mySqlstatementFetch(newValue)}
  }

  var mySqlstatementBulkExecute: Events_MySQLStatementBulkExecute {
    get {
      if case .mySqlstatementBulkExecute(let v)? = event {return v}
      return Events_MySQLStatementBulkExecute()
    }
    set {event = .mySqlstatementBulkExecute(newValue)}
  }

  var renewableCertificateGenerationMismatch: Events_RenewableCertificateGenerationMismatch {
    get {
      if case .renewableCertificateGenerationMismatch(let v)? = event {return v}
      return Events_RenewableCertificateGenerationMismatch()
    }
    set {event = .renewableCertificateGenerationMismatch(newValue)}
  }

  var unknown: Events_Unknown {
    get {
      if case .unknown(let v)? = event {return v}
      return Events_Unknown()
    }
    set {event = .unknown(newValue)}
  }

  var mySqlinitDb: Events_MySQLInitDB {
    get {
      if case .mySqlinitDb(let v)? = event {return v}
      return Events_MySQLInitDB()
    }
    set {event = .mySqlinitDb(newValue)}
  }

  var mySqlcreateDb: Events_MySQLCreateDB {
    get {
      if case .mySqlcreateDb(let v)? = event {return v}
      return Events_MySQLCreateDB()
    }
    set {event = .mySqlcreateDb(newValue)}
  }

  var mySqldropDb: Events_MySQLDropDB {
    get {
      if case .mySqldropDb(let v)? = event {return v}
      return Events_MySQLDropDB()
    }
    set {event = .mySqldropDb(newValue)}
  }

  var mySqlshutDown: Events_MySQLShutDown {
    get {
      if case .mySqlshutDown(let v)? = event {return v}
      return Events_MySQLShutDown()
    }
    set {event = .mySqlshutDown(newValue)}
  }

  var mySqlprocessKill: Events_MySQLProcessKill {
    get {
      if case .mySqlprocessKill(let v)? = event {return v}
      return Events_MySQLProcessKill()
    }
    set {event = .mySqlprocessKill(newValue)}
  }

  var mySqldebug: Events_MySQLDebug {
    get {
      if case .mySqldebug(let v)? = event {return v}
      return Events_MySQLDebug()
    }
    set {event = .mySqldebug(newValue)}
  }

  var mySqlrefresh: Events_MySQLRefresh {
    get {
      if case .mySqlrefresh(let v)? = event {return v}
      return Events_MySQLRefresh()
    }
    set {event = .mySqlrefresh(newValue)}
  }

  var accessRequestResourceSearch: Events_AccessRequestResourceSearch {
    get {
      if case .accessRequestResourceSearch(let v)? = event {return v}
      return Events_AccessRequestResourceSearch()
    }
    set {event = .accessRequestResourceSearch(newValue)}
  }

  var sqlserverRpcrequest: Events_SQLServerRPCRequest {
    get {
      if case .sqlserverRpcrequest(let v)? = event {return v}
      return Events_SQLServerRPCRequest()
    }
    set {event = .sqlserverRpcrequest(newValue)}
  }

  var databaseSessionMalformedPacket: Events_DatabaseSessionMalformedPacket {
    get {
      if case .databaseSessionMalformedPacket(let v)? = event {return v}
      return Events_DatabaseSessionMalformedPacket()
    }
    set {event = .databaseSessionMalformedPacket(newValue)}
  }

  var sftp: Events_SFTP {
    get {
      if case .sftp(let v)? = event {return v}
      return Events_SFTP()
    }
    set {event = .sftp(newValue)}
  }

  var upgradeWindowStartUpdate: Events_UpgradeWindowStartUpdate {
    get {
      if case .upgradeWindowStartUpdate(let v)? = event {return v}
      return Events_UpgradeWindowStartUpdate()
    }
    set {event = .upgradeWindowStartUpdate(newValue)}
  }

  var appSessionEnd: Events_AppSessionEnd {
    get {
      if case .appSessionEnd(let v)? = event {return v}
      return Events_AppSessionEnd()
    }
    set {event = .appSessionEnd(newValue)}
  }

  var sessionRecordingAccess: Events_SessionRecordingAccess {
    get {
      if case .sessionRecordingAccess(let v)? = event {return v}
      return Events_SessionRecordingAccess()
    }
    set {event = .sessionRecordingAccess(newValue)}
  }

  var kubernetesClusterCreate: Events_KubernetesClusterCreate {
    get {
      if case .kubernetesClusterCreate(let v)? = event {return v}
      return Events_KubernetesClusterCreate()
    }
    set {event = .kubernetesClusterCreate(newValue)}
  }

  var kubernetesClusterUpdate: Events_KubernetesClusterUpdate {
    get {
      if case .kubernetesClusterUpdate(let v)? = event {return v}
      return Events_KubernetesClusterUpdate()
    }
    set {event = .kubernetesClusterUpdate(newValue)}
  }

  var kubernetesClusterDelete: Events_KubernetesClusterDelete {
    get {
      if case .kubernetesClusterDelete(let v)? = event {return v}
      return Events_KubernetesClusterDelete()
    }
    set {event = .kubernetesClusterDelete(newValue)}
  }

  var ssmrun: Events_SSMRun {
    get {
      if case .ssmrun(let v)? = event {return v}
      return Events_SSMRun()
    }
    set {event = .ssmrun(newValue)}
  }

  var elasticsearchRequest: Events_ElasticsearchRequest {
    get {
      if case .elasticsearchRequest(let v)? = event {return v}
      return Events_ElasticsearchRequest()
    }
    set {event = .elasticsearchRequest(newValue)}
  }

  var cassandraBatch: Events_CassandraBatch {
    get {
      if case .cassandraBatch(let v)? = event {return v}
      return Events_CassandraBatch()
    }
    set {event = .cassandraBatch(newValue)}
  }

  var cassandraPrepare: Events_CassandraPrepare {
    get {
      if case .cassandraPrepare(let v)? = event {return v}
      return Events_CassandraPrepare()
    }
    set {event = .cassandraPrepare(newValue)}
  }

  var cassandraRegister: Events_CassandraRegister {
    get {
      if case .cassandraRegister(let v)? = event {return v}
      return Events_CassandraRegister()
    }
    set {event = .cassandraRegister(newValue)}
  }

  var cassandraExecute: Events_CassandraExecute {
    get {
      if case .cassandraExecute(let v)? = event {return v}
      return Events_CassandraExecute()
    }
    set {event = .cassandraExecute(newValue)}
  }

  var appSessionDynamoDbrequest: Events_AppSessionDynamoDBRequest {
    get {
      if case .appSessionDynamoDbrequest(let v)? = event {return v}
      return Events_AppSessionDynamoDBRequest()
    }
    set {event = .appSessionDynamoDbrequest(newValue)}
  }

  var desktopSharedDirectoryStart: Events_DesktopSharedDirectoryStart {
    get {
      if case .desktopSharedDirectoryStart(let v)? = event {return v}
      return Events_DesktopSharedDirectoryStart()
    }
    set {event = .desktopSharedDirectoryStart(newValue)}
  }

  var desktopSharedDirectoryRead: Events_DesktopSharedDirectoryRead {
    get {
      if case .desktopSharedDirectoryRead(let v)? = event {return v}
      return Events_DesktopSharedDirectoryRead()
    }
    set {event = .desktopSharedDirectoryRead(newValue)}
  }

  var desktopSharedDirectoryWrite: Events_DesktopSharedDirectoryWrite {
    get {
      if case .desktopSharedDirectoryWrite(let v)? = event {return v}
      return Events_DesktopSharedDirectoryWrite()
    }
    set {event = .desktopSharedDirectoryWrite(newValue)}
  }

  var dynamoDbrequest: Events_DynamoDBRequest {
    get {
      if case .dynamoDbrequest(let v)? = event {return v}
      return Events_DynamoDBRequest()
    }
    set {event = .dynamoDbrequest(newValue)}
  }

  var botJoin: Events_BotJoin {
    get {
      if case .botJoin(let v)? = event {return v}
      return Events_BotJoin()
    }
    set {event = .botJoin(newValue)}
  }

  var instanceJoin: Events_InstanceJoin {
    get {
      if case .instanceJoin(let v)? = event {return v}
      return Events_InstanceJoin()
    }
    set {event = .instanceJoin(newValue)}
  }

  var deviceEvent: Events_DeviceEvent {
    get {
      if case .deviceEvent(let v)? = event {return v}
      return Events_DeviceEvent()
    }
    set {event = .deviceEvent(newValue)}
  }

  var loginRuleCreate: Events_LoginRuleCreate {
    get {
      if case .loginRuleCreate(let v)? = event {return v}
      return Events_LoginRuleCreate()
    }
    set {event = .loginRuleCreate(newValue)}
  }

  var loginRuleDelete: Events_LoginRuleDelete {
    get {
      if case .loginRuleDelete(let v)? = event {return v}
      return Events_LoginRuleDelete()
    }
    set {event = .loginRuleDelete(newValue)}
  }

  var samlidPauthAttempt: Events_SAMLIdPAuthAttempt {
    get {
      if case .samlidPauthAttempt(let v)? = event {return v}
      return Events_SAMLIdPAuthAttempt()
    }
    set {event = .samlidPauthAttempt(newValue)}
  }

  var samlidPserviceProviderCreate: Events_SAMLIdPServiceProviderCreate {
    get {
      if case .samlidPserviceProviderCreate(let v)? = event {return v}
      return Events_SAMLIdPServiceProviderCreate()
    }
    set {event = .samlidPserviceProviderCreate(newValue)}
  }

  var samlidPserviceProviderUpdate: Events_SAMLIdPServiceProviderUpdate {
    get {
      if case .samlidPserviceProviderUpdate(let v)? = event {return v}
      return Events_SAMLIdPServiceProviderUpdate()
    }
    set {event = .samlidPserviceProviderUpdate(newValue)}
  }

  var samlidPserviceProviderDelete: Events_SAMLIdPServiceProviderDelete {
    get {
      if case .samlidPserviceProviderDelete(let v)? = event {return v}
      return Events_SAMLIdPServiceProviderDelete()
    }
    set {event = .samlidPserviceProviderDelete(newValue)}
  }

  var samlidPserviceProviderDeleteAll: Events_SAMLIdPServiceProviderDeleteAll {
    get {
      if case .samlidPserviceProviderDeleteAll(let v)? = event {return v}
      return Events_SAMLIdPServiceProviderDeleteAll()
    }
    set {event = .samlidPserviceProviderDeleteAll(newValue)}
  }

  var openSearchRequest: Events_OpenSearchRequest {
    get {
      if case .openSearchRequest(let v)? = event {return v}
      return Events_OpenSearchRequest()
    }
    set {event = .openSearchRequest(newValue)}
  }

  var deviceEvent2: Events_DeviceEvent2 {
    get {
      if case .deviceEvent2(let v)? = event {return v}
      return Events_DeviceEvent2()
    }
    set {event = .deviceEvent2(newValue)}
  }

  var oktaResourcesUpdate: Events_OktaResourcesUpdate {
    get {
      if case .oktaResourcesUpdate(let v)? = event {return v}
      return Events_OktaResourcesUpdate()
    }
    set {event = .oktaResourcesUpdate(newValue)}
  }

  var oktaSyncFailure: Events_OktaSyncFailure {
    get {
      if case .oktaSyncFailure(let v)? = event {return v}
      return Events_OktaSyncFailure()
    }
    set {event = .oktaSyncFailure(newValue)}
  }

  var oktaAssignmentResult: Events_OktaAssignmentResult {
    get {
      if case .oktaAssignmentResult(let v)? = event {return v}
      return Events_OktaAssignmentResult()
    }
    set {event = .oktaAssignmentResult(newValue)}
  }

  var provisionTokenCreate: Events_ProvisionTokenCreate {
    get {
      if case .provisionTokenCreate(let v)? = event {return v}
      return Events_ProvisionTokenCreate()
    }
    set {event = .provisionTokenCreate(newValue)}
  }

  var accessListCreate: Events_AccessListCreate {
    get {
      if case .accessListCreate(let v)? = event {return v}
      return Events_AccessListCreate()
    }
    set {event = .accessListCreate(newValue)}
  }

  var accessListUpdate: Events_AccessListUpdate {
    get {
      if case .accessListUpdate(let v)? = event {return v}
      return Events_AccessListUpdate()
    }
    set {event = .accessListUpdate(newValue)}
  }

  var accessListDelete: Events_AccessListDelete {
    get {
      if case .accessListDelete(let v)? = event {return v}
      return Events_AccessListDelete()
    }
    set {event = .accessListDelete(newValue)}
  }

  var accessListReview: Events_AccessListReview {
    get {
      if case .accessListReview(let v)? = event {return v}
      return Events_AccessListReview()
    }
    set {event = .accessListReview(newValue)}
  }

  var accessListMemberCreate: Events_AccessListMemberCreate {
    get {
      if case .accessListMemberCreate(let v)? = event {return v}
      return Events_AccessListMemberCreate()
    }
    set {event = .accessListMemberCreate(newValue)}
  }

  var accessListMemberUpdate: Events_AccessListMemberUpdate {
    get {
      if case .accessListMemberUpdate(let v)? = event {return v}
      return Events_AccessListMemberUpdate()
    }
    set {event = .accessListMemberUpdate(newValue)}
  }

  var accessListMemberDelete: Events_AccessListMemberDelete {
    get {
      if case .accessListMemberDelete(let v)? = event {return v}
      return Events_AccessListMemberDelete()
    }
    set {event = .accessListMemberDelete(newValue)}
  }

  var accessListMemberDeleteAllForAccessList: Events_AccessListMemberDeleteAllForAccessList {
    get {
      if case .accessListMemberDeleteAllForAccessList(let v)? = event {return v}
      return Events_AccessListMemberDeleteAllForAccessList()
    }
    set {event = .accessListMemberDeleteAllForAccessList(newValue)}
  }

  var auditQueryRun: Events_AuditQueryRun {
    get {
      if case .auditQueryRun(let v)? = event {return v}
      return Events_AuditQueryRun()
    }
    set {event = .auditQueryRun(newValue)}
  }

  var securityReportRun: Events_SecurityReportRun {
    get {
      if case .securityReportRun(let v)? = event {return v}
      return Events_SecurityReportRun()
    }
    set {event = .securityReportRun(newValue)}
  }

  var githubConnectorUpdate: Events_GithubConnectorUpdate {
    get {
      if case .githubConnectorUpdate(let v)? = event {return v}
      return Events_GithubConnectorUpdate()
    }
    set {event = .githubConnectorUpdate(newValue)}
  }

  var oidcconnectorUpdate: Events_OIDCConnectorUpdate {
    get {
      if case .oidcconnectorUpdate(let v)? = event {return v}
      return Events_OIDCConnectorUpdate()
    }
    set {event = .oidcconnectorUpdate(newValue)}
  }

  var samlconnectorUpdate: Events_SAMLConnectorUpdate {
    get {
      if case .samlconnectorUpdate(let v)? = event {return v}
      return Events_SAMLConnectorUpdate()
    }
    set {event = .samlconnectorUpdate(newValue)}
  }

  var roleUpdate: Events_RoleUpdate {
    get {
      if case .roleUpdate(let v)? = event {return v}
      return Events_RoleUpdate()
    }
    set {event = .roleUpdate(newValue)}
  }

  var userUpdate: Events_UserUpdate {
    get {
      if case .userUpdate(let v)? = event {return v}
      return Events_UserUpdate()
    }
    set {event = .userUpdate(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Event is one of the audit events
  enum OneOf_Event: Equatable {
    case userLogin(Events_UserLogin)
    case userCreate(Events_UserCreate)
    case userDelete(Events_UserDelete)
    case userPasswordChange(Events_UserPasswordChange)
    case sessionStart(Events_SessionStart)
    case sessionJoin(Events_SessionJoin)
    case sessionPrint(Events_SessionPrint)
    case sessionReject(Events_SessionReject)
    case resize(Events_Resize)
    case sessionEnd(Events_SessionEnd)
    case sessionCommand(Events_SessionCommand)
    case sessionDisk(Events_SessionDisk)
    case sessionNetwork(Events_SessionNetwork)
    case sessionData(Events_SessionData)
    case sessionLeave(Events_SessionLeave)
    case portForward(Events_PortForward)
    case x11Forward(Events_X11Forward)
    case scp(Events_SCP)
    case exec(Events_Exec)
    case subsystem(Events_Subsystem)
    case clientDisconnect(Events_ClientDisconnect)
    case authAttempt(Events_AuthAttempt)
    case accessRequestCreate(Events_AccessRequestCreate)
    case userTokenCreate(Events_UserTokenCreate)
    case roleCreate(Events_RoleCreate)
    case roleDelete(Events_RoleDelete)
    case trustedClusterCreate(Events_TrustedClusterCreate)
    case trustedClusterDelete(Events_TrustedClusterDelete)
    case trustedClusterTokenCreate(Events_TrustedClusterTokenCreate)
    case githubConnectorCreate(Events_GithubConnectorCreate)
    case githubConnectorDelete(Events_GithubConnectorDelete)
    case oidcconnectorCreate(Events_OIDCConnectorCreate)
    case oidcconnectorDelete(Events_OIDCConnectorDelete)
    case samlconnectorCreate(Events_SAMLConnectorCreate)
    case samlconnectorDelete(Events_SAMLConnectorDelete)
    case kubeRequest(Events_KubeRequest)
    case appSessionStart(Events_AppSessionStart)
    case appSessionChunk(Events_AppSessionChunk)
    case appSessionRequest(Events_AppSessionRequest)
    case databaseSessionStart(Events_DatabaseSessionStart)
    case databaseSessionEnd(Events_DatabaseSessionEnd)
    case databaseSessionQuery(Events_DatabaseSessionQuery)
    case sessionUpload(Events_SessionUpload)
    case mfadeviceAdd(Events_MFADeviceAdd)
    case mfadeviceDelete(Events_MFADeviceDelete)
    case billingInformationUpdate(Events_BillingInformationUpdate)
    case billingCardCreate(Events_BillingCardCreate)
    case billingCardDelete(Events_BillingCardDelete)
    case lockCreate(Events_LockCreate)
    case lockDelete(Events_LockDelete)
    case recoveryCodeGenerate(Events_RecoveryCodeGenerate)
    case recoveryCodeUsed(Events_RecoveryCodeUsed)
    case databaseCreate(Events_DatabaseCreate)
    case databaseUpdate(Events_DatabaseUpdate)
    case databaseDelete(Events_DatabaseDelete)
    case appCreate(Events_AppCreate)
    case appUpdate(Events_AppUpdate)
    case appDelete(Events_AppDelete)
    case windowsDesktopSessionStart(Events_WindowsDesktopSessionStart)
    case windowsDesktopSessionEnd(Events_WindowsDesktopSessionEnd)
    case postgresParse(Events_PostgresParse)
    case postgresBind(Events_PostgresBind)
    case postgresExecute(Events_PostgresExecute)
    case postgresClose(Events_PostgresClose)
    case postgresFunctionCall(Events_PostgresFunctionCall)
    case accessRequestDelete(Events_AccessRequestDelete)
    case sessionConnect(Events_SessionConnect)
    case certificateCreate(Events_CertificateCreate)
    case desktopRecording(Events_DesktopRecording)
    case desktopClipboardSend(Events_DesktopClipboardSend)
    case desktopClipboardReceive(Events_DesktopClipboardReceive)
    case mySqlstatementPrepare(Events_MySQLStatementPrepare)
    case mySqlstatementExecute(Events_MySQLStatementExecute)
    case mySqlstatementSendLongData(Events_MySQLStatementSendLongData)
    case mySqlstatementClose(Events_MySQLStatementClose)
    case mySqlstatementReset(Events_MySQLStatementReset)
    case mySqlstatementFetch(Events_MySQLStatementFetch)
    case mySqlstatementBulkExecute(Events_MySQLStatementBulkExecute)
    case renewableCertificateGenerationMismatch(Events_RenewableCertificateGenerationMismatch)
    case unknown(Events_Unknown)
    case mySqlinitDb(Events_MySQLInitDB)
    case mySqlcreateDb(Events_MySQLCreateDB)
    case mySqldropDb(Events_MySQLDropDB)
    case mySqlshutDown(Events_MySQLShutDown)
    case mySqlprocessKill(Events_MySQLProcessKill)
    case mySqldebug(Events_MySQLDebug)
    case mySqlrefresh(Events_MySQLRefresh)
    case accessRequestResourceSearch(Events_AccessRequestResourceSearch)
    case sqlserverRpcrequest(Events_SQLServerRPCRequest)
    case databaseSessionMalformedPacket(Events_DatabaseSessionMalformedPacket)
    case sftp(Events_SFTP)
    case upgradeWindowStartUpdate(Events_UpgradeWindowStartUpdate)
    case appSessionEnd(Events_AppSessionEnd)
    case sessionRecordingAccess(Events_SessionRecordingAccess)
    case kubernetesClusterCreate(Events_KubernetesClusterCreate)
    case kubernetesClusterUpdate(Events_KubernetesClusterUpdate)
    case kubernetesClusterDelete(Events_KubernetesClusterDelete)
    case ssmrun(Events_SSMRun)
    case elasticsearchRequest(Events_ElasticsearchRequest)
    case cassandraBatch(Events_CassandraBatch)
    case cassandraPrepare(Events_CassandraPrepare)
    case cassandraRegister(Events_CassandraRegister)
    case cassandraExecute(Events_CassandraExecute)
    case appSessionDynamoDbrequest(Events_AppSessionDynamoDBRequest)
    case desktopSharedDirectoryStart(Events_DesktopSharedDirectoryStart)
    case desktopSharedDirectoryRead(Events_DesktopSharedDirectoryRead)
    case desktopSharedDirectoryWrite(Events_DesktopSharedDirectoryWrite)
    case dynamoDbrequest(Events_DynamoDBRequest)
    case botJoin(Events_BotJoin)
    case instanceJoin(Events_InstanceJoin)
    case deviceEvent(Events_DeviceEvent)
    case loginRuleCreate(Events_LoginRuleCreate)
    case loginRuleDelete(Events_LoginRuleDelete)
    case samlidPauthAttempt(Events_SAMLIdPAuthAttempt)
    case samlidPserviceProviderCreate(Events_SAMLIdPServiceProviderCreate)
    case samlidPserviceProviderUpdate(Events_SAMLIdPServiceProviderUpdate)
    case samlidPserviceProviderDelete(Events_SAMLIdPServiceProviderDelete)
    case samlidPserviceProviderDeleteAll(Events_SAMLIdPServiceProviderDeleteAll)
    case openSearchRequest(Events_OpenSearchRequest)
    case deviceEvent2(Events_DeviceEvent2)
    case oktaResourcesUpdate(Events_OktaResourcesUpdate)
    case oktaSyncFailure(Events_OktaSyncFailure)
    case oktaAssignmentResult(Events_OktaAssignmentResult)
    case provisionTokenCreate(Events_ProvisionTokenCreate)
    case accessListCreate(Events_AccessListCreate)
    case accessListUpdate(Events_AccessListUpdate)
    case accessListDelete(Events_AccessListDelete)
    case accessListReview(Events_AccessListReview)
    case accessListMemberCreate(Events_AccessListMemberCreate)
    case accessListMemberUpdate(Events_AccessListMemberUpdate)
    case accessListMemberDelete(Events_AccessListMemberDelete)
    case accessListMemberDeleteAllForAccessList(Events_AccessListMemberDeleteAllForAccessList)
    case auditQueryRun(Events_AuditQueryRun)
    case securityReportRun(Events_SecurityReportRun)
    case githubConnectorUpdate(Events_GithubConnectorUpdate)
    case oidcconnectorUpdate(Events_OIDCConnectorUpdate)
    case samlconnectorUpdate(Events_SAMLConnectorUpdate)
    case roleUpdate(Events_RoleUpdate)
    case userUpdate(Events_UserUpdate)

  #if !swift(>=4.1)
    static func ==(lhs: Events_OneOf.OneOf_Event, rhs: Events_OneOf.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.userLogin, .userLogin): return {
        guard case .userLogin(let l) = lhs, case .userLogin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userCreate, .userCreate): return {
        guard case .userCreate(let l) = lhs, case .userCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userDelete, .userDelete): return {
        guard case .userDelete(let l) = lhs, case .userDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userPasswordChange, .userPasswordChange): return {
        guard case .userPasswordChange(let l) = lhs, case .userPasswordChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionStart, .sessionStart): return {
        guard case .sessionStart(let l) = lhs, case .sessionStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionJoin, .sessionJoin): return {
        guard case .sessionJoin(let l) = lhs, case .sessionJoin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionPrint, .sessionPrint): return {
        guard case .sessionPrint(let l) = lhs, case .sessionPrint(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionReject, .sessionReject): return {
        guard case .sessionReject(let l) = lhs, case .sessionReject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resize, .resize): return {
        guard case .resize(let l) = lhs, case .resize(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionEnd, .sessionEnd): return {
        guard case .sessionEnd(let l) = lhs, case .sessionEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionCommand, .sessionCommand): return {
        guard case .sessionCommand(let l) = lhs, case .sessionCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionDisk, .sessionDisk): return {
        guard case .sessionDisk(let l) = lhs, case .sessionDisk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionNetwork, .sessionNetwork): return {
        guard case .sessionNetwork(let l) = lhs, case .sessionNetwork(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionData, .sessionData): return {
        guard case .sessionData(let l) = lhs, case .sessionData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionLeave, .sessionLeave): return {
        guard case .sessionLeave(let l) = lhs, case .sessionLeave(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.portForward, .portForward): return {
        guard case .portForward(let l) = lhs, case .portForward(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.x11Forward, .x11Forward): return {
        guard case .x11Forward(let l) = lhs, case .x11Forward(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scp, .scp): return {
        guard case .scp(let l) = lhs, case .scp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exec, .exec): return {
        guard case .exec(let l) = lhs, case .exec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subsystem, .subsystem): return {
        guard case .subsystem(let l) = lhs, case .subsystem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientDisconnect, .clientDisconnect): return {
        guard case .clientDisconnect(let l) = lhs, case .clientDisconnect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authAttempt, .authAttempt): return {
        guard case .authAttempt(let l) = lhs, case .authAttempt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessRequestCreate, .accessRequestCreate): return {
        guard case .accessRequestCreate(let l) = lhs, case .accessRequestCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userTokenCreate, .userTokenCreate): return {
        guard case .userTokenCreate(let l) = lhs, case .userTokenCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roleCreate, .roleCreate): return {
        guard case .roleCreate(let l) = lhs, case .roleCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roleDelete, .roleDelete): return {
        guard case .roleDelete(let l) = lhs, case .roleDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trustedClusterCreate, .trustedClusterCreate): return {
        guard case .trustedClusterCreate(let l) = lhs, case .trustedClusterCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trustedClusterDelete, .trustedClusterDelete): return {
        guard case .trustedClusterDelete(let l) = lhs, case .trustedClusterDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.trustedClusterTokenCreate, .trustedClusterTokenCreate): return {
        guard case .trustedClusterTokenCreate(let l) = lhs, case .trustedClusterTokenCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.githubConnectorCreate, .githubConnectorCreate): return {
        guard case .githubConnectorCreate(let l) = lhs, case .githubConnectorCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.githubConnectorDelete, .githubConnectorDelete): return {
        guard case .githubConnectorDelete(let l) = lhs, case .githubConnectorDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oidcconnectorCreate, .oidcconnectorCreate): return {
        guard case .oidcconnectorCreate(let l) = lhs, case .oidcconnectorCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oidcconnectorDelete, .oidcconnectorDelete): return {
        guard case .oidcconnectorDelete(let l) = lhs, case .oidcconnectorDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlconnectorCreate, .samlconnectorCreate): return {
        guard case .samlconnectorCreate(let l) = lhs, case .samlconnectorCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlconnectorDelete, .samlconnectorDelete): return {
        guard case .samlconnectorDelete(let l) = lhs, case .samlconnectorDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kubeRequest, .kubeRequest): return {
        guard case .kubeRequest(let l) = lhs, case .kubeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appSessionStart, .appSessionStart): return {
        guard case .appSessionStart(let l) = lhs, case .appSessionStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appSessionChunk, .appSessionChunk): return {
        guard case .appSessionChunk(let l) = lhs, case .appSessionChunk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appSessionRequest, .appSessionRequest): return {
        guard case .appSessionRequest(let l) = lhs, case .appSessionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseSessionStart, .databaseSessionStart): return {
        guard case .databaseSessionStart(let l) = lhs, case .databaseSessionStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseSessionEnd, .databaseSessionEnd): return {
        guard case .databaseSessionEnd(let l) = lhs, case .databaseSessionEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseSessionQuery, .databaseSessionQuery): return {
        guard case .databaseSessionQuery(let l) = lhs, case .databaseSessionQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionUpload, .sessionUpload): return {
        guard case .sessionUpload(let l) = lhs, case .sessionUpload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mfadeviceAdd, .mfadeviceAdd): return {
        guard case .mfadeviceAdd(let l) = lhs, case .mfadeviceAdd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mfadeviceDelete, .mfadeviceDelete): return {
        guard case .mfadeviceDelete(let l) = lhs, case .mfadeviceDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.billingInformationUpdate, .billingInformationUpdate): return {
        guard case .billingInformationUpdate(let l) = lhs, case .billingInformationUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.billingCardCreate, .billingCardCreate): return {
        guard case .billingCardCreate(let l) = lhs, case .billingCardCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.billingCardDelete, .billingCardDelete): return {
        guard case .billingCardDelete(let l) = lhs, case .billingCardDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lockCreate, .lockCreate): return {
        guard case .lockCreate(let l) = lhs, case .lockCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lockDelete, .lockDelete): return {
        guard case .lockDelete(let l) = lhs, case .lockDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.recoveryCodeGenerate, .recoveryCodeGenerate): return {
        guard case .recoveryCodeGenerate(let l) = lhs, case .recoveryCodeGenerate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.recoveryCodeUsed, .recoveryCodeUsed): return {
        guard case .recoveryCodeUsed(let l) = lhs, case .recoveryCodeUsed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseCreate, .databaseCreate): return {
        guard case .databaseCreate(let l) = lhs, case .databaseCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseUpdate, .databaseUpdate): return {
        guard case .databaseUpdate(let l) = lhs, case .databaseUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseDelete, .databaseDelete): return {
        guard case .databaseDelete(let l) = lhs, case .databaseDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appCreate, .appCreate): return {
        guard case .appCreate(let l) = lhs, case .appCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appUpdate, .appUpdate): return {
        guard case .appUpdate(let l) = lhs, case .appUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appDelete, .appDelete): return {
        guard case .appDelete(let l) = lhs, case .appDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsDesktopSessionStart, .windowsDesktopSessionStart): return {
        guard case .windowsDesktopSessionStart(let l) = lhs, case .windowsDesktopSessionStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsDesktopSessionEnd, .windowsDesktopSessionEnd): return {
        guard case .windowsDesktopSessionEnd(let l) = lhs, case .windowsDesktopSessionEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postgresParse, .postgresParse): return {
        guard case .postgresParse(let l) = lhs, case .postgresParse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postgresBind, .postgresBind): return {
        guard case .postgresBind(let l) = lhs, case .postgresBind(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postgresExecute, .postgresExecute): return {
        guard case .postgresExecute(let l) = lhs, case .postgresExecute(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postgresClose, .postgresClose): return {
        guard case .postgresClose(let l) = lhs, case .postgresClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postgresFunctionCall, .postgresFunctionCall): return {
        guard case .postgresFunctionCall(let l) = lhs, case .postgresFunctionCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessRequestDelete, .accessRequestDelete): return {
        guard case .accessRequestDelete(let l) = lhs, case .accessRequestDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionConnect, .sessionConnect): return {
        guard case .sessionConnect(let l) = lhs, case .sessionConnect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.certificateCreate, .certificateCreate): return {
        guard case .certificateCreate(let l) = lhs, case .certificateCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.desktopRecording, .desktopRecording): return {
        guard case .desktopRecording(let l) = lhs, case .desktopRecording(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.desktopClipboardSend, .desktopClipboardSend): return {
        guard case .desktopClipboardSend(let l) = lhs, case .desktopClipboardSend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.desktopClipboardReceive, .desktopClipboardReceive): return {
        guard case .desktopClipboardReceive(let l) = lhs, case .desktopClipboardReceive(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlstatementPrepare, .mySqlstatementPrepare): return {
        guard case .mySqlstatementPrepare(let l) = lhs, case .mySqlstatementPrepare(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlstatementExecute, .mySqlstatementExecute): return {
        guard case .mySqlstatementExecute(let l) = lhs, case .mySqlstatementExecute(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlstatementSendLongData, .mySqlstatementSendLongData): return {
        guard case .mySqlstatementSendLongData(let l) = lhs, case .mySqlstatementSendLongData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlstatementClose, .mySqlstatementClose): return {
        guard case .mySqlstatementClose(let l) = lhs, case .mySqlstatementClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlstatementReset, .mySqlstatementReset): return {
        guard case .mySqlstatementReset(let l) = lhs, case .mySqlstatementReset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlstatementFetch, .mySqlstatementFetch): return {
        guard case .mySqlstatementFetch(let l) = lhs, case .mySqlstatementFetch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlstatementBulkExecute, .mySqlstatementBulkExecute): return {
        guard case .mySqlstatementBulkExecute(let l) = lhs, case .mySqlstatementBulkExecute(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.renewableCertificateGenerationMismatch, .renewableCertificateGenerationMismatch): return {
        guard case .renewableCertificateGenerationMismatch(let l) = lhs, case .renewableCertificateGenerationMismatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unknown, .unknown): return {
        guard case .unknown(let l) = lhs, case .unknown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlinitDb, .mySqlinitDb): return {
        guard case .mySqlinitDb(let l) = lhs, case .mySqlinitDb(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlcreateDb, .mySqlcreateDb): return {
        guard case .mySqlcreateDb(let l) = lhs, case .mySqlcreateDb(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqldropDb, .mySqldropDb): return {
        guard case .mySqldropDb(let l) = lhs, case .mySqldropDb(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlshutDown, .mySqlshutDown): return {
        guard case .mySqlshutDown(let l) = lhs, case .mySqlshutDown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlprocessKill, .mySqlprocessKill): return {
        guard case .mySqlprocessKill(let l) = lhs, case .mySqlprocessKill(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqldebug, .mySqldebug): return {
        guard case .mySqldebug(let l) = lhs, case .mySqldebug(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mySqlrefresh, .mySqlrefresh): return {
        guard case .mySqlrefresh(let l) = lhs, case .mySqlrefresh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessRequestResourceSearch, .accessRequestResourceSearch): return {
        guard case .accessRequestResourceSearch(let l) = lhs, case .accessRequestResourceSearch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sqlserverRpcrequest, .sqlserverRpcrequest): return {
        guard case .sqlserverRpcrequest(let l) = lhs, case .sqlserverRpcrequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.databaseSessionMalformedPacket, .databaseSessionMalformedPacket): return {
        guard case .databaseSessionMalformedPacket(let l) = lhs, case .databaseSessionMalformedPacket(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sftp, .sftp): return {
        guard case .sftp(let l) = lhs, case .sftp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.upgradeWindowStartUpdate, .upgradeWindowStartUpdate): return {
        guard case .upgradeWindowStartUpdate(let l) = lhs, case .upgradeWindowStartUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appSessionEnd, .appSessionEnd): return {
        guard case .appSessionEnd(let l) = lhs, case .appSessionEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionRecordingAccess, .sessionRecordingAccess): return {
        guard case .sessionRecordingAccess(let l) = lhs, case .sessionRecordingAccess(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kubernetesClusterCreate, .kubernetesClusterCreate): return {
        guard case .kubernetesClusterCreate(let l) = lhs, case .kubernetesClusterCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kubernetesClusterUpdate, .kubernetesClusterUpdate): return {
        guard case .kubernetesClusterUpdate(let l) = lhs, case .kubernetesClusterUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.kubernetesClusterDelete, .kubernetesClusterDelete): return {
        guard case .kubernetesClusterDelete(let l) = lhs, case .kubernetesClusterDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ssmrun, .ssmrun): return {
        guard case .ssmrun(let l) = lhs, case .ssmrun(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.elasticsearchRequest, .elasticsearchRequest): return {
        guard case .elasticsearchRequest(let l) = lhs, case .elasticsearchRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cassandraBatch, .cassandraBatch): return {
        guard case .cassandraBatch(let l) = lhs, case .cassandraBatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cassandraPrepare, .cassandraPrepare): return {
        guard case .cassandraPrepare(let l) = lhs, case .cassandraPrepare(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cassandraRegister, .cassandraRegister): return {
        guard case .cassandraRegister(let l) = lhs, case .cassandraRegister(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cassandraExecute, .cassandraExecute): return {
        guard case .cassandraExecute(let l) = lhs, case .cassandraExecute(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appSessionDynamoDbrequest, .appSessionDynamoDbrequest): return {
        guard case .appSessionDynamoDbrequest(let l) = lhs, case .appSessionDynamoDbrequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.desktopSharedDirectoryStart, .desktopSharedDirectoryStart): return {
        guard case .desktopSharedDirectoryStart(let l) = lhs, case .desktopSharedDirectoryStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.desktopSharedDirectoryRead, .desktopSharedDirectoryRead): return {
        guard case .desktopSharedDirectoryRead(let l) = lhs, case .desktopSharedDirectoryRead(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.desktopSharedDirectoryWrite, .desktopSharedDirectoryWrite): return {
        guard case .desktopSharedDirectoryWrite(let l) = lhs, case .desktopSharedDirectoryWrite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dynamoDbrequest, .dynamoDbrequest): return {
        guard case .dynamoDbrequest(let l) = lhs, case .dynamoDbrequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.botJoin, .botJoin): return {
        guard case .botJoin(let l) = lhs, case .botJoin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.instanceJoin, .instanceJoin): return {
        guard case .instanceJoin(let l) = lhs, case .instanceJoin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deviceEvent, .deviceEvent): return {
        guard case .deviceEvent(let l) = lhs, case .deviceEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loginRuleCreate, .loginRuleCreate): return {
        guard case .loginRuleCreate(let l) = lhs, case .loginRuleCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loginRuleDelete, .loginRuleDelete): return {
        guard case .loginRuleDelete(let l) = lhs, case .loginRuleDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlidPauthAttempt, .samlidPauthAttempt): return {
        guard case .samlidPauthAttempt(let l) = lhs, case .samlidPauthAttempt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlidPserviceProviderCreate, .samlidPserviceProviderCreate): return {
        guard case .samlidPserviceProviderCreate(let l) = lhs, case .samlidPserviceProviderCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlidPserviceProviderUpdate, .samlidPserviceProviderUpdate): return {
        guard case .samlidPserviceProviderUpdate(let l) = lhs, case .samlidPserviceProviderUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlidPserviceProviderDelete, .samlidPserviceProviderDelete): return {
        guard case .samlidPserviceProviderDelete(let l) = lhs, case .samlidPserviceProviderDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlidPserviceProviderDeleteAll, .samlidPserviceProviderDeleteAll): return {
        guard case .samlidPserviceProviderDeleteAll(let l) = lhs, case .samlidPserviceProviderDeleteAll(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.openSearchRequest, .openSearchRequest): return {
        guard case .openSearchRequest(let l) = lhs, case .openSearchRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deviceEvent2, .deviceEvent2): return {
        guard case .deviceEvent2(let l) = lhs, case .deviceEvent2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oktaResourcesUpdate, .oktaResourcesUpdate): return {
        guard case .oktaResourcesUpdate(let l) = lhs, case .oktaResourcesUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oktaSyncFailure, .oktaSyncFailure): return {
        guard case .oktaSyncFailure(let l) = lhs, case .oktaSyncFailure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oktaAssignmentResult, .oktaAssignmentResult): return {
        guard case .oktaAssignmentResult(let l) = lhs, case .oktaAssignmentResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.provisionTokenCreate, .provisionTokenCreate): return {
        guard case .provisionTokenCreate(let l) = lhs, case .provisionTokenCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListCreate, .accessListCreate): return {
        guard case .accessListCreate(let l) = lhs, case .accessListCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListUpdate, .accessListUpdate): return {
        guard case .accessListUpdate(let l) = lhs, case .accessListUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListDelete, .accessListDelete): return {
        guard case .accessListDelete(let l) = lhs, case .accessListDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListReview, .accessListReview): return {
        guard case .accessListReview(let l) = lhs, case .accessListReview(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListMemberCreate, .accessListMemberCreate): return {
        guard case .accessListMemberCreate(let l) = lhs, case .accessListMemberCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListMemberUpdate, .accessListMemberUpdate): return {
        guard case .accessListMemberUpdate(let l) = lhs, case .accessListMemberUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListMemberDelete, .accessListMemberDelete): return {
        guard case .accessListMemberDelete(let l) = lhs, case .accessListMemberDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListMemberDeleteAllForAccessList, .accessListMemberDeleteAllForAccessList): return {
        guard case .accessListMemberDeleteAllForAccessList(let l) = lhs, case .accessListMemberDeleteAllForAccessList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.auditQueryRun, .auditQueryRun): return {
        guard case .auditQueryRun(let l) = lhs, case .auditQueryRun(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.securityReportRun, .securityReportRun): return {
        guard case .securityReportRun(let l) = lhs, case .securityReportRun(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.githubConnectorUpdate, .githubConnectorUpdate): return {
        guard case .githubConnectorUpdate(let l) = lhs, case .githubConnectorUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oidcconnectorUpdate, .oidcconnectorUpdate): return {
        guard case .oidcconnectorUpdate(let l) = lhs, case .oidcconnectorUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlconnectorUpdate, .samlconnectorUpdate): return {
        guard case .samlconnectorUpdate(let l) = lhs, case .samlconnectorUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roleUpdate, .roleUpdate): return {
        guard case .roleUpdate(let l) = lhs, case .roleUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userUpdate, .userUpdate): return {
        guard case .userUpdate(let l) = lhs, case .userUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// StreamStatus reflects stream status
struct Events_StreamStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UploadID represents upload ID
  var uploadID: String = String()

  /// LastEventIndex updates last event index
  var lastEventIndex: Int64 = 0

  /// LastUploadTime is the time of the last upload
  var lastUploadTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastUploadTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastUploadTime = newValue}
  }
  /// Returns true if `lastUploadTime` has been explicitly set.
  var hasLastUploadTime: Bool {return self._lastUploadTime != nil}
  /// Clears the value of `lastUploadTime`. Subsequent reads from it will return its default value.
  mutating func clearLastUploadTime() {self._lastUploadTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastUploadTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// SessionUpload is a session upload
struct Events_SessionUpload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// SessionMetadata is a common event session metadata
  var sessionMetadata: Events_SessionMetadata {
    get {return _sessionMetadata ?? Events_SessionMetadata()}
    set {_sessionMetadata = newValue}
  }
  /// Returns true if `sessionMetadata` has been explicitly set.
  var hasSessionMetadata: Bool {return self._sessionMetadata != nil}
  /// Clears the value of `sessionMetadata`. Subsequent reads from it will return its default value.
  mutating func clearSessionMetadata() {self._sessionMetadata = nil}

  /// URL is where the url the session event data upload is at
  var sessionURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _sessionMetadata: Events_SessionMetadata? = nil
}

/// Identity matches github.com/gravitational/teleport/lib/tlsca.Identity except
/// for RouteToApp and RouteToDatabase which are nullable and Traits which is
/// represented as a google.protobuf.Struct (still containing a map from string
/// to strings). Field names match other names already used in other events
/// rather than the field names in tlsca.Identity.
struct Events_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User is a username or name of the node connection
  var user: String {
    get {return _storage._user}
    set {_uniqueStorage()._user = newValue}
  }

  /// Impersonator is a username of a user impersonating this user
  var impersonator: String {
    get {return _storage._impersonator}
    set {_uniqueStorage()._impersonator = newValue}
  }

  /// Roles is a list of groups (Teleport roles) encoded in the identity
  var roles: [String] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  /// Usage is a list of usage restrictions encoded in the identity
  var usage: [String] {
    get {return _storage._usage}
    set {_uniqueStorage()._usage = newValue}
  }

  /// Logins is a list of Unix logins allowed.
  var logins: [String] {
    get {return _storage._logins}
    set {_uniqueStorage()._logins = newValue}
  }

  /// KubernetesGroups is a list of Kubernetes groups allowed
  var kubernetesGroups: [String] {
    get {return _storage._kubernetesGroups}
    set {_uniqueStorage()._kubernetesGroups = newValue}
  }

  /// KubernetesUsers is a list of Kubernetes users allowed
  var kubernetesUsers: [String] {
    get {return _storage._kubernetesUsers}
    set {_uniqueStorage()._kubernetesUsers = newValue}
  }

  /// Expires specifies whenever the session will expire
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return _storage._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {_uniqueStorage()._expires = nil}

  /// RouteToCluster specifies the target cluster
  /// if present in the session
  var routeToCluster: String {
    get {return _storage._routeToCluster}
    set {_uniqueStorage()._routeToCluster = newValue}
  }

  /// KubernetesCluster specifies the target kubernetes cluster for TLS
  /// identities. This can be empty on older Teleport clients.
  var kubernetesCluster: String {
    get {return _storage._kubernetesCluster}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }

  /// Traits hold claim data used to populate a role at runtime.
  var traits: Wrappers_LabelValues {
    get {return _storage._traits ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._traits = newValue}
  }
  /// Returns true if `traits` has been explicitly set.
  var hasTraits: Bool {return _storage._traits != nil}
  /// Clears the value of `traits`. Subsequent reads from it will return its default value.
  mutating func clearTraits() {_uniqueStorage()._traits = nil}

  /// RouteToApp holds routing information for applications. Routing metadata
  /// allows Teleport web proxy to route HTTP requests to the appropriate
  /// cluster and Teleport application proxy within the cluster.
  var routeToApp: Events_RouteToApp {
    get {return _storage._routeToApp ?? Events_RouteToApp()}
    set {_uniqueStorage()._routeToApp = newValue}
  }
  /// Returns true if `routeToApp` has been explicitly set.
  var hasRouteToApp: Bool {return _storage._routeToApp != nil}
  /// Clears the value of `routeToApp`. Subsequent reads from it will return its default value.
  mutating func clearRouteToApp() {_uniqueStorage()._routeToApp = nil}

  /// TeleportCluster is the name of the teleport cluster that this identity
  /// originated from. For TLS certs this may not be the same as cert issuer,
  /// in case of multi-hop requests that originate from a remote cluster.
  var teleportCluster: String {
    get {return _storage._teleportCluster}
    set {_uniqueStorage()._teleportCluster = newValue}
  }

  /// RouteToDatabase contains routing information for databases.
  var routeToDatabase: Events_RouteToDatabase {
    get {return _storage._routeToDatabase ?? Events_RouteToDatabase()}
    set {_uniqueStorage()._routeToDatabase = newValue}
  }
  /// Returns true if `routeToDatabase` has been explicitly set.
  var hasRouteToDatabase: Bool {return _storage._routeToDatabase != nil}
  /// Clears the value of `routeToDatabase`. Subsequent reads from it will return its default value.
  mutating func clearRouteToDatabase() {_uniqueStorage()._routeToDatabase = nil}

  /// DatabaseNames is a list of allowed database names.
  var databaseNames: [String] {
    get {return _storage._databaseNames}
    set {_uniqueStorage()._databaseNames = newValue}
  }

  /// DatabaseUsers is a list of allowed database users.
  var databaseUsers: [String] {
    get {return _storage._databaseUsers}
    set {_uniqueStorage()._databaseUsers = newValue}
  }

  /// MFADeviceUUID is the UUID of an MFA device when this Identity was
  /// confirmed immediately after an MFA check.
  var mfadeviceUuid: String {
    get {return _storage._mfadeviceUuid}
    set {_uniqueStorage()._mfadeviceUuid = newValue}
  }

  /// ClientIP is an observed IP of the client that this Identity represents.
  var clientIp: String {
    get {return _storage._clientIp}
    set {_uniqueStorage()._clientIp = newValue}
  }

  /// AWSRoleARNs is a list of allowed AWS role ARNs user can assume.
  var awsroleArns: [String] {
    get {return _storage._awsroleArns}
    set {_uniqueStorage()._awsroleArns = newValue}
  }

  /// AccessRequests is a list of UUIDs of active requests for this Identity.
  var accessRequests: [String] {
    get {return _storage._accessRequests}
    set {_uniqueStorage()._accessRequests = newValue}
  }

  /// DisallowReissue is a flag that, if set, instructs the auth server to
  /// deny any attempts to reissue new certificates while authenticated with
  /// this certificate.
  var disallowReissue: Bool {
    get {return _storage._disallowReissue}
    set {_uniqueStorage()._disallowReissue = newValue}
  }

  /// AllowedResourceIds is the list of resources which the identity will be
  /// allowed to access. An empty list indicates that no resource-specific
  /// restrictions will be applied.
  var allowedResourceIds: [Events_ResourceID] {
    get {return _storage._allowedResourceIds}
    set {_uniqueStorage()._allowedResourceIds = newValue}
  }

  /// PreviousIdentityExpires is the expiry time of the identity/cert that this
  /// identity/cert was derived from. It is used to determine a session's hard
  /// deadline in cases where both require_session_mfa and disconnect_expired_cert
  /// are enabled. See https://github.com/gravitational/teleport/issues/18544.
  var previousIdentityExpires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._previousIdentityExpires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._previousIdentityExpires = newValue}
  }
  /// Returns true if `previousIdentityExpires` has been explicitly set.
  var hasPreviousIdentityExpires: Bool {return _storage._previousIdentityExpires != nil}
  /// Clears the value of `previousIdentityExpires`. Subsequent reads from it will return its default value.
  mutating func clearPreviousIdentityExpires() {_uniqueStorage()._previousIdentityExpires = nil}

  /// AzureIdentities is a list of allowed Azure identities user can assume.
  var azureIdentities: [String] {
    get {return _storage._azureIdentities}
    set {_uniqueStorage()._azureIdentities = newValue}
  }

  /// GCPServiceAccounts is a list of allowed GCP service accounts user can assume.
  var gcpserviceAccounts: [String] {
    get {return _storage._gcpserviceAccounts}
    set {_uniqueStorage()._gcpserviceAccounts = newValue}
  }

  /// PrivateKeyPolicy is the private key policy of the user's private key.
  var privateKeyPolicy: String {
    get {return _storage._privateKeyPolicy}
    set {_uniqueStorage()._privateKeyPolicy = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RouteToApp contains parameters for application access certificate requests.
struct Events_RouteToApp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the application name certificate is being requested for.
  var name: String = String()

  /// SessionID is the ID of the application session.
  var sessionID: String = String()

  /// PublicAddr is the application public address.
  var publicAddr: String = String()

  /// ClusterName is the cluster where the application resides.
  var clusterName: String = String()

  /// AWSRoleARN is the AWS role to assume when accessing AWS API.
  var awsroleArn: String = String()

  /// AzureIdentity is the Azure identity ot assume when accessing Azure API.
  var azureIdentity: String = String()

  /// GCPServiceAccount is the GCP service account to assume when accessing GCP API.
  var gcpserviceAccount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RouteToDatabase combines parameters for database service routing information.
struct Events_RouteToDatabase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ServiceName is the Teleport database proxy service name the cert is for.
  var serviceName: String = String()

  /// Protocol is the type of the database the cert is for.
  var `protocol`: String = String()

  /// Username is an optional database username to embed.
  var username: String = String()

  /// Database is an optional database name to embed.
  var database: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestResourceSearch is emitted when a user searches for resources as
/// part of a search-based access request
struct Events_AccessRequestResourceSearch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is common user metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SearchAsRoles is the list of roles the search was performed as.
  var searchAsRoles: [String] {
    get {return _storage._searchAsRoles}
    set {_uniqueStorage()._searchAsRoles = newValue}
  }

  /// ResourceType is the type of resource being searched for.
  var resourceType: String {
    get {return _storage._resourceType}
    set {_uniqueStorage()._resourceType = newValue}
  }

  /// Namespace is the namespace of resources.
  var namespace: String {
    get {return _storage._namespace}
    set {_uniqueStorage()._namespace = newValue}
  }

  /// Labels is the label-based matcher used for the search.
  var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// PredicateExpression is the list of boolean conditions that were used for the search.
  var predicateExpression: String {
    get {return _storage._predicateExpression}
    set {_uniqueStorage()._predicateExpression = newValue}
  }

  /// SearchKeywords is the list of search keywords used to match against resource field values.
  var searchKeywords: [String] {
    get {return _storage._searchKeywords}
    set {_uniqueStorage()._searchKeywords = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLStatementPrepare is emitted when a MySQL client creates a prepared
/// statement using the prepared statement protocol.
struct Events_MySQLStatementPrepare {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// Query is the prepared statement query.
  var query: String {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLStatementExecute is emitted when a MySQL client executes a prepared
/// statement using the prepared statement protocol.
struct Events_MySQLStatementExecute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// StatementID is the identifier of the prepared statement.
  var statementID: UInt32 {
    get {return _storage._statementID}
    set {_uniqueStorage()._statementID = newValue}
  }

  /// Parameters are the parameters used to execute the prepared statement.
  var parameters: [String] {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLStatementSendLongData is emitted when a MySQL client sends long bytes
/// stream using the prepared statement protocol.
struct Events_MySQLStatementSendLongData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// StatementID is the identifier of the prepared statement.
  var statementID: UInt32 {
    get {return _storage._statementID}
    set {_uniqueStorage()._statementID = newValue}
  }

  /// ParameterID is the identifier of the parameter.
  var parameterID: UInt32 {
    get {return _storage._parameterID}
    set {_uniqueStorage()._parameterID = newValue}
  }

  /// DataSize is the size of the data.
  var dataSize: UInt32 {
    get {return _storage._dataSize}
    set {_uniqueStorage()._dataSize = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLStatementClose is emitted when a MySQL client deallocates a prepared
/// statement using the prepared statement protocol.
struct Events_MySQLStatementClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// StatementID is the identifier of the prepared statement.
  var statementID: UInt32 {
    get {return _storage._statementID}
    set {_uniqueStorage()._statementID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLStatementReset is emitted when a MySQL client resets the data of a
/// prepared statement using the prepared statement protocol.
struct Events_MySQLStatementReset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// StatementID is the identifier of the prepared statement.
  var statementID: UInt32 {
    get {return _storage._statementID}
    set {_uniqueStorage()._statementID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLStatementFetch is emitted when a MySQL client fetches rows from a
/// prepared statement using the prepared statement protocol.
struct Events_MySQLStatementFetch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// StatementID is the identifier of the prepared statement.
  var statementID: UInt32 {
    get {return _storage._statementID}
    set {_uniqueStorage()._statementID = newValue}
  }

  /// RowsCount is the number of rows to fetch.
  var rowsCount: UInt32 {
    get {return _storage._rowsCount}
    set {_uniqueStorage()._rowsCount = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLStatementBulkExecute is emitted when a MySQL client executes a bulk
/// insert of a prepared statement using the prepared statement protocol.
struct Events_MySQLStatementBulkExecute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// StatementID is the identifier of the prepared statement.
  var statementID: UInt32 {
    get {return _storage._statementID}
    set {_uniqueStorage()._statementID = newValue}
  }

  /// Parameters are the parameters used to execute the prepared statement.
  var parameters: [String] {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLInitDB is emitted when a MySQL client changes the default schema for
/// the connection.
struct Events_MySQLInitDB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// SchemaName is the name of the schema to use.
  var schemaName: String {
    get {return _storage._schemaName}
    set {_uniqueStorage()._schemaName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLCreateDB is emitted when a MySQL client creates a schema.
struct Events_MySQLCreateDB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// SchemaName is the name of the schema to create.
  var schemaName: String {
    get {return _storage._schemaName}
    set {_uniqueStorage()._schemaName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLDropDB is emitted when a MySQL client drops a schema.
struct Events_MySQLDropDB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// SchemaName is the name of the schema to drop.
  var schemaName: String {
    get {return _storage._schemaName}
    set {_uniqueStorage()._schemaName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLShutDown is emitted when a MySQL client asks the server to shut down.
struct Events_MySQLShutDown {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLProcessKill is emitted when a MySQL client asks the server to terminate
/// a connection.
struct Events_MySQLProcessKill {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// ProcessID is the process ID of a connection.
  var processID: UInt32 {
    get {return _storage._processID}
    set {_uniqueStorage()._processID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLDebug is emitted when a MySQL client asks the server to dump internal
/// debug info to stdout.
struct Events_MySQLDebug {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// MySQLRefresh is emitted when a MySQL client sends refresh commands.
struct Events_MySQLRefresh {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// Subcommand is the string representation of the subcommand.
  var subcommand: String {
    get {return _storage._subcommand}
    set {_uniqueStorage()._subcommand = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SQLServerRPCRequest is emitted when a user executes a MSSQL Server RPC command.
struct Events_SQLServerRPCRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// Procname is the RPC SQL Server procedure name.
  var procname: String {
    get {return _storage._procname}
    set {_uniqueStorage()._procname = newValue}
  }

  /// Parameters are the RPC parameters used to execute RPC Procedure..
  var parameters: [String] {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DatabaseSessionMalformedPacket is emitted when a database sends a malformed packet.
struct Events_DatabaseSessionMalformedPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// Payload is the malformed packet payload.
  var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ElasticsearchRequest is emitted when user executes an Elasticsearch request, which isn't
/// covered by API-specific events.
struct Events_ElasticsearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// Path is relative path in the URL.
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// RawQuery are the encoded query values.
  var rawQuery: String {
    get {return _storage._rawQuery}
    set {_uniqueStorage()._rawQuery = newValue}
  }

  /// Method is the request HTTP method, like GET/POST/DELETE/etc.
  var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  /// Body is the request HTTP body.
  var body: Data {
    get {return _storage._body}
    set {_uniqueStorage()._body = newValue}
  }

  /// Headers are the HTTP request headers.
  var headers: Wrappers_LabelValues {
    get {return _storage._headers ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._headers = newValue}
  }
  /// Returns true if `headers` has been explicitly set.
  var hasHeaders: Bool {return _storage._headers != nil}
  /// Clears the value of `headers`. Subsequent reads from it will return its default value.
  mutating func clearHeaders() {_uniqueStorage()._headers = nil}

  /// Category represents the category if API being accessed in a given request.
  var category: Events_ElasticsearchCategory {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  /// Target is an optional field indicating the target index or set of indices used as a subject of request.
  var target: String {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  /// Query is an optional text of query (e.g. an SQL select statement for _sql API), if a request includes it.
  var query: String {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  /// StatusCode is optional status code returned from the call to database.
  var statusCode: UInt32 {
    get {return _storage._statusCode}
    set {_uniqueStorage()._statusCode = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OpenSearchRequest is emitted when a user executes a OpenSearch request via database-access.
struct Events_OpenSearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// Path is relative path in the URL.
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// RawQuery are the encoded query values.
  var rawQuery: String {
    get {return _storage._rawQuery}
    set {_uniqueStorage()._rawQuery = newValue}
  }

  /// Method is the request HTTP method, like GET/POST/DELETE/etc.
  var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  /// Body is the request HTTP body.
  var body: Data {
    get {return _storage._body}
    set {_uniqueStorage()._body = newValue}
  }

  /// Headers are the HTTP request headers.
  var headers: Wrappers_LabelValues {
    get {return _storage._headers ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._headers = newValue}
  }
  /// Returns true if `headers` has been explicitly set.
  var hasHeaders: Bool {return _storage._headers != nil}
  /// Clears the value of `headers`. Subsequent reads from it will return its default value.
  mutating func clearHeaders() {_uniqueStorage()._headers = nil}

  /// Category represents the category if API being accessed in a given request.
  var category: Events_OpenSearchCategory {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  /// Target is an optional field indicating the target index or set of indices used as a subject of request.
  var target: String {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  /// Query is an optional text of query (e.g. an SQL select statement for _sql API), if a request includes it.
  var query: String {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  /// StatusCode is optional status code returned from the call to database.
  var statusCode: UInt32 {
    get {return _storage._statusCode}
    set {_uniqueStorage()._statusCode = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DynamoDBRequest is emitted when a user executes a DynamoDB request via database-access.
struct Events_DynamoDBRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  var statusCode: UInt32 {
    get {return _storage._statusCode}
    set {_uniqueStorage()._statusCode = newValue}
  }

  /// Path is relative path in the URL.
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// RawQuery are the encoded query values.
  var rawQuery: String {
    get {return _storage._rawQuery}
    set {_uniqueStorage()._rawQuery = newValue}
  }

  /// Method is the request HTTP method, like GET/POST/DELETE/etc.
  var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  /// Target is the API target in the X-Amz-Target header.
  var target: String {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  /// Body is the HTTP request json body.
  /// The Struct type is a wrapper around protobuf/types.Struct and is used to marshal the JSON body correctly.
  var body: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._body ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AppSessionDynamoDBRequest is emitted when a user executes a DynamoDB request via app access.
struct Events_AppSessionDynamoDBRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// App is a common application resource metadata.
  var app: Events_AppMetadata {
    get {return _storage._app ?? Events_AppMetadata()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  mutating func clearApp() {_uniqueStorage()._app = nil}

  /// AWS contains extra AWS metadata of the request.
  var aws: Events_AWSRequestMetadata {
    get {return _storage._aws ?? Events_AWSRequestMetadata()}
    set {_uniqueStorage()._aws = newValue}
  }
  /// Returns true if `aws` has been explicitly set.
  var hasAws: Bool {return _storage._aws != nil}
  /// Clears the value of `aws`. Subsequent reads from it will return its default value.
  mutating func clearAws() {_uniqueStorage()._aws = nil}

  /// SessionChunkID is the ID of the app session chunk that this request belongs to.
  /// This is more appropriate to include than the app session id, since it is the chunk
  /// id that is needed to play back the session chunk with tsh. The session chunk event
  /// already includes the app session id.
  var sessionChunkID: String {
    get {return _storage._sessionChunkID}
    set {_uniqueStorage()._sessionChunkID = newValue}
  }

  /// StatusCode the HTTP response code for the request.
  var statusCode: UInt32 {
    get {return _storage._statusCode}
    set {_uniqueStorage()._statusCode = newValue}
  }

  /// Path is relative path in the URL.
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  /// RawQuery are the encoded query values.
  var rawQuery: String {
    get {return _storage._rawQuery}
    set {_uniqueStorage()._rawQuery = newValue}
  }

  /// Method is the request HTTP method, like GET/POST/DELETE/etc.
  var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  /// Target is the API target in the X-Amz-Target header.
  var target: String {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  /// Body is the HTTP request json body.
  /// The Struct type is a wrapper around protobuf/types.Struct and is used to marshal the JSON body correctly.
  var body: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._body ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// UpgradeWindowStartMetadata contains common upgrade window information.
struct Events_UpgradeWindowStartMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UpgradeWindowStart is the upgrade window time.
  var upgradeWindowStart: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UpgradeWindowStartUpdate is emitted when a user updates the cloud upgrade window start time.
struct Events_UpgradeWindowStartUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// UpgradeWindowStartMetadata contains upgrade window related metadata.
  var upgradeWindowStart: Events_UpgradeWindowStartMetadata {
    get {return _storage._upgradeWindowStart ?? Events_UpgradeWindowStartMetadata()}
    set {_uniqueStorage()._upgradeWindowStart = newValue}
  }
  /// Returns true if `upgradeWindowStart` has been explicitly set.
  var hasUpgradeWindowStart: Bool {return _storage._upgradeWindowStart != nil}
  /// Clears the value of `upgradeWindowStart`. Subsequent reads from it will return its default value.
  mutating func clearUpgradeWindowStart() {_uniqueStorage()._upgradeWindowStart = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionRecordingAccess is emitted when a session recording is accessed, allowing
/// session views to be included in the audit log
struct Events_SessionRecordingAccess {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// SessionID is the ID of the session.
  var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// UserMetadata is a common user event metadata.
  var userMetadata: Events_UserMetadata {
    get {return _storage._userMetadata ?? Events_UserMetadata()}
    set {_uniqueStorage()._userMetadata = newValue}
  }
  /// Returns true if `userMetadata` has been explicitly set.
  var hasUserMetadata: Bool {return _storage._userMetadata != nil}
  /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
  mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// KubeClusterMetadata contains common kubernetes cluster information.
struct Events_KubeClusterMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// KubeLabels are the configured cluster labels.
  var kubeLabels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// KubernetesClusterCreate is emitted when a new kubernetes cluster resource is created.
struct Events_KubernetesClusterCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata.
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// KubeClusterMetadata is a common kubernetes resource metadata.
  var kubeClusterMetadata: Events_KubeClusterMetadata {
    get {return _storage._kubeClusterMetadata ?? Events_KubeClusterMetadata()}
    set {_uniqueStorage()._kubeClusterMetadata = newValue}
  }
  /// Returns true if `kubeClusterMetadata` has been explicitly set.
  var hasKubeClusterMetadata: Bool {return _storage._kubeClusterMetadata != nil}
  /// Clears the value of `kubeClusterMetadata`. Subsequent reads from it will return its default value.
  mutating func clearKubeClusterMetadata() {_uniqueStorage()._kubeClusterMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// KubernetesClusterUpdate is emitted when an existing kubernetes cluster resource is updated.
struct Events_KubernetesClusterUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata.
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// KubeClusterMetadata is a common kubernetes resource metadata.
  var kubeClusterMetadata: Events_KubeClusterMetadata {
    get {return _storage._kubeClusterMetadata ?? Events_KubeClusterMetadata()}
    set {_uniqueStorage()._kubeClusterMetadata = newValue}
  }
  /// Returns true if `kubeClusterMetadata` has been explicitly set.
  var hasKubeClusterMetadata: Bool {return _storage._kubeClusterMetadata != nil}
  /// Clears the value of `kubeClusterMetadata`. Subsequent reads from it will return its default value.
  mutating func clearKubeClusterMetadata() {_uniqueStorage()._kubeClusterMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// KubernetesClusterDelete is emitted when a kubernetes cluster resource is deleted.
struct Events_KubernetesClusterDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// ResourceMetadata is a common resource event metadata.
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SSMRun is emitted after an AWS SSM document completes execution.
struct Events_SSMRun {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// CommandID is the id of the SSM command that was run.
  var commandID: String = String()

  /// InstanceID is the id of the EC2 instance the command was run on.
  var instanceID: String = String()

  /// ExitCode is the exit code resulting from the script run.
  var exitCode: Int64 = 0

  /// Status represents the success or failure status of a script run.
  var status: String = String()

  /// AccountID is the id of the AWS account that ran the command.
  var accountID: String = String()

  /// Region is the AWS region the command was ran in.
  var region: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
}

/// CassandraSession is emitted when a Cassandra client sends
/// the prepare a CQL statement.
struct Events_CassandraPrepare {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// Query is the CQL statement.
  var query: String {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  /// Keyspace is the keyspace the statement is in.
  var keyspace: String {
    get {return _storage._keyspace}
    set {_uniqueStorage()._keyspace = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// CassandraExecute is emitted when a Cassandra client executes a CQL statement.
struct Events_CassandraExecute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// QueryId is the prepared query id to execute.
  var queryID: String {
    get {return _storage._queryID}
    set {_uniqueStorage()._queryID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// CassandraBatch is emitted when a Cassandra client executes a batch of CQL statements.
struct Events_CassandraBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// Consistency is the consistency level to use.
  var consistency: String {
    get {return _storage._consistency}
    set {_uniqueStorage()._consistency = newValue}
  }

  /// Keyspace is the keyspace the statement is in.
  var keyspace: String {
    get {return _storage._keyspace}
    set {_uniqueStorage()._keyspace = newValue}
  }

  /// BatchType is the type of batch.
  var batchType: String {
    get {return _storage._batchType}
    set {_uniqueStorage()._batchType = newValue}
  }

  /// Children is batch children statements.
  var children: [Events_CassandraBatch.BatchChild] {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// BatchChild represents a single child batch statement.
  struct BatchChild {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID is the id of the statement.
    var id: String = String()

    /// Query the CQL statement to execute.
    var query: String = String()

    /// Values is the values to bind to the query.
    var values: [Events_CassandraBatch.BatchChild.Value] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Value is a single value to bind to the query.
    struct Value {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Type is the type of the value.
      var type: UInt32 = 0

      /// Contents is the value contents.
      var contents: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// CassandraRegister is emitted when a Cassandra client
/// request to register for the specified event types.
struct Events_CassandraRegister {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is a common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is a common event session metadata.
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Database contains database related metadata.
  var database: Events_DatabaseMetadata {
    get {return _storage._database ?? Events_DatabaseMetadata()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// EventTypes is the list of event types to register for.
  var eventTypes: [String] {
    get {return _storage._eventTypes}
    set {_uniqueStorage()._eventTypes = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LoginRuleCreate is emitted when a login rule is created or updated.
struct Events_LoginRuleCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LoginRuleDelete is emitted when a login rule is deleted
struct Events_LoginRuleDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is a common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// User is a common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SAMLIdPAuthAttempt is emitted when a user has attempted to authorize against the SAML IdP.
struct Events_SAMLIdPAuthAttempt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is common user event metadata
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// SessionMetadata is common event session metadata
  var session: Events_SessionMetadata {
    get {return _storage._session ?? Events_SessionMetadata()}
    set {_uniqueStorage()._session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return _storage._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {_uniqueStorage()._session = nil}

  /// Status indicates whether the SAML IdP authentication was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
  var serviceProvider: Events_SAMLIdPServiceProviderMetadata {
    get {return _storage._serviceProvider ?? Events_SAMLIdPServiceProviderMetadata()}
    set {_uniqueStorage()._serviceProvider = newValue}
  }
  /// Returns true if `serviceProvider` has been explicitly set.
  var hasServiceProvider: Bool {return _storage._serviceProvider != nil}
  /// Clears the value of `serviceProvider`. Subsequent reads from it will return its default value.
  mutating func clearServiceProvider() {_uniqueStorage()._serviceProvider = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SAMLIdPServiceProviderCreate is emitted when a service provider has been added.
struct Events_SAMLIdPServiceProviderCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// ResourceMetadata is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _resource ?? Events_ResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  /// SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
  var serviceProvider: Events_SAMLIdPServiceProviderMetadata {
    get {return _serviceProvider ?? Events_SAMLIdPServiceProviderMetadata()}
    set {_serviceProvider = newValue}
  }
  /// Returns true if `serviceProvider` has been explicitly set.
  var hasServiceProvider: Bool {return self._serviceProvider != nil}
  /// Clears the value of `serviceProvider`. Subsequent reads from it will return its default value.
  mutating func clearServiceProvider() {self._serviceProvider = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _resource: Events_ResourceMetadata? = nil
  fileprivate var _serviceProvider: Events_SAMLIdPServiceProviderMetadata? = nil
}

/// SAMLIdPServiceProviderUpdate is emitted when a service provider has been updated.
struct Events_SAMLIdPServiceProviderUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// ResourceMetadata is a common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _resource ?? Events_ResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  /// SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
  var serviceProvider: Events_SAMLIdPServiceProviderMetadata {
    get {return _serviceProvider ?? Events_SAMLIdPServiceProviderMetadata()}
    set {_serviceProvider = newValue}
  }
  /// Returns true if `serviceProvider` has been explicitly set.
  var hasServiceProvider: Bool {return self._serviceProvider != nil}
  /// Clears the value of `serviceProvider`. Subsequent reads from it will return its default value.
  mutating func clearServiceProvider() {self._serviceProvider = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _resource: Events_ResourceMetadata? = nil
  fileprivate var _serviceProvider: Events_SAMLIdPServiceProviderMetadata? = nil
}

/// SAMLIdPServiceProviderDelete is emitted when a service provider has been deleted.
struct Events_SAMLIdPServiceProviderDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// ResourceMetadata is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _resource ?? Events_ResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  /// SAMLIdPServiceProviderMetadata is common SAML IdP service provider event metadata
  var serviceProvider: Events_SAMLIdPServiceProviderMetadata {
    get {return _serviceProvider ?? Events_SAMLIdPServiceProviderMetadata()}
    set {_serviceProvider = newValue}
  }
  /// Returns true if `serviceProvider` has been explicitly set.
  var hasServiceProvider: Bool {return self._serviceProvider != nil}
  /// Clears the value of `serviceProvider`. Subsequent reads from it will return its default value.
  mutating func clearServiceProvider() {self._serviceProvider = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _resource: Events_ResourceMetadata? = nil
  fileprivate var _serviceProvider: Events_SAMLIdPServiceProviderMetadata? = nil
}

/// SAMLIdPServiceProviderDeleteAll is emitted when all service providers have been deleted.
struct Events_SAMLIdPServiceProviderDeleteAll {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// ResourceMetadata is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _resource ?? Events_ResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _resource: Events_ResourceMetadata? = nil
}

/// OktaResourcesUpdate is emitted when Okta related resources have been updated.
struct Events_OktaResourcesUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Server is a common server metadata.
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// Updated is common metadata related to Okta resources being updated.
  var updated: Events_OktaResourcesUpdatedMetadata {
    get {return _storage._updated ?? Events_OktaResourcesUpdatedMetadata()}
    set {_uniqueStorage()._updated = newValue}
  }
  /// Returns true if `updated` has been explicitly set.
  var hasUpdated: Bool {return _storage._updated != nil}
  /// Clears the value of `updated`. Subsequent reads from it will return its default value.
  mutating func clearUpdated() {_uniqueStorage()._updated = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OktaSyncFailure is emitted when an Okta synchronization attempt has failed.
struct Events_OktaSyncFailure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Server is a common server metadata.
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// Status contains error information for the synchronization failure.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OktaAssignmentResult is emitted when an Okta assignment processing or cleanup was attempted.
struct Events_OktaAssignmentResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Server is a common server metadata.
  var server: Events_ServerMetadata {
    get {return _storage._server ?? Events_ServerMetadata()}
    set {_uniqueStorage()._server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  var hasServer: Bool {return _storage._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  mutating func clearServer() {_uniqueStorage()._server = nil}

  /// ResourceMetadata is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// Status indicates whether the assignment processing was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// OktaAssignmentMetadata is common Okta assignment metadata.
  var oktaAssignment: Events_OktaAssignmentMetadata {
    get {return _storage._oktaAssignment ?? Events_OktaAssignmentMetadata()}
    set {_uniqueStorage()._oktaAssignment = newValue}
  }
  /// Returns true if `oktaAssignment` has been explicitly set.
  var hasOktaAssignment: Bool {return _storage._oktaAssignment != nil}
  /// Clears the value of `oktaAssignment`. Subsequent reads from it will return its default value.
  mutating func clearOktaAssignment() {_uniqueStorage()._oktaAssignment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AccessListCreate is emitted when an access list is created.
struct Events_AccessListCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Resource is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _resource ?? Events_ResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  /// Status indicates whether the resource operation was successful.
  var status: Events_Status {
    get {return _status ?? Events_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _resource: Events_ResourceMetadata? = nil
  fileprivate var _status: Events_Status? = nil
}

/// AccessListUpdate is emitted when an access list is updated.
struct Events_AccessListUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Resource is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _resource ?? Events_ResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  /// Status indicates whether the resource operation was successful.
  var status: Events_Status {
    get {return _status ?? Events_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _resource: Events_ResourceMetadata? = nil
  fileprivate var _status: Events_Status? = nil
}

/// AccessListDelete is emitted when an access list is deleted.
struct Events_AccessListDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _metadata ?? Events_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Resource is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _resource ?? Events_ResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  /// Status indicates whether the resource operation was successful.
  var status: Events_Status {
    get {return _status ?? Events_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Events_Metadata? = nil
  fileprivate var _resource: Events_ResourceMetadata? = nil
  fileprivate var _status: Events_Status? = nil
}

/// AccessListMemberCreate is emitted when an access list member is created.
struct Events_AccessListMemberCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Resource is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// AccessListMember is common access list member metadata.
  var accessListMember: Events_AccessListMemberMetadata {
    get {return _storage._accessListMember ?? Events_AccessListMemberMetadata()}
    set {_uniqueStorage()._accessListMember = newValue}
  }
  /// Returns true if `accessListMember` has been explicitly set.
  var hasAccessListMember: Bool {return _storage._accessListMember != nil}
  /// Clears the value of `accessListMember`. Subsequent reads from it will return its default value.
  mutating func clearAccessListMember() {_uniqueStorage()._accessListMember = nil}

  /// Status indicates whether the resource operation was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AccessListMemberUpdate is emitted when an access list member is updated.
struct Events_AccessListMemberUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Resource is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// AccessListMember is common access list member metadata.
  var accessListMember: Events_AccessListMemberMetadata {
    get {return _storage._accessListMember ?? Events_AccessListMemberMetadata()}
    set {_uniqueStorage()._accessListMember = newValue}
  }
  /// Returns true if `accessListMember` has been explicitly set.
  var hasAccessListMember: Bool {return _storage._accessListMember != nil}
  /// Clears the value of `accessListMember`. Subsequent reads from it will return its default value.
  mutating func clearAccessListMember() {_uniqueStorage()._accessListMember = nil}

  /// Status indicates whether the resource operation was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AccessListMemberDelete is emitted when an access list member is deleted.
struct Events_AccessListMemberDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Resource is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// AccessListMember is common access list member metadata.
  var accessListMember: Events_AccessListMemberMetadata {
    get {return _storage._accessListMember ?? Events_AccessListMemberMetadata()}
    set {_uniqueStorage()._accessListMember = newValue}
  }
  /// Returns true if `accessListMember` has been explicitly set.
  var hasAccessListMember: Bool {return _storage._accessListMember != nil}
  /// Clears the value of `accessListMember`. Subsequent reads from it will return its default value.
  mutating func clearAccessListMember() {_uniqueStorage()._accessListMember = nil}

  /// Status indicates whether the resource operation was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AccessListMemberDeleteAllForAccessList is emitted when all members are deleted for an access list.
struct Events_AccessListMemberDeleteAllForAccessList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Resource is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// AccessListMember is common access list member metadata.
  var accessListMember: Events_AccessListMemberMetadata {
    get {return _storage._accessListMember ?? Events_AccessListMemberMetadata()}
    set {_uniqueStorage()._accessListMember = newValue}
  }
  /// Returns true if `accessListMember` has been explicitly set.
  var hasAccessListMember: Bool {return _storage._accessListMember != nil}
  /// Clears the value of `accessListMember`. Subsequent reads from it will return its default value.
  mutating func clearAccessListMember() {_uniqueStorage()._accessListMember = nil}

  /// Status indicates whether the resource operation was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AccessListReview is emitted when an access list is reviewed.
struct Events_AccessListReview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Resource is common resource event metadata
  var resource: Events_ResourceMetadata {
    get {return _storage._resource ?? Events_ResourceMetadata()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// Review is metadata for the access list review.
  var review: Events_AccessListReviewMetadata {
    get {return _storage._review ?? Events_AccessListReviewMetadata()}
    set {_uniqueStorage()._review = newValue}
  }
  /// Returns true if `review` has been explicitly set.
  var hasReview: Bool {return _storage._review != nil}
  /// Clears the value of `review`. Subsequent reads from it will return its default value.
  mutating func clearReview() {_uniqueStorage()._review = nil}

  /// Status indicates whether the review operation was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AuditQueryRun is emitted when a user runs an audit query.
struct Events_AuditQueryRun {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Status indicates whether the read was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Query contains additional query information.
  var query: Events_AuditQueryDetails {
    get {return _storage._query ?? Events_AuditQueryDetails()}
    set {_uniqueStorage()._query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  var hasQuery: Bool {return _storage._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  mutating func clearQuery() {_uniqueStorage()._query = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AuditQueryDetails contains additional query information.
struct Events_AuditQueryDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the query.
  var name: String = String()

  /// Query is the query that was run.
  var query: String = String()

  /// Days is the number of days time range for the query.
  var days: Int32 = 0

  /// ExecutionTimeInMillis is the total execution time of the query.
  var executionTimeInMillis: Int64 = 0

  /// DataScannedInBytes is the amount of data scanned by the query.
  var dataScannedInBytes: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SecurityReportRun is emitted when a user runs an audit query.
struct Events_SecurityReportRun {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is common event metadata.
  var metadata: Events_Metadata {
    get {return _storage._metadata ?? Events_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// User is common user event metadata.
  var user: Events_UserMetadata {
    get {return _storage._user ?? Events_UserMetadata()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  /// Status indicates whether the read was successful.
  var status: Events_Status {
    get {return _storage._status ?? Events_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Query is the query that was run.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Version is the version of security report.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// TotalExecutionTimeInMillis is the total execution time of the query.
  var totalExecutionTimeInMillis: Int64 {
    get {return _storage._totalExecutionTimeInMillis}
    set {_uniqueStorage()._totalExecutionTimeInMillis = newValue}
  }

  /// TotalDataScannedInBytes is the amount of data scanned by the query.
  var totalDataScannedInBytes: Int64 {
    get {return _storage._totalDataScannedInBytes}
    set {_uniqueStorage()._totalDataScannedInBytes = newValue}
  }

  /// AuditQueries is the list of audit queries that were run.
  var auditQueries: [Events_AuditQueryDetails] {
    get {return _storage._auditQueries}
    set {_uniqueStorage()._auditQueries = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Events_EventAction: @unchecked Sendable {}
extension Events_SFTPAction: @unchecked Sendable {}
extension Events_OSType: @unchecked Sendable {}
extension Events_DeviceOrigin: @unchecked Sendable {}
extension Events_ElasticsearchCategory: @unchecked Sendable {}
extension Events_OpenSearchCategory: @unchecked Sendable {}
extension Events_Metadata: @unchecked Sendable {}
extension Events_SessionMetadata: @unchecked Sendable {}
extension Events_UserMetadata: @unchecked Sendable {}
extension Events_ServerMetadata: @unchecked Sendable {}
extension Events_ConnectionMetadata: @unchecked Sendable {}
extension Events_ClientMetadata: @unchecked Sendable {}
extension Events_KubernetesClusterMetadata: @unchecked Sendable {}
extension Events_KubernetesPodMetadata: @unchecked Sendable {}
extension Events_SAMLIdPServiceProviderMetadata: @unchecked Sendable {}
extension Events_OktaResourcesUpdatedMetadata: @unchecked Sendable {}
extension Events_OktaResource: @unchecked Sendable {}
extension Events_OktaAssignmentMetadata: @unchecked Sendable {}
extension Events_AccessListMemberMetadata: @unchecked Sendable {}
extension Events_AccessListMember: @unchecked Sendable {}
extension Events_AccessListReviewMembershipRequirementsChanged: @unchecked Sendable {}
extension Events_AccessListReviewMetadata: @unchecked Sendable {}
extension Events_SessionStart: @unchecked Sendable {}
extension Events_SessionJoin: @unchecked Sendable {}
extension Events_SessionPrint: @unchecked Sendable {}
extension Events_DesktopRecording: @unchecked Sendable {}
extension Events_DesktopClipboardReceive: @unchecked Sendable {}
extension Events_DesktopClipboardSend: @unchecked Sendable {}
extension Events_DesktopSharedDirectoryStart: @unchecked Sendable {}
extension Events_DesktopSharedDirectoryRead: @unchecked Sendable {}
extension Events_DesktopSharedDirectoryWrite: @unchecked Sendable {}
extension Events_SessionReject: @unchecked Sendable {}
extension Events_SessionConnect: @unchecked Sendable {}
extension Events_FileTransferRequestEvent: @unchecked Sendable {}
extension Events_Resize: @unchecked Sendable {}
extension Events_SessionEnd: @unchecked Sendable {}
extension Events_BPFMetadata: @unchecked Sendable {}
extension Events_Status: @unchecked Sendable {}
extension Events_SessionCommand: @unchecked Sendable {}
extension Events_SessionDisk: @unchecked Sendable {}
extension Events_SessionNetwork: @unchecked Sendable {}
extension Events_SessionNetwork.NetworkOperation: @unchecked Sendable {}
extension Events_SessionData: @unchecked Sendable {}
extension Events_SessionLeave: @unchecked Sendable {}
extension Events_UserLogin: @unchecked Sendable {}
extension Events_ResourceMetadata: @unchecked Sendable {}
extension Events_UserCreate: @unchecked Sendable {}
extension Events_UserUpdate: @unchecked Sendable {}
extension Events_UserDelete: @unchecked Sendable {}
extension Events_UserPasswordChange: @unchecked Sendable {}
extension Events_AccessRequestCreate: @unchecked Sendable {}
extension Events_ResourceID: @unchecked Sendable {}
extension Events_AccessRequestDelete: @unchecked Sendable {}
extension Events_PortForward: @unchecked Sendable {}
extension Events_X11Forward: @unchecked Sendable {}
extension Events_CommandMetadata: @unchecked Sendable {}
extension Events_Exec: @unchecked Sendable {}
extension Events_SCP: @unchecked Sendable {}
extension Events_SFTPAttributes: @unchecked Sendable {}
extension Events_SFTP: @unchecked Sendable {}
extension Events_Subsystem: @unchecked Sendable {}
extension Events_ClientDisconnect: @unchecked Sendable {}
extension Events_AuthAttempt: @unchecked Sendable {}
extension Events_UserTokenCreate: @unchecked Sendable {}
extension Events_RoleCreate: @unchecked Sendable {}
extension Events_RoleUpdate: @unchecked Sendable {}
extension Events_RoleDelete: @unchecked Sendable {}
extension Events_TrustedClusterCreate: @unchecked Sendable {}
extension Events_TrustedClusterDelete: @unchecked Sendable {}
extension Events_ProvisionTokenCreate: @unchecked Sendable {}
extension Events_TrustedClusterTokenCreate: @unchecked Sendable {}
extension Events_GithubConnectorCreate: @unchecked Sendable {}
extension Events_GithubConnectorUpdate: @unchecked Sendable {}
extension Events_GithubConnectorDelete: @unchecked Sendable {}
extension Events_OIDCConnectorCreate: @unchecked Sendable {}
extension Events_OIDCConnectorUpdate: @unchecked Sendable {}
extension Events_OIDCConnectorDelete: @unchecked Sendable {}
extension Events_SAMLConnectorCreate: @unchecked Sendable {}
extension Events_SAMLConnectorUpdate: @unchecked Sendable {}
extension Events_SAMLConnectorDelete: @unchecked Sendable {}
extension Events_KubeRequest: @unchecked Sendable {}
extension Events_AppMetadata: @unchecked Sendable {}
extension Events_AppCreate: @unchecked Sendable {}
extension Events_AppUpdate: @unchecked Sendable {}
extension Events_AppDelete: @unchecked Sendable {}
extension Events_AppSessionStart: @unchecked Sendable {}
extension Events_AppSessionEnd: @unchecked Sendable {}
extension Events_AppSessionChunk: @unchecked Sendable {}
extension Events_AppSessionRequest: @unchecked Sendable {}
extension Events_AWSRequestMetadata: @unchecked Sendable {}
extension Events_DatabaseMetadata: @unchecked Sendable {}
extension Events_DatabaseCreate: @unchecked Sendable {}
extension Events_DatabaseUpdate: @unchecked Sendable {}
extension Events_DatabaseDelete: @unchecked Sendable {}
extension Events_DatabaseSessionStart: @unchecked Sendable {}
extension Events_DatabaseSessionQuery: @unchecked Sendable {}
extension Events_PostgresParse: @unchecked Sendable {}
extension Events_PostgresBind: @unchecked Sendable {}
extension Events_PostgresExecute: @unchecked Sendable {}
extension Events_PostgresClose: @unchecked Sendable {}
extension Events_PostgresFunctionCall: @unchecked Sendable {}
extension Events_WindowsDesktopSessionStart: @unchecked Sendable {}
extension Events_DatabaseSessionEnd: @unchecked Sendable {}
extension Events_MFADeviceMetadata: @unchecked Sendable {}
extension Events_MFADeviceAdd: @unchecked Sendable {}
extension Events_MFADeviceDelete: @unchecked Sendable {}
extension Events_BillingInformationUpdate: @unchecked Sendable {}
extension Events_BillingCardCreate: @unchecked Sendable {}
extension Events_BillingCardDelete: @unchecked Sendable {}
extension Events_LockCreate: @unchecked Sendable {}
extension Events_LockDelete: @unchecked Sendable {}
extension Events_RecoveryCodeGenerate: @unchecked Sendable {}
extension Events_RecoveryCodeUsed: @unchecked Sendable {}
extension Events_WindowsDesktopSessionEnd: @unchecked Sendable {}
extension Events_CertificateCreate: @unchecked Sendable {}
extension Events_RenewableCertificateGenerationMismatch: @unchecked Sendable {}
extension Events_BotJoin: @unchecked Sendable {}
extension Events_InstanceJoin: @unchecked Sendable {}
extension Events_Unknown: @unchecked Sendable {}
extension Events_DeviceMetadata: @unchecked Sendable {}
extension Events_DeviceEvent: @unchecked Sendable {}
extension Events_DeviceEvent2: @unchecked Sendable {}
extension Events_OneOf: @unchecked Sendable {}
extension Events_OneOf.OneOf_Event: @unchecked Sendable {}
extension Events_StreamStatus: @unchecked Sendable {}
extension Events_SessionUpload: @unchecked Sendable {}
extension Events_Identity: @unchecked Sendable {}
extension Events_RouteToApp: @unchecked Sendable {}
extension Events_RouteToDatabase: @unchecked Sendable {}
extension Events_AccessRequestResourceSearch: @unchecked Sendable {}
extension Events_MySQLStatementPrepare: @unchecked Sendable {}
extension Events_MySQLStatementExecute: @unchecked Sendable {}
extension Events_MySQLStatementSendLongData: @unchecked Sendable {}
extension Events_MySQLStatementClose: @unchecked Sendable {}
extension Events_MySQLStatementReset: @unchecked Sendable {}
extension Events_MySQLStatementFetch: @unchecked Sendable {}
extension Events_MySQLStatementBulkExecute: @unchecked Sendable {}
extension Events_MySQLInitDB: @unchecked Sendable {}
extension Events_MySQLCreateDB: @unchecked Sendable {}
extension Events_MySQLDropDB: @unchecked Sendable {}
extension Events_MySQLShutDown: @unchecked Sendable {}
extension Events_MySQLProcessKill: @unchecked Sendable {}
extension Events_MySQLDebug: @unchecked Sendable {}
extension Events_MySQLRefresh: @unchecked Sendable {}
extension Events_SQLServerRPCRequest: @unchecked Sendable {}
extension Events_DatabaseSessionMalformedPacket: @unchecked Sendable {}
extension Events_ElasticsearchRequest: @unchecked Sendable {}
extension Events_OpenSearchRequest: @unchecked Sendable {}
extension Events_DynamoDBRequest: @unchecked Sendable {}
extension Events_AppSessionDynamoDBRequest: @unchecked Sendable {}
extension Events_UpgradeWindowStartMetadata: @unchecked Sendable {}
extension Events_UpgradeWindowStartUpdate: @unchecked Sendable {}
extension Events_SessionRecordingAccess: @unchecked Sendable {}
extension Events_KubeClusterMetadata: @unchecked Sendable {}
extension Events_KubernetesClusterCreate: @unchecked Sendable {}
extension Events_KubernetesClusterUpdate: @unchecked Sendable {}
extension Events_KubernetesClusterDelete: @unchecked Sendable {}
extension Events_SSMRun: @unchecked Sendable {}
extension Events_CassandraPrepare: @unchecked Sendable {}
extension Events_CassandraExecute: @unchecked Sendable {}
extension Events_CassandraBatch: @unchecked Sendable {}
extension Events_CassandraBatch.BatchChild: @unchecked Sendable {}
extension Events_CassandraBatch.BatchChild.Value: @unchecked Sendable {}
extension Events_CassandraRegister: @unchecked Sendable {}
extension Events_LoginRuleCreate: @unchecked Sendable {}
extension Events_LoginRuleDelete: @unchecked Sendable {}
extension Events_SAMLIdPAuthAttempt: @unchecked Sendable {}
extension Events_SAMLIdPServiceProviderCreate: @unchecked Sendable {}
extension Events_SAMLIdPServiceProviderUpdate: @unchecked Sendable {}
extension Events_SAMLIdPServiceProviderDelete: @unchecked Sendable {}
extension Events_SAMLIdPServiceProviderDeleteAll: @unchecked Sendable {}
extension Events_OktaResourcesUpdate: @unchecked Sendable {}
extension Events_OktaSyncFailure: @unchecked Sendable {}
extension Events_OktaAssignmentResult: @unchecked Sendable {}
extension Events_AccessListCreate: @unchecked Sendable {}
extension Events_AccessListUpdate: @unchecked Sendable {}
extension Events_AccessListDelete: @unchecked Sendable {}
extension Events_AccessListMemberCreate: @unchecked Sendable {}
extension Events_AccessListMemberUpdate: @unchecked Sendable {}
extension Events_AccessListMemberDelete: @unchecked Sendable {}
extension Events_AccessListMemberDeleteAllForAccessList: @unchecked Sendable {}
extension Events_AccessListReview: @unchecked Sendable {}
extension Events_AuditQueryRun: @unchecked Sendable {}
extension Events_AuditQueryDetails: @unchecked Sendable {}
extension Events_SecurityReportRun: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "events"

extension Events_EventAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OBSERVED"),
    1: .same(proto: "DENIED"),
  ]
}

extension Events_SFTPAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID"),
    1: .same(proto: "OPEN"),
    2: .same(proto: "CLOSE"),
    3: .same(proto: "READ"),
    4: .same(proto: "WRITE"),
    5: .same(proto: "LSTAT"),
    6: .same(proto: "FSTAT"),
    7: .same(proto: "SETSTAT"),
    8: .same(proto: "FSETSTAT"),
    9: .same(proto: "OPENDIR"),
    10: .same(proto: "READDIR"),
    11: .same(proto: "REMOVE"),
    12: .same(proto: "MKDIR"),
    13: .same(proto: "RMDIR"),
    14: .same(proto: "REALPATH"),
    15: .same(proto: "STAT"),
    16: .same(proto: "RENAME"),
    17: .same(proto: "READLINK"),
    18: .same(proto: "SYMLINK"),
    19: .same(proto: "LINK"),
  ]
}

extension Events_OSType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OS_TYPE_UNSPECIFIED"),
    1: .same(proto: "OS_TYPE_LINUX"),
    2: .same(proto: "OS_TYPE_MACOS"),
    3: .same(proto: "OS_TYPE_WINDOWS"),
  ]
}

extension Events_DeviceOrigin: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_ORIGIN_UNSPECIFIED"),
    1: .same(proto: "DEVICE_ORIGIN_API"),
    2: .same(proto: "DEVICE_ORIGIN_JAMF"),
    3: .same(proto: "DEVICE_ORIGIN_INTUNE"),
  ]
}

extension Events_ElasticsearchCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ELASTICSEARCH_CATEGORY_GENERAL"),
    1: .same(proto: "ELASTICSEARCH_CATEGORY_SECURITY"),
    2: .same(proto: "ELASTICSEARCH_CATEGORY_SEARCH"),
    3: .same(proto: "ELASTICSEARCH_CATEGORY_SQL"),
  ]
}

extension Events_OpenSearchCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPEN_SEARCH_CATEGORY_GENERAL"),
    1: .same(proto: "OPEN_SEARCH_CATEGORY_SECURITY"),
    2: .same(proto: "OPEN_SEARCH_CATEGORY_SEARCH"),
    3: .same(proto: "OPEN_SEARCH_CATEGORY_SQL"),
  ]
}

extension Events_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Metadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Index"),
    2: .same(proto: "Type"),
    3: .same(proto: "ID"),
    4: .same(proto: "Code"),
    5: .same(proto: "Time"),
    6: .same(proto: "ClusterName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 4)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_Metadata, rhs: Events_Metadata) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.code != rhs.code {return false}
    if lhs._time != rhs._time {return false}
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
    2: .same(proto: "WithMFA"),
    3: .same(proto: "PrivateKeyPolicy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.withMfa) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.privateKeyPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.withMfa.isEmpty {
      try visitor.visitSingularStringField(value: self.withMfa, fieldNumber: 2)
    }
    if !self.privateKeyPolicy.isEmpty {
      try visitor.visitSingularStringField(value: self.privateKeyPolicy, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionMetadata, rhs: Events_SessionMetadata) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.withMfa != rhs.withMfa {return false}
    if lhs.privateKeyPolicy != rhs.privateKeyPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_UserMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "Login"),
    3: .same(proto: "Impersonator"),
    4: .same(proto: "AWSRoleARN"),
    5: .same(proto: "AccessRequests"),
    6: .same(proto: "AzureIdentity"),
    7: .same(proto: "GCPServiceAccount"),
    8: .same(proto: "TrustedDevice"),
    9: .same(proto: "RequiredPrivateKeyPolicy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.login) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.impersonator) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.awsroleArn) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.accessRequests) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.azureIdentity) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.gcpserviceAccount) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._trustedDevice) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.requiredPrivateKeyPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.login.isEmpty {
      try visitor.visitSingularStringField(value: self.login, fieldNumber: 2)
    }
    if !self.impersonator.isEmpty {
      try visitor.visitSingularStringField(value: self.impersonator, fieldNumber: 3)
    }
    if !self.awsroleArn.isEmpty {
      try visitor.visitSingularStringField(value: self.awsroleArn, fieldNumber: 4)
    }
    if !self.accessRequests.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accessRequests, fieldNumber: 5)
    }
    if !self.azureIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.azureIdentity, fieldNumber: 6)
    }
    if !self.gcpserviceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.gcpserviceAccount, fieldNumber: 7)
    }
    try { if let v = self._trustedDevice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.requiredPrivateKeyPolicy.isEmpty {
      try visitor.visitSingularStringField(value: self.requiredPrivateKeyPolicy, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_UserMetadata, rhs: Events_UserMetadata) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.login != rhs.login {return false}
    if lhs.impersonator != rhs.impersonator {return false}
    if lhs.awsroleArn != rhs.awsroleArn {return false}
    if lhs.accessRequests != rhs.accessRequests {return false}
    if lhs.azureIdentity != rhs.azureIdentity {return false}
    if lhs.gcpserviceAccount != rhs.gcpserviceAccount {return false}
    if lhs._trustedDevice != rhs._trustedDevice {return false}
    if lhs.requiredPrivateKeyPolicy != rhs.requiredPrivateKeyPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ServerMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServerNamespace"),
    2: .same(proto: "ServerID"),
    3: .same(proto: "ServerHostname"),
    4: .same(proto: "ServerAddr"),
    5: .same(proto: "ServerLabels"),
    6: .same(proto: "ForwardedBy"),
    7: .same(proto: "ServerSubKind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverNamespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serverHostname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serverAddr) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.serverLabels) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.forwardedBy) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.serverSubKind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverNamespace.isEmpty {
      try visitor.visitSingularStringField(value: self.serverNamespace, fieldNumber: 1)
    }
    if !self.serverID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverID, fieldNumber: 2)
    }
    if !self.serverHostname.isEmpty {
      try visitor.visitSingularStringField(value: self.serverHostname, fieldNumber: 3)
    }
    if !self.serverAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.serverAddr, fieldNumber: 4)
    }
    if !self.serverLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.serverLabels, fieldNumber: 5)
    }
    if !self.forwardedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.forwardedBy, fieldNumber: 6)
    }
    if !self.serverSubKind.isEmpty {
      try visitor.visitSingularStringField(value: self.serverSubKind, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_ServerMetadata, rhs: Events_ServerMetadata) -> Bool {
    if lhs.serverNamespace != rhs.serverNamespace {return false}
    if lhs.serverID != rhs.serverID {return false}
    if lhs.serverHostname != rhs.serverHostname {return false}
    if lhs.serverAddr != rhs.serverAddr {return false}
    if lhs.serverLabels != rhs.serverLabels {return false}
    if lhs.forwardedBy != rhs.forwardedBy {return false}
    if lhs.serverSubKind != rhs.serverSubKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ConnectionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LocalAddr"),
    2: .same(proto: "RemoteAddr"),
    3: .same(proto: "Protocol"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localAddr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.remoteAddr) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.localAddr, fieldNumber: 1)
    }
    if !self.remoteAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteAddr, fieldNumber: 2)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_ConnectionMetadata, rhs: Events_ConnectionMetadata) -> Bool {
    if lhs.localAddr != rhs.localAddr {return false}
    if lhs.remoteAddr != rhs.remoteAddr {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ClientMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserAgent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_ClientMetadata, rhs: Events_ClientMetadata) -> Bool {
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_KubernetesClusterMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesClusterMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "KubernetesCluster"),
    2: .same(proto: "KubernetesUsers"),
    3: .same(proto: "KubernetesGroups"),
    4: .same(proto: "KubernetesLabels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kubernetesCluster) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.kubernetesUsers) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.kubernetesGroups) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.kubernetesLabels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kubernetesCluster.isEmpty {
      try visitor.visitSingularStringField(value: self.kubernetesCluster, fieldNumber: 1)
    }
    if !self.kubernetesUsers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kubernetesUsers, fieldNumber: 2)
    }
    if !self.kubernetesGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kubernetesGroups, fieldNumber: 3)
    }
    if !self.kubernetesLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.kubernetesLabels, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_KubernetesClusterMetadata, rhs: Events_KubernetesClusterMetadata) -> Bool {
    if lhs.kubernetesCluster != rhs.kubernetesCluster {return false}
    if lhs.kubernetesUsers != rhs.kubernetesUsers {return false}
    if lhs.kubernetesGroups != rhs.kubernetesGroups {return false}
    if lhs.kubernetesLabels != rhs.kubernetesLabels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_KubernetesPodMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesPodMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "KubernetesPodName"),
    2: .same(proto: "KubernetesPodNamespace"),
    3: .same(proto: "KubernetesContainerName"),
    4: .same(proto: "KubernetesContainerImage"),
    5: .same(proto: "KubernetesNodeName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kubernetesPodName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kubernetesPodNamespace) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.kubernetesContainerName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.kubernetesContainerImage) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.kubernetesNodeName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kubernetesPodName.isEmpty {
      try visitor.visitSingularStringField(value: self.kubernetesPodName, fieldNumber: 1)
    }
    if !self.kubernetesPodNamespace.isEmpty {
      try visitor.visitSingularStringField(value: self.kubernetesPodNamespace, fieldNumber: 2)
    }
    if !self.kubernetesContainerName.isEmpty {
      try visitor.visitSingularStringField(value: self.kubernetesContainerName, fieldNumber: 3)
    }
    if !self.kubernetesContainerImage.isEmpty {
      try visitor.visitSingularStringField(value: self.kubernetesContainerImage, fieldNumber: 4)
    }
    if !self.kubernetesNodeName.isEmpty {
      try visitor.visitSingularStringField(value: self.kubernetesNodeName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_KubernetesPodMetadata, rhs: Events_KubernetesPodMetadata) -> Bool {
    if lhs.kubernetesPodName != rhs.kubernetesPodName {return false}
    if lhs.kubernetesPodNamespace != rhs.kubernetesPodNamespace {return false}
    if lhs.kubernetesContainerName != rhs.kubernetesContainerName {return false}
    if lhs.kubernetesContainerImage != rhs.kubernetesContainerImage {return false}
    if lhs.kubernetesNodeName != rhs.kubernetesNodeName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SAMLIdPServiceProviderMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLIdPServiceProviderMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServiceProviderEntityID"),
    2: .same(proto: "ServiceProviderShortcut"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceProviderEntityID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceProviderShortcut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceProviderEntityID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceProviderEntityID, fieldNumber: 1)
    }
    if !self.serviceProviderShortcut.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceProviderShortcut, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SAMLIdPServiceProviderMetadata, rhs: Events_SAMLIdPServiceProviderMetadata) -> Bool {
    if lhs.serviceProviderEntityID != rhs.serviceProviderEntityID {return false}
    if lhs.serviceProviderShortcut != rhs.serviceProviderShortcut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OktaResourcesUpdatedMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaResourcesUpdatedMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Added"),
    2: .same(proto: "Updated"),
    3: .same(proto: "Deleted"),
    4: .same(proto: "AddedResources"),
    5: .same(proto: "UpdatedResources"),
    6: .same(proto: "DeletedResources"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.added) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.updated) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.deleted) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.addedResources) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.updatedResources) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.deletedResources) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.added != 0 {
      try visitor.visitSingularInt32Field(value: self.added, fieldNumber: 1)
    }
    if self.updated != 0 {
      try visitor.visitSingularInt32Field(value: self.updated, fieldNumber: 2)
    }
    if self.deleted != 0 {
      try visitor.visitSingularInt32Field(value: self.deleted, fieldNumber: 3)
    }
    if !self.addedResources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addedResources, fieldNumber: 4)
    }
    if !self.updatedResources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updatedResources, fieldNumber: 5)
    }
    if !self.deletedResources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deletedResources, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OktaResourcesUpdatedMetadata, rhs: Events_OktaResourcesUpdatedMetadata) -> Bool {
    if lhs.added != rhs.added {return false}
    if lhs.updated != rhs.updated {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs.addedResources != rhs.addedResources {return false}
    if lhs.updatedResources != rhs.updatedResources {return false}
    if lhs.deletedResources != rhs.deletedResources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OktaResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "Description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OktaResource, rhs: Events_OktaResource) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OktaAssignmentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaAssignmentMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Source"),
    2: .same(proto: "User"),
    3: .same(proto: "StartingStatus"),
    4: .same(proto: "EndingStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.startingStatus) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.endingStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 2)
    }
    if !self.startingStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.startingStatus, fieldNumber: 3)
    }
    if !self.endingStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.endingStatus, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OktaAssignmentMetadata, rhs: Events_OktaAssignmentMetadata) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.user != rhs.user {return false}
    if lhs.startingStatus != rhs.startingStatus {return false}
    if lhs.endingStatus != rhs.endingStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListMemberMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListMemberMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AccessListName"),
    2: .same(proto: "Members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessListName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessListName.isEmpty {
      try visitor.visitSingularStringField(value: self.accessListName, fieldNumber: 1)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListMemberMetadata, rhs: Events_AccessListMemberMetadata) -> Bool {
    if lhs.accessListName != rhs.accessListName {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListMember"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JoinedOn"),
    2: .same(proto: "RemovedOn"),
    3: .same(proto: "Reason"),
    4: .same(proto: "MemberName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._joinedOn) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._removedOn) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.memberName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._joinedOn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._removedOn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    if !self.memberName.isEmpty {
      try visitor.visitSingularStringField(value: self.memberName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListMember, rhs: Events_AccessListMember) -> Bool {
    if lhs._joinedOn != rhs._joinedOn {return false}
    if lhs._removedOn != rhs._removedOn {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.memberName != rhs.memberName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListReviewMembershipRequirementsChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListReviewMembershipRequirementsChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Roles"),
    2: .same(proto: "Traits"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.traits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    if !self.traits.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.traits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListReviewMembershipRequirementsChanged, rhs: Events_AccessListReviewMembershipRequirementsChanged) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.traits != rhs.traits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListReviewMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListReviewMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Message"),
    2: .same(proto: "ReviewID"),
    3: .same(proto: "MembershipRequirementsChanged"),
    4: .same(proto: "ReviewFrequencyChanged"),
    5: .same(proto: "ReviewDayOfMonthChanged"),
    6: .same(proto: "RemovedMembers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reviewID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._membershipRequirementsChanged) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reviewFrequencyChanged) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reviewDayOfMonthChanged) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.removedMembers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.reviewID.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewID, fieldNumber: 2)
    }
    try { if let v = self._membershipRequirementsChanged {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.reviewFrequencyChanged.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewFrequencyChanged, fieldNumber: 4)
    }
    if !self.reviewDayOfMonthChanged.isEmpty {
      try visitor.visitSingularStringField(value: self.reviewDayOfMonthChanged, fieldNumber: 5)
    }
    if !self.removedMembers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removedMembers, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListReviewMetadata, rhs: Events_AccessListReviewMetadata) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.reviewID != rhs.reviewID {return false}
    if lhs._membershipRequirementsChanged != rhs._membershipRequirementsChanged {return false}
    if lhs.reviewFrequencyChanged != rhs.reviewFrequencyChanged {return false}
    if lhs.reviewDayOfMonthChanged != rhs.reviewDayOfMonthChanged {return false}
    if lhs.removedMembers != rhs.removedMembers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "Connection"),
    6: .same(proto: "TerminalSize"),
    7: .same(proto: "KubernetesCluster"),
    8: .same(proto: "KubernetesPod"),
    9: .same(proto: "InitialCommand"),
    10: .same(proto: "SessionRecording"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _terminalSize: String = String()
    var _kubernetesCluster: Events_KubernetesClusterMetadata? = nil
    var _kubernetesPod: Events_KubernetesPodMetadata? = nil
    var _initialCommand: [String] = []
    var _sessionRecording: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _connection = source._connection
      _terminalSize = source._terminalSize
      _kubernetesCluster = source._kubernetesCluster
      _kubernetesPod = source._kubernetesPod
      _initialCommand = source._initialCommand
      _sessionRecording = source._sessionRecording
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._terminalSize) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetesCluster) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetesPod) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._initialCommand) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._sessionRecording) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._terminalSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._terminalSize, fieldNumber: 6)
      }
      try { if let v = _storage._kubernetesCluster {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kubernetesPod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._initialCommand.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._initialCommand, fieldNumber: 9)
      }
      if !_storage._sessionRecording.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionRecording, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionStart, rhs: Events_SessionStart) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._terminalSize != rhs_storage._terminalSize {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        if _storage._kubernetesPod != rhs_storage._kubernetesPod {return false}
        if _storage._initialCommand != rhs_storage._initialCommand {return false}
        if _storage._sessionRecording != rhs_storage._sessionRecording {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionJoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionJoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "Connection"),
    6: .same(proto: "KubernetesCluster"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _kubernetesCluster: Events_KubernetesClusterMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _connection = source._connection
      _kubernetesCluster = source._kubernetesCluster
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetesCluster) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._kubernetesCluster {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionJoin, rhs: Events_SessionJoin) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionPrint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionPrint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "ChunkIndex"),
    3: .same(proto: "Data"),
    4: .same(proto: "Bytes"),
    5: .same(proto: "DelayMilliseconds"),
    6: .same(proto: "Offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.chunkIndex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.bytes) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.delayMilliseconds) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.chunkIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.chunkIndex, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if self.bytes != 0 {
      try visitor.visitSingularInt64Field(value: self.bytes, fieldNumber: 4)
    }
    if self.delayMilliseconds != 0 {
      try visitor.visitSingularInt64Field(value: self.delayMilliseconds, fieldNumber: 5)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionPrint, rhs: Events_SessionPrint) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.chunkIndex != rhs.chunkIndex {return false}
    if lhs.data != rhs.data {return false}
    if lhs.bytes != rhs.bytes {return false}
    if lhs.delayMilliseconds != rhs.delayMilliseconds {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DesktopRecording: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DesktopRecording"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Message"),
    3: .same(proto: "DelayMilliseconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.delayMilliseconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 2)
    }
    if self.delayMilliseconds != 0 {
      try visitor.visitSingularInt64Field(value: self.delayMilliseconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DesktopRecording, rhs: Events_DesktopRecording) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.message != rhs.message {return false}
    if lhs.delayMilliseconds != rhs.delayMilliseconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DesktopClipboardReceive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DesktopClipboardReceive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Connection"),
    5: .same(proto: "DesktopAddr"),
    6: .same(proto: "Length"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _desktopAddr: String = String()
    var _length: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _connection = source._connection
      _desktopAddr = source._desktopAddr
      _length = source._length
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._desktopAddr) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._length) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._desktopAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desktopAddr, fieldNumber: 5)
      }
      if _storage._length != 0 {
        try visitor.visitSingularInt32Field(value: _storage._length, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DesktopClipboardReceive, rhs: Events_DesktopClipboardReceive) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._desktopAddr != rhs_storage._desktopAddr {return false}
        if _storage._length != rhs_storage._length {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DesktopClipboardSend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DesktopClipboardSend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Connection"),
    5: .same(proto: "DesktopAddr"),
    6: .same(proto: "Length"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _desktopAddr: String = String()
    var _length: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _connection = source._connection
      _desktopAddr = source._desktopAddr
      _length = source._length
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._desktopAddr) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._length) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._desktopAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desktopAddr, fieldNumber: 5)
      }
      if _storage._length != 0 {
        try visitor.visitSingularInt32Field(value: _storage._length, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DesktopClipboardSend, rhs: Events_DesktopClipboardSend) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._desktopAddr != rhs_storage._desktopAddr {return false}
        if _storage._length != rhs_storage._length {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DesktopSharedDirectoryStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DesktopSharedDirectoryStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Connection"),
    5: .same(proto: "Status"),
    6: .same(proto: "DesktopAddr"),
    7: .same(proto: "DirectoryName"),
    8: .same(proto: "DirectoryID"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _status: Events_Status? = nil
    var _desktopAddr: String = String()
    var _directoryName: String = String()
    var _directoryID: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _connection = source._connection
      _status = source._status
      _desktopAddr = source._desktopAddr
      _directoryName = source._directoryName
      _directoryID = source._directoryID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._desktopAddr) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._directoryName) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._directoryID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._desktopAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desktopAddr, fieldNumber: 6)
      }
      if !_storage._directoryName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._directoryName, fieldNumber: 7)
      }
      if _storage._directoryID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._directoryID, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DesktopSharedDirectoryStart, rhs: Events_DesktopSharedDirectoryStart) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._desktopAddr != rhs_storage._desktopAddr {return false}
        if _storage._directoryName != rhs_storage._directoryName {return false}
        if _storage._directoryID != rhs_storage._directoryID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DesktopSharedDirectoryRead: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DesktopSharedDirectoryRead"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Connection"),
    5: .same(proto: "Status"),
    6: .same(proto: "DesktopAddr"),
    7: .same(proto: "DirectoryName"),
    8: .same(proto: "DirectoryID"),
    9: .same(proto: "Path"),
    10: .same(proto: "Length"),
    11: .same(proto: "Offset"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _status: Events_Status? = nil
    var _desktopAddr: String = String()
    var _directoryName: String = String()
    var _directoryID: UInt32 = 0
    var _path: String = String()
    var _length: UInt32 = 0
    var _offset: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _connection = source._connection
      _status = source._status
      _desktopAddr = source._desktopAddr
      _directoryName = source._directoryName
      _directoryID = source._directoryID
      _path = source._path
      _length = source._length
      _offset = source._offset
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._desktopAddr) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._directoryName) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._directoryID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._length) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._offset) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._desktopAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desktopAddr, fieldNumber: 6)
      }
      if !_storage._directoryName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._directoryName, fieldNumber: 7)
      }
      if _storage._directoryID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._directoryID, fieldNumber: 8)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 9)
      }
      if _storage._length != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._length, fieldNumber: 10)
      }
      if _storage._offset != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._offset, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DesktopSharedDirectoryRead, rhs: Events_DesktopSharedDirectoryRead) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._desktopAddr != rhs_storage._desktopAddr {return false}
        if _storage._directoryName != rhs_storage._directoryName {return false}
        if _storage._directoryID != rhs_storage._directoryID {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._length != rhs_storage._length {return false}
        if _storage._offset != rhs_storage._offset {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DesktopSharedDirectoryWrite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DesktopSharedDirectoryWrite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Connection"),
    5: .same(proto: "Status"),
    6: .same(proto: "DesktopAddr"),
    7: .same(proto: "DirectoryName"),
    8: .same(proto: "DirectoryID"),
    9: .same(proto: "Path"),
    10: .same(proto: "Length"),
    11: .same(proto: "Offset"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _status: Events_Status? = nil
    var _desktopAddr: String = String()
    var _directoryName: String = String()
    var _directoryID: UInt32 = 0
    var _path: String = String()
    var _length: UInt32 = 0
    var _offset: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _connection = source._connection
      _status = source._status
      _desktopAddr = source._desktopAddr
      _directoryName = source._directoryName
      _directoryID = source._directoryID
      _path = source._path
      _length = source._length
      _offset = source._offset
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._desktopAddr) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._directoryName) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._directoryID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._length) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._offset) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._desktopAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desktopAddr, fieldNumber: 6)
      }
      if !_storage._directoryName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._directoryName, fieldNumber: 7)
      }
      if _storage._directoryID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._directoryID, fieldNumber: 8)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 9)
      }
      if _storage._length != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._length, fieldNumber: 10)
      }
      if _storage._offset != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._offset, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DesktopSharedDirectoryWrite, rhs: Events_DesktopSharedDirectoryWrite) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._desktopAddr != rhs_storage._desktopAddr {return false}
        if _storage._directoryName != rhs_storage._directoryName {return false}
        if _storage._directoryID != rhs_storage._directoryID {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._length != rhs_storage._length {return false}
        if _storage._offset != rhs_storage._offset {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionReject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionReject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Server"),
    4: .same(proto: "Connection"),
    5: .same(proto: "Reason"),
    6: .same(proto: "Maximum"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _reason: String = String()
    var _maximum: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _server = source._server
      _connection = source._connection
      _reason = source._reason
      _maximum = source._maximum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._reason) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._maximum) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._reason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reason, fieldNumber: 5)
      }
      if _storage._maximum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maximum, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionReject, rhs: Events_SessionReject) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._maximum != rhs_storage._maximum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionConnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionConnect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Server"),
    3: .same(proto: "Connection"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _server = source._server
      _connection = source._connection
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionConnect, rhs: Events_SessionConnect) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._connection != rhs_storage._connection {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_FileTransferRequestEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileTransferRequestEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Session"),
    3: .same(proto: "RequestID"),
    4: .same(proto: "Approvers"),
    5: .same(proto: "Requester"),
    6: .same(proto: "Location"),
    7: .same(proto: "Download"),
    8: .same(proto: "Filename"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.approvers) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.requester) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.download) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    if !self.approvers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.approvers, fieldNumber: 4)
    }
    if !self.requester.isEmpty {
      try visitor.visitSingularStringField(value: self.requester, fieldNumber: 5)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 6)
    }
    if self.download != false {
      try visitor.visitSingularBoolField(value: self.download, fieldNumber: 7)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_FileTransferRequestEvent, rhs: Events_FileTransferRequestEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._session != rhs._session {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.approvers != rhs.approvers {return false}
    if lhs.requester != rhs.requester {return false}
    if lhs.location != rhs.location {return false}
    if lhs.download != rhs.download {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_Resize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Resize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Connection"),
    5: .same(proto: "Server"),
    6: .same(proto: "TerminalSize"),
    7: .same(proto: "KubernetesCluster"),
    8: .same(proto: "KubernetesPod"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _terminalSize: String = String()
    var _kubernetesCluster: Events_KubernetesClusterMetadata? = nil
    var _kubernetesPod: Events_KubernetesPodMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _connection = source._connection
      _server = source._server
      _terminalSize = source._terminalSize
      _kubernetesCluster = source._kubernetesCluster
      _kubernetesPod = source._kubernetesPod
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._terminalSize) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetesCluster) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetesPod) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._terminalSize.isEmpty {
        try visitor.visitSingularStringField(value: _storage._terminalSize, fieldNumber: 6)
      }
      try { if let v = _storage._kubernetesCluster {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kubernetesPod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_Resize, rhs: Events_Resize) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._terminalSize != rhs_storage._terminalSize {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        if _storage._kubernetesPod != rhs_storage._kubernetesPod {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionEnd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Connection"),
    5: .same(proto: "Server"),
    6: .same(proto: "EnhancedRecording"),
    7: .same(proto: "Interactive"),
    8: .same(proto: "Participants"),
    9: .same(proto: "StartTime"),
    10: .same(proto: "EndTime"),
    11: .same(proto: "KubernetesCluster"),
    12: .same(proto: "KubernetesPod"),
    13: .same(proto: "InitialCommand"),
    14: .same(proto: "SessionRecording"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _enhancedRecording: Bool = false
    var _interactive: Bool = false
    var _participants: [String] = []
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _kubernetesCluster: Events_KubernetesClusterMetadata? = nil
    var _kubernetesPod: Events_KubernetesPodMetadata? = nil
    var _initialCommand: [String] = []
    var _sessionRecording: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _connection = source._connection
      _server = source._server
      _enhancedRecording = source._enhancedRecording
      _interactive = source._interactive
      _participants = source._participants
      _startTime = source._startTime
      _endTime = source._endTime
      _kubernetesCluster = source._kubernetesCluster
      _kubernetesPod = source._kubernetesPod
      _initialCommand = source._initialCommand
      _sessionRecording = source._sessionRecording
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._enhancedRecording) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._interactive) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._participants) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetesCluster) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetesPod) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._initialCommand) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._sessionRecording) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._enhancedRecording != false {
        try visitor.visitSingularBoolField(value: _storage._enhancedRecording, fieldNumber: 6)
      }
      if _storage._interactive != false {
        try visitor.visitSingularBoolField(value: _storage._interactive, fieldNumber: 7)
      }
      if !_storage._participants.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._participants, fieldNumber: 8)
      }
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._kubernetesCluster {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._kubernetesPod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._initialCommand.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._initialCommand, fieldNumber: 13)
      }
      if !_storage._sessionRecording.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionRecording, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionEnd, rhs: Events_SessionEnd) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._enhancedRecording != rhs_storage._enhancedRecording {return false}
        if _storage._interactive != rhs_storage._interactive {return false}
        if _storage._participants != rhs_storage._participants {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        if _storage._kubernetesPod != rhs_storage._kubernetesPod {return false}
        if _storage._initialCommand != rhs_storage._initialCommand {return false}
        if _storage._sessionRecording != rhs_storage._sessionRecording {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_BPFMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BPFMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PID"),
    2: .same(proto: "CgroupID"),
    3: .same(proto: "Program"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.pid) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.cgroupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.program) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pid != 0 {
      try visitor.visitSingularUInt64Field(value: self.pid, fieldNumber: 1)
    }
    if self.cgroupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.cgroupID, fieldNumber: 2)
    }
    if !self.program.isEmpty {
      try visitor.visitSingularStringField(value: self.program, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_BPFMetadata, rhs: Events_BPFMetadata) -> Bool {
    if lhs.pid != rhs.pid {return false}
    if lhs.cgroupID != rhs.cgroupID {return false}
    if lhs.program != rhs.program {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Success"),
    2: .same(proto: "Error"),
    3: .same(proto: "UserMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if !self.userMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.userMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_Status, rhs: Events_Status) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.userMessage != rhs.userMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "BPF"),
    6: .same(proto: "PPID"),
    7: .same(proto: "Path"),
    8: .same(proto: "Argv"),
    9: .same(proto: "ReturnCode"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _bpf: Events_BPFMetadata? = nil
    var _ppid: UInt64 = 0
    var _path: String = String()
    var _argv: [String] = []
    var _returnCode: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _bpf = source._bpf
      _ppid = source._ppid
      _path = source._path
      _argv = source._argv
      _returnCode = source._returnCode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._bpf) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._ppid) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._argv) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._returnCode) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._bpf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._ppid != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._ppid, fieldNumber: 6)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 7)
      }
      if !_storage._argv.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._argv, fieldNumber: 8)
      }
      if _storage._returnCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._returnCode, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionCommand, rhs: Events_SessionCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._bpf != rhs_storage._bpf {return false}
        if _storage._ppid != rhs_storage._ppid {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._argv != rhs_storage._argv {return false}
        if _storage._returnCode != rhs_storage._returnCode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionDisk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionDisk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "BPF"),
    6: .same(proto: "Path"),
    7: .same(proto: "Flags"),
    8: .same(proto: "ReturnCode"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _bpf: Events_BPFMetadata? = nil
    var _path: String = String()
    var _flags: Int32 = 0
    var _returnCode: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _bpf = source._bpf
      _path = source._path
      _flags = source._flags
      _returnCode = source._returnCode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._bpf) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._flags) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._returnCode) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._bpf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 6)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularInt32Field(value: _storage._flags, fieldNumber: 7)
      }
      if _storage._returnCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._returnCode, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionDisk, rhs: Events_SessionDisk) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._bpf != rhs_storage._bpf {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._returnCode != rhs_storage._returnCode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionNetwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionNetwork"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "BPF"),
    6: .same(proto: "SrcAddr"),
    7: .same(proto: "DstAddr"),
    8: .same(proto: "DstPort"),
    9: .same(proto: "TCPVersion"),
    10: .same(proto: "Operation"),
    11: .same(proto: "Action"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _bpf: Events_BPFMetadata? = nil
    var _srcAddr: String = String()
    var _dstAddr: String = String()
    var _dstPort: Int32 = 0
    var _tcpversion: Int32 = 0
    var _operation: Events_SessionNetwork.NetworkOperation = .connect
    var _action: Events_EventAction = .observed

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _bpf = source._bpf
      _srcAddr = source._srcAddr
      _dstAddr = source._dstAddr
      _dstPort = source._dstPort
      _tcpversion = source._tcpversion
      _operation = source._operation
      _action = source._action
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._bpf) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._srcAddr) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._dstAddr) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._dstPort) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._tcpversion) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._operation) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._bpf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._srcAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._srcAddr, fieldNumber: 6)
      }
      if !_storage._dstAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dstAddr, fieldNumber: 7)
      }
      if _storage._dstPort != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dstPort, fieldNumber: 8)
      }
      if _storage._tcpversion != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tcpversion, fieldNumber: 9)
      }
      if _storage._operation != .connect {
        try visitor.visitSingularEnumField(value: _storage._operation, fieldNumber: 10)
      }
      if _storage._action != .observed {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionNetwork, rhs: Events_SessionNetwork) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._bpf != rhs_storage._bpf {return false}
        if _storage._srcAddr != rhs_storage._srcAddr {return false}
        if _storage._dstAddr != rhs_storage._dstAddr {return false}
        if _storage._dstPort != rhs_storage._dstPort {return false}
        if _storage._tcpversion != rhs_storage._tcpversion {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._action != rhs_storage._action {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionNetwork.NetworkOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECT"),
    1: .same(proto: "SEND"),
  ]
}

extension Events_SessionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "Connection"),
    6: .same(proto: "BytesTransmitted"),
    7: .same(proto: "BytesReceived"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _bytesTransmitted: UInt64 = 0
    var _bytesReceived: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _connection = source._connection
      _bytesTransmitted = source._bytesTransmitted
      _bytesReceived = source._bytesReceived
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._bytesTransmitted) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._bytesReceived) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._bytesTransmitted != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bytesTransmitted, fieldNumber: 6)
      }
      if _storage._bytesReceived != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._bytesReceived, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionData, rhs: Events_SessionData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._bytesTransmitted != rhs_storage._bytesTransmitted {return false}
        if _storage._bytesReceived != rhs_storage._bytesReceived {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionLeave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionLeave"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "Connection"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _connection = source._connection
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionLeave, rhs: Events_SessionLeave) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._connection != rhs_storage._connection {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_UserLogin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserLogin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Status"),
    4: .same(proto: "Method"),
    5: .same(proto: "IdentityAttributes"),
    6: .same(proto: "MFADevice"),
    7: .same(proto: "Client"),
    8: .same(proto: "Connection"),
    9: .same(proto: "AppliedLoginRules"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _status: Events_Status? = nil
    var _method: String = String()
    var _identityAttributes: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _mfadevice: Events_MFADeviceMetadata? = nil
    var _client: Events_ClientMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _appliedLoginRules: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _status = source._status
      _method = source._method
      _identityAttributes = source._identityAttributes
      _mfadevice = source._mfadevice
      _client = source._client
      _connection = source._connection
      _appliedLoginRules = source._appliedLoginRules
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._identityAttributes) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._mfadevice) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._client) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._appliedLoginRules) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 4)
      }
      try { if let v = _storage._identityAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._mfadevice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._client {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._appliedLoginRules.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._appliedLoginRules, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_UserLogin, rhs: Events_UserLogin) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._identityAttributes != rhs_storage._identityAttributes {return false}
        if _storage._mfadevice != rhs_storage._mfadevice {return false}
        if _storage._client != rhs_storage._client {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._appliedLoginRules != rhs_storage._appliedLoginRules {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ResourceMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Expires"),
    3: .same(proto: "UpdatedBy"),
    4: .same(proto: "TTL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.updatedBy) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ttl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.updatedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.updatedBy, fieldNumber: 3)
    }
    if !self.ttl.isEmpty {
      try visitor.visitSingularStringField(value: self.ttl, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_ResourceMetadata, rhs: Events_ResourceMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.updatedBy != rhs.updatedBy {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_UserCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
    4: .same(proto: "Roles"),
    5: .same(proto: "Connector"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _roles: [String] = []
    var _connector: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
      _roles = source._roles
      _connector = source._connector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._roles) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._connector) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roles, fieldNumber: 4)
      }
      if !_storage._connector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connector, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_UserCreate, rhs: Events_UserCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._connector != rhs_storage._connector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_UserUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
    4: .same(proto: "Roles"),
    5: .same(proto: "Connector"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _roles: [String] = []
    var _connector: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
      _roles = source._roles
      _connector = source._connector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._roles) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._connector) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roles, fieldNumber: 4)
      }
      if !_storage._connector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connector, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_UserUpdate, rhs: Events_UserUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._connector != rhs_storage._connector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_UserDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_UserDelete, rhs: Events_UserDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_UserPasswordChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserPasswordChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_UserPasswordChange, rhs: Events_UserPasswordChange) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessRequestCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
    4: .same(proto: "Roles"),
    5: .same(proto: "RequestID"),
    6: .same(proto: "RequestState"),
    7: .same(proto: "Delegator"),
    8: .same(proto: "Reason"),
    9: .same(proto: "Annotations"),
    10: .same(proto: "Reviewer"),
    11: .same(proto: "ProposedState"),
    12: .same(proto: "RequestedResourceIDs"),
    13: .same(proto: "MaxDuration"),
    15: .same(proto: "PromotedAccessListName"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _roles: [String] = []
    var _requestID: String = String()
    var _requestState: String = String()
    var _delegator: String = String()
    var _reason: String = String()
    var _annotations: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _reviewer: String = String()
    var _proposedState: String = String()
    var _requestedResourceIds: [Events_ResourceID] = []
    var _maxDuration: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _promotedAccessListName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
      _roles = source._roles
      _requestID = source._requestID
      _requestState = source._requestState
      _delegator = source._delegator
      _reason = source._reason
      _annotations = source._annotations
      _reviewer = source._reviewer
      _proposedState = source._proposedState
      _requestedResourceIds = source._requestedResourceIds
      _maxDuration = source._maxDuration
      _promotedAccessListName = source._promotedAccessListName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._roles) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._requestState) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._delegator) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._reason) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._annotations) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._reviewer) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._proposedState) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestedResourceIds) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._maxDuration) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._promotedAccessListName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roles, fieldNumber: 4)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 5)
      }
      if !_storage._requestState.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestState, fieldNumber: 6)
      }
      if !_storage._delegator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._delegator, fieldNumber: 7)
      }
      if !_storage._reason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reason, fieldNumber: 8)
      }
      try { if let v = _storage._annotations {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._reviewer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reviewer, fieldNumber: 10)
      }
      if !_storage._proposedState.isEmpty {
        try visitor.visitSingularStringField(value: _storage._proposedState, fieldNumber: 11)
      }
      if !_storage._requestedResourceIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestedResourceIds, fieldNumber: 12)
      }
      try { if let v = _storage._maxDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._promotedAccessListName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._promotedAccessListName, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessRequestCreate, rhs: Events_AccessRequestCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._requestState != rhs_storage._requestState {return false}
        if _storage._delegator != rhs_storage._delegator {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._annotations != rhs_storage._annotations {return false}
        if _storage._reviewer != rhs_storage._reviewer {return false}
        if _storage._proposedState != rhs_storage._proposedState {return false}
        if _storage._requestedResourceIds != rhs_storage._requestedResourceIds {return false}
        if _storage._maxDuration != rhs_storage._maxDuration {return false}
        if _storage._promotedAccessListName != rhs_storage._promotedAccessListName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ResourceID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClusterName"),
    2: .same(proto: "Kind"),
    3: .same(proto: "Name"),
    4: .same(proto: "SubResourceName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subResourceName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.subResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.subResourceName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_ResourceID, rhs: Events_ResourceID) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.name != rhs.name {return false}
    if lhs.subResourceName != rhs.subResourceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessRequestDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "RequestID"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _requestID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _requestID = source._requestID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessRequestDelete, rhs: Events_AccessRequestDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_PortForward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PortForward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Connection"),
    4: .same(proto: "Status"),
    5: .same(proto: "Addr"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _status: Events_Status? = nil
    var _addr: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _connection = source._connection
      _status = source._status
      _addr = source._addr
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._addr) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._addr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addr, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_PortForward, rhs: Events_PortForward) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._addr != rhs_storage._addr {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_X11Forward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".X11Forward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Connection"),
    4: .same(proto: "Status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _status: Events_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _connection = source._connection
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_X11Forward, rhs: Events_X11Forward) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_CommandMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Command"),
    2: .same(proto: "ExitCode"),
    3: .same(proto: "Error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exitCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 1)
    }
    if !self.exitCode.isEmpty {
      try visitor.visitSingularStringField(value: self.exitCode, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_CommandMetadata, rhs: Events_CommandMetadata) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_Exec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Exec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Connection"),
    4: .same(proto: "Session"),
    5: .same(proto: "Server"),
    6: .same(proto: "Command"),
    7: .same(proto: "KubernetesCluster"),
    8: .same(proto: "KubernetesPod"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _command: Events_CommandMetadata? = nil
    var _kubernetesCluster: Events_KubernetesClusterMetadata? = nil
    var _kubernetesPod: Events_KubernetesPodMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _connection = source._connection
      _session = source._session
      _server = source._server
      _command = source._command
      _kubernetesCluster = source._kubernetesCluster
      _kubernetesPod = source._kubernetesPod
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._command) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetesCluster) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetesPod) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._command {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._kubernetesCluster {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._kubernetesPod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_Exec, rhs: Events_Exec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._command != rhs_storage._command {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        if _storage._kubernetesPod != rhs_storage._kubernetesPod {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SCP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SCP"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Connection"),
    4: .same(proto: "Session"),
    5: .same(proto: "Server"),
    6: .same(proto: "Command"),
    7: .same(proto: "Path"),
    8: .same(proto: "Action"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _command: Events_CommandMetadata? = nil
    var _path: String = String()
    var _action: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _connection = source._connection
      _session = source._session
      _server = source._server
      _command = source._command
      _path = source._path
      _action = source._action
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._command) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._action) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._command {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 7)
      }
      if !_storage._action.isEmpty {
        try visitor.visitSingularStringField(value: _storage._action, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SCP, rhs: Events_SCP) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._command != rhs_storage._command {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._action != rhs_storage._action {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SFTPAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SFTPAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FileSize"),
    2: .same(proto: "UID"),
    3: .same(proto: "GID"),
    4: .same(proto: "Permissions"),
    5: .same(proto: "AccessTime"),
    6: .same(proto: "ModificationTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fileSize) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gid) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._permissions) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._accessTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._modificationTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fileSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._gid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._permissions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._accessTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._modificationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SFTPAttributes, rhs: Events_SFTPAttributes) -> Bool {
    if lhs._fileSize != rhs._fileSize {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs._gid != rhs._gid {return false}
    if lhs._permissions != rhs._permissions {return false}
    if lhs._accessTime != rhs._accessTime {return false}
    if lhs._modificationTime != rhs._modificationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SFTP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SFTP"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Connection"),
    4: .same(proto: "Session"),
    5: .same(proto: "Server"),
    6: .same(proto: "WorkingDirectory"),
    7: .same(proto: "Path"),
    8: .same(proto: "TargetPath"),
    9: .same(proto: "Flags"),
    10: .same(proto: "Attributes"),
    11: .same(proto: "Action"),
    12: .same(proto: "Error"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _workingDirectory: String = String()
    var _path: String = String()
    var _targetPath: String = String()
    var _flags: UInt32 = 0
    var _attributes: Events_SFTPAttributes? = nil
    var _action: Events_SFTPAction = .invalid
    var _error: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _connection = source._connection
      _session = source._session
      _server = source._server
      _workingDirectory = source._workingDirectory
      _path = source._path
      _targetPath = source._targetPath
      _flags = source._flags
      _attributes = source._attributes
      _action = source._action
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._workingDirectory) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._targetPath) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._attributes) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._error) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._workingDirectory.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workingDirectory, fieldNumber: 6)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 7)
      }
      if !_storage._targetPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetPath, fieldNumber: 8)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 9)
      }
      try { if let v = _storage._attributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._action != .invalid {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 11)
      }
      if !_storage._error.isEmpty {
        try visitor.visitSingularStringField(value: _storage._error, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SFTP, rhs: Events_SFTP) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._workingDirectory != rhs_storage._workingDirectory {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._targetPath != rhs_storage._targetPath {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_Subsystem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Subsystem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Connection"),
    4: .same(proto: "Name"),
    5: .same(proto: "Error"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _name: String = String()
    var _error: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _connection = source._connection
      _name = source._name
      _error = source._error
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._error) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 4)
      }
      if !_storage._error.isEmpty {
        try visitor.visitSingularStringField(value: _storage._error, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_Subsystem, rhs: Events_Subsystem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._error != rhs_storage._error {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ClientDisconnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientDisconnect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Connection"),
    4: .same(proto: "Server"),
    5: .same(proto: "Reason"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _reason: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _connection = source._connection
      _server = source._server
      _reason = source._reason
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._reason) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._reason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reason, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_ClientDisconnect, rhs: Events_ClientDisconnect) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._reason != rhs_storage._reason {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AuthAttempt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthAttempt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Connection"),
    4: .same(proto: "Status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _status: Events_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _connection = source._connection
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AuthAttempt, rhs: Events_AuthAttempt) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_UserTokenCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserTokenCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_UserTokenCreate, rhs: Events_UserTokenCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_RoleCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_RoleCreate, rhs: Events_RoleCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_RoleUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_RoleUpdate, rhs: Events_RoleUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_RoleDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_RoleDelete, rhs: Events_RoleDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_TrustedClusterCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrustedClusterCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_TrustedClusterCreate, rhs: Events_TrustedClusterCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_TrustedClusterDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrustedClusterDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_TrustedClusterDelete, rhs: Events_TrustedClusterDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ProvisionTokenCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
    4: .same(proto: "Roles"),
    5: .same(proto: "JoinMethod"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil
    var _roles: [String] = []
    var _joinMethod: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
      _roles = source._roles
      _joinMethod = source._joinMethod
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._roles) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._joinMethod) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roles, fieldNumber: 4)
      }
      if !_storage._joinMethod.isEmpty {
        try visitor.visitSingularStringField(value: _storage._joinMethod, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_ProvisionTokenCreate, rhs: Events_ProvisionTokenCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._joinMethod != rhs_storage._joinMethod {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_TrustedClusterTokenCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrustedClusterTokenCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_TrustedClusterTokenCreate, rhs: Events_TrustedClusterTokenCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_GithubConnectorCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GithubConnectorCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_GithubConnectorCreate, rhs: Events_GithubConnectorCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_GithubConnectorUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GithubConnectorUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_GithubConnectorUpdate, rhs: Events_GithubConnectorUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_GithubConnectorDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GithubConnectorDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_GithubConnectorDelete, rhs: Events_GithubConnectorDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OIDCConnectorCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OIDCConnectorCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OIDCConnectorCreate, rhs: Events_OIDCConnectorCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OIDCConnectorUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OIDCConnectorUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OIDCConnectorUpdate, rhs: Events_OIDCConnectorUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OIDCConnectorDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OIDCConnectorDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OIDCConnectorDelete, rhs: Events_OIDCConnectorDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SAMLConnectorCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLConnectorCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SAMLConnectorCreate, rhs: Events_SAMLConnectorCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SAMLConnectorUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLConnectorUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SAMLConnectorUpdate, rhs: Events_SAMLConnectorUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SAMLConnectorDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLConnectorDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SAMLConnectorDelete, rhs: Events_SAMLConnectorDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_KubeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Connection"),
    4: .same(proto: "Server"),
    5: .same(proto: "RequestPath"),
    6: .same(proto: "Verb"),
    7: .same(proto: "ResourceAPIGroup"),
    8: .same(proto: "ResourceNamespace"),
    9: .same(proto: "ResourceKind"),
    10: .same(proto: "ResourceName"),
    11: .same(proto: "ResponseCode"),
    12: .same(proto: "Kubernetes"),
    13: .same(proto: "Session"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _requestPath: String = String()
    var _verb: String = String()
    var _resourceApigroup: String = String()
    var _resourceNamespace: String = String()
    var _resourceKind: String = String()
    var _resourceName: String = String()
    var _responseCode: Int32 = 0
    var _kubernetes: Events_KubernetesClusterMetadata? = nil
    var _session: Events_SessionMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _connection = source._connection
      _server = source._server
      _requestPath = source._requestPath
      _verb = source._verb
      _resourceApigroup = source._resourceApigroup
      _resourceNamespace = source._resourceNamespace
      _resourceKind = source._resourceKind
      _resourceName = source._resourceName
      _responseCode = source._responseCode
      _kubernetes = source._kubernetes
      _session = source._session
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._requestPath) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._verb) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._resourceApigroup) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._resourceNamespace) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._resourceKind) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._resourceName) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._responseCode) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetes) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._requestPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestPath, fieldNumber: 5)
      }
      if !_storage._verb.isEmpty {
        try visitor.visitSingularStringField(value: _storage._verb, fieldNumber: 6)
      }
      if !_storage._resourceApigroup.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceApigroup, fieldNumber: 7)
      }
      if !_storage._resourceNamespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceNamespace, fieldNumber: 8)
      }
      if !_storage._resourceKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceKind, fieldNumber: 9)
      }
      if !_storage._resourceName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceName, fieldNumber: 10)
      }
      if _storage._responseCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._responseCode, fieldNumber: 11)
      }
      try { if let v = _storage._kubernetes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_KubeRequest, rhs: Events_KubeRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._requestPath != rhs_storage._requestPath {return false}
        if _storage._verb != rhs_storage._verb {return false}
        if _storage._resourceApigroup != rhs_storage._resourceApigroup {return false}
        if _storage._resourceNamespace != rhs_storage._resourceNamespace {return false}
        if _storage._resourceKind != rhs_storage._resourceKind {return false}
        if _storage._resourceName != rhs_storage._resourceName {return false}
        if _storage._responseCode != rhs_storage._responseCode {return false}
        if _storage._kubernetes != rhs_storage._kubernetes {return false}
        if _storage._session != rhs_storage._session {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AppMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AppURI"),
    2: .same(proto: "AppPublicAddr"),
    3: .same(proto: "AppLabels"),
    4: .same(proto: "AppName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appPublicAddr) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.appLabels) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.appName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appUri.isEmpty {
      try visitor.visitSingularStringField(value: self.appUri, fieldNumber: 1)
    }
    if !self.appPublicAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.appPublicAddr, fieldNumber: 2)
    }
    if !self.appLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.appLabels, fieldNumber: 3)
    }
    if !self.appName.isEmpty {
      try visitor.visitSingularStringField(value: self.appName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AppMetadata, rhs: Events_AppMetadata) -> Bool {
    if lhs.appUri != rhs.appUri {return false}
    if lhs.appPublicAddr != rhs.appPublicAddr {return false}
    if lhs.appLabels != rhs.appLabels {return false}
    if lhs.appName != rhs.appName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AppCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
    4: .same(proto: "App"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _app: Events_AppMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
      _app = source._app
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AppCreate, rhs: Events_AppCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._app != rhs_storage._app {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AppUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
    4: .same(proto: "App"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _app: Events_AppMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
      _app = source._app
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AppUpdate, rhs: Events_AppUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._app != rhs_storage._app {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AppDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AppDelete, rhs: Events_AppDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AppSessionStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppSessionStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "Connection"),
    7: .same(proto: "PublicAddr"),
    8: .same(proto: "App"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _publicAddr: String = String()
    var _app: Events_AppMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _connection = source._connection
      _publicAddr = source._publicAddr
      _app = source._app
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._publicAddr) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._publicAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._publicAddr, fieldNumber: 7)
      }
      try { if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AppSessionStart, rhs: Events_AppSessionStart) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._publicAddr != rhs_storage._publicAddr {return false}
        if _storage._app != rhs_storage._app {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AppSessionEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppSessionEnd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "Connection"),
    6: .same(proto: "App"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _app: Events_AppMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _connection = source._connection
      _app = source._app
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AppSessionEnd, rhs: Events_AppSessionEnd) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._app != rhs_storage._app {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AppSessionChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppSessionChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "Connection"),
    6: .same(proto: "SessionChunkID"),
    7: .same(proto: "App"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _sessionChunkID: String = String()
    var _app: Events_AppMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _connection = source._connection
      _sessionChunkID = source._sessionChunkID
      _app = source._app
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._sessionChunkID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._sessionChunkID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionChunkID, fieldNumber: 6)
      }
      try { if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AppSessionChunk, rhs: Events_AppSessionChunk) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._sessionChunkID != rhs_storage._sessionChunkID {return false}
        if _storage._app != rhs_storage._app {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AppSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "StatusCode"),
    3: .same(proto: "Path"),
    4: .same(proto: "RawQuery"),
    5: .same(proto: "Method"),
    6: .same(proto: "App"),
    7: .same(proto: "AWS"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _statusCode: UInt32 = 0
    var _path: String = String()
    var _rawQuery: String = String()
    var _method: String = String()
    var _app: Events_AppMetadata? = nil
    var _aws: Events_AWSRequestMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _statusCode = source._statusCode
      _path = source._path
      _rawQuery = source._rawQuery
      _method = source._method
      _app = source._app
      _aws = source._aws
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._statusCode) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._rawQuery) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._aws) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._statusCode != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statusCode, fieldNumber: 2)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 3)
      }
      if !_storage._rawQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rawQuery, fieldNumber: 4)
      }
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 5)
      }
      try { if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._aws {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AppSessionRequest, rhs: Events_AppSessionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._statusCode != rhs_storage._statusCode {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._rawQuery != rhs_storage._rawQuery {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._app != rhs_storage._app {return false}
        if _storage._aws != rhs_storage._aws {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AWSRequestMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AWSRequestMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AWSRegion"),
    2: .same(proto: "AWSService"),
    3: .same(proto: "AWSHost"),
    4: .same(proto: "AWSAssumedRole"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.awsregion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.awsservice) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.awshost) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.awsassumedRole) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.awsregion.isEmpty {
      try visitor.visitSingularStringField(value: self.awsregion, fieldNumber: 1)
    }
    if !self.awsservice.isEmpty {
      try visitor.visitSingularStringField(value: self.awsservice, fieldNumber: 2)
    }
    if !self.awshost.isEmpty {
      try visitor.visitSingularStringField(value: self.awshost, fieldNumber: 3)
    }
    if !self.awsassumedRole.isEmpty {
      try visitor.visitSingularStringField(value: self.awsassumedRole, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AWSRequestMetadata, rhs: Events_AWSRequestMetadata) -> Bool {
    if lhs.awsregion != rhs.awsregion {return false}
    if lhs.awsservice != rhs.awsservice {return false}
    if lhs.awshost != rhs.awshost {return false}
    if lhs.awsassumedRole != rhs.awsassumedRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DatabaseMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DatabaseService"),
    2: .same(proto: "DatabaseProtocol"),
    3: .same(proto: "DatabaseURI"),
    4: .same(proto: "DatabaseName"),
    5: .same(proto: "DatabaseUser"),
    6: .same(proto: "DatabaseLabels"),
    7: .same(proto: "DatabaseAWSRegion"),
    8: .same(proto: "DatabaseAWSRedshiftClusterID"),
    9: .same(proto: "DatabaseGCPProjectID"),
    10: .same(proto: "DatabaseGCPInstanceID"),
    11: .same(proto: "DatabaseRoles"),
    12: .same(proto: "DatabaseType"),
    13: .same(proto: "DatabaseOrigin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.databaseService) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.databaseProtocol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.databaseUri) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.databaseName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.databaseUser) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.databaseLabels) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.databaseAwsregion) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.databaseAwsredshiftClusterID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.databaseGcpprojectID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.databaseGcpinstanceID) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.databaseRoles) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.databaseType) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.databaseOrigin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.databaseService.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseService, fieldNumber: 1)
    }
    if !self.databaseProtocol.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseProtocol, fieldNumber: 2)
    }
    if !self.databaseUri.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseUri, fieldNumber: 3)
    }
    if !self.databaseName.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseName, fieldNumber: 4)
    }
    if !self.databaseUser.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseUser, fieldNumber: 5)
    }
    if !self.databaseLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.databaseLabels, fieldNumber: 6)
    }
    if !self.databaseAwsregion.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseAwsregion, fieldNumber: 7)
    }
    if !self.databaseAwsredshiftClusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseAwsredshiftClusterID, fieldNumber: 8)
    }
    if !self.databaseGcpprojectID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseGcpprojectID, fieldNumber: 9)
    }
    if !self.databaseGcpinstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseGcpinstanceID, fieldNumber: 10)
    }
    if !self.databaseRoles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.databaseRoles, fieldNumber: 11)
    }
    if !self.databaseType.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseType, fieldNumber: 12)
    }
    if !self.databaseOrigin.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseOrigin, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DatabaseMetadata, rhs: Events_DatabaseMetadata) -> Bool {
    if lhs.databaseService != rhs.databaseService {return false}
    if lhs.databaseProtocol != rhs.databaseProtocol {return false}
    if lhs.databaseUri != rhs.databaseUri {return false}
    if lhs.databaseName != rhs.databaseName {return false}
    if lhs.databaseUser != rhs.databaseUser {return false}
    if lhs.databaseLabels != rhs.databaseLabels {return false}
    if lhs.databaseAwsregion != rhs.databaseAwsregion {return false}
    if lhs.databaseAwsredshiftClusterID != rhs.databaseAwsredshiftClusterID {return false}
    if lhs.databaseGcpprojectID != rhs.databaseGcpprojectID {return false}
    if lhs.databaseGcpinstanceID != rhs.databaseGcpinstanceID {return false}
    if lhs.databaseRoles != rhs.databaseRoles {return false}
    if lhs.databaseType != rhs.databaseType {return false}
    if lhs.databaseOrigin != rhs.databaseOrigin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DatabaseCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
    4: .same(proto: "Database"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
      _database = source._database
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DatabaseCreate, rhs: Events_DatabaseCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._database != rhs_storage._database {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DatabaseUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
    4: .same(proto: "Database"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
      _database = source._database
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DatabaseUpdate, rhs: Events_DatabaseUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._database != rhs_storage._database {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DatabaseDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DatabaseDelete, rhs: Events_DatabaseDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DatabaseSessionStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseSessionStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Server"),
    5: .same(proto: "Connection"),
    6: .same(proto: "Status"),
    7: .same(proto: "Database"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _status: Events_Status? = nil
    var _database: Events_DatabaseMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _server = source._server
      _connection = source._connection
      _status = source._status
      _database = source._database
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DatabaseSessionStart, rhs: Events_DatabaseSessionStart) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._database != rhs_storage._database {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DatabaseSessionQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseSessionQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "DatabaseQuery"),
    6: .same(proto: "DatabaseQueryParameters"),
    7: .same(proto: "Status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _databaseQuery: String = String()
    var _databaseQueryParameters: [String] = []
    var _status: Events_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _databaseQuery = source._databaseQuery
      _databaseQueryParameters = source._databaseQueryParameters
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._databaseQuery) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._databaseQueryParameters) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._databaseQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._databaseQuery, fieldNumber: 5)
      }
      if !_storage._databaseQueryParameters.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._databaseQueryParameters, fieldNumber: 6)
      }
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DatabaseSessionQuery, rhs: Events_DatabaseSessionQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._databaseQuery != rhs_storage._databaseQuery {return false}
        if _storage._databaseQueryParameters != rhs_storage._databaseQueryParameters {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_PostgresParse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostgresParse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "StatementName"),
    6: .same(proto: "Query"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _statementName: String = String()
    var _query: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _statementName = source._statementName
      _query = source._query
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._statementName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._query) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._statementName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statementName, fieldNumber: 5)
      }
      if !_storage._query.isEmpty {
        try visitor.visitSingularStringField(value: _storage._query, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_PostgresParse, rhs: Events_PostgresParse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._statementName != rhs_storage._statementName {return false}
        if _storage._query != rhs_storage._query {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_PostgresBind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostgresBind"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "StatementName"),
    6: .same(proto: "PortalName"),
    7: .same(proto: "Parameters"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _statementName: String = String()
    var _portalName: String = String()
    var _parameters: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _statementName = source._statementName
      _portalName = source._portalName
      _parameters = source._parameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._statementName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._portalName) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._parameters) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._statementName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statementName, fieldNumber: 5)
      }
      if !_storage._portalName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._portalName, fieldNumber: 6)
      }
      if !_storage._parameters.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._parameters, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_PostgresBind, rhs: Events_PostgresBind) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._statementName != rhs_storage._statementName {return false}
        if _storage._portalName != rhs_storage._portalName {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_PostgresExecute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostgresExecute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "PortalName"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _portalName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _portalName = source._portalName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._portalName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._portalName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._portalName, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_PostgresExecute, rhs: Events_PostgresExecute) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._portalName != rhs_storage._portalName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_PostgresClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostgresClose"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "StatementName"),
    6: .same(proto: "PortalName"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _statementName: String = String()
    var _portalName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _statementName = source._statementName
      _portalName = source._portalName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._statementName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._portalName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._statementName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statementName, fieldNumber: 5)
      }
      if !_storage._portalName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._portalName, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_PostgresClose, rhs: Events_PostgresClose) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._statementName != rhs_storage._statementName {return false}
        if _storage._portalName != rhs_storage._portalName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_PostgresFunctionCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostgresFunctionCall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "FunctionOID"),
    6: .same(proto: "FunctionArgs"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _functionOid: UInt32 = 0
    var _functionArgs: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _functionOid = source._functionOid
      _functionArgs = source._functionArgs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._functionOid) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._functionArgs) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._functionOid != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._functionOid, fieldNumber: 5)
      }
      if !_storage._functionArgs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._functionArgs, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_PostgresFunctionCall, rhs: Events_PostgresFunctionCall) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._functionOid != rhs_storage._functionOid {return false}
        if _storage._functionArgs != rhs_storage._functionArgs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_WindowsDesktopSessionStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsDesktopSessionStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Connection"),
    5: .same(proto: "Status"),
    6: .same(proto: "WindowsDesktopService"),
    7: .same(proto: "DesktopAddr"),
    8: .same(proto: "Domain"),
    9: .same(proto: "WindowsUser"),
    10: .same(proto: "DesktopLabels"),
    11: .same(proto: "DesktopName"),
    12: .same(proto: "AllowUserCreation"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _connection: Events_ConnectionMetadata? = nil
    var _status: Events_Status? = nil
    var _windowsDesktopService: String = String()
    var _desktopAddr: String = String()
    var _domain: String = String()
    var _windowsUser: String = String()
    var _desktopLabels: Dictionary<String,String> = [:]
    var _desktopName: String = String()
    var _allowUserCreation: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _connection = source._connection
      _status = source._status
      _windowsDesktopService = source._windowsDesktopService
      _desktopAddr = source._desktopAddr
      _domain = source._domain
      _windowsUser = source._windowsUser
      _desktopLabels = source._desktopLabels
      _desktopName = source._desktopName
      _allowUserCreation = source._allowUserCreation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._connection) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._windowsDesktopService) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._desktopAddr) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._domain) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._windowsUser) }()
        case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._desktopLabels) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._desktopName) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._allowUserCreation) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._windowsDesktopService.isEmpty {
        try visitor.visitSingularStringField(value: _storage._windowsDesktopService, fieldNumber: 6)
      }
      if !_storage._desktopAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desktopAddr, fieldNumber: 7)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 8)
      }
      if !_storage._windowsUser.isEmpty {
        try visitor.visitSingularStringField(value: _storage._windowsUser, fieldNumber: 9)
      }
      if !_storage._desktopLabels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._desktopLabels, fieldNumber: 10)
      }
      if !_storage._desktopName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desktopName, fieldNumber: 11)
      }
      if _storage._allowUserCreation != false {
        try visitor.visitSingularBoolField(value: _storage._allowUserCreation, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_WindowsDesktopSessionStart, rhs: Events_WindowsDesktopSessionStart) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._windowsDesktopService != rhs_storage._windowsDesktopService {return false}
        if _storage._desktopAddr != rhs_storage._desktopAddr {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._windowsUser != rhs_storage._windowsUser {return false}
        if _storage._desktopLabels != rhs_storage._desktopLabels {return false}
        if _storage._desktopName != rhs_storage._desktopName {return false}
        if _storage._allowUserCreation != rhs_storage._allowUserCreation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DatabaseSessionEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseSessionEnd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DatabaseSessionEnd, rhs: Events_DatabaseSessionEnd) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MFADeviceMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MFADeviceMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DeviceName"),
    2: .same(proto: "DeviceID"),
    3: .same(proto: "DeviceType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    if !self.deviceType.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MFADeviceMetadata, rhs: Events_MFADeviceMetadata) -> Bool {
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MFADeviceAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MFADeviceAdd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Device"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _device: Events_MFADeviceMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _device = source._device
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MFADeviceAdd, rhs: Events_MFADeviceAdd) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._device != rhs_storage._device {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MFADeviceDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MFADeviceDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Device"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _device: Events_MFADeviceMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _device = source._device
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MFADeviceDelete, rhs: Events_MFADeviceDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._device != rhs_storage._device {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_BillingInformationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BillingInformationUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_BillingInformationUpdate, rhs: Events_BillingInformationUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_BillingCardCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BillingCardCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_BillingCardCreate, rhs: Events_BillingCardCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_BillingCardDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BillingCardDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_BillingCardDelete, rhs: Events_BillingCardDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_LockCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LockCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
    4: .same(proto: "Target"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil
    var _target: Types_LockTarget? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
      _target = source._target
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._target) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._target {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_LockCreate, rhs: Events_LockCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._target != rhs_storage._target {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_LockDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LockDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_LockDelete, rhs: Events_LockDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_RecoveryCodeGenerate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecoveryCodeGenerate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_RecoveryCodeGenerate, rhs: Events_RecoveryCodeGenerate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_RecoveryCodeUsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecoveryCodeUsed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _status: Events_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_RecoveryCodeUsed, rhs: Events_RecoveryCodeUsed) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_WindowsDesktopSessionEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsDesktopSessionEnd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "WindowsDesktopService"),
    5: .same(proto: "DesktopAddr"),
    6: .same(proto: "Domain"),
    7: .same(proto: "WindowsUser"),
    8: .same(proto: "DesktopLabels"),
    9: .same(proto: "StartTime"),
    10: .same(proto: "EndTime"),
    11: .same(proto: "DesktopName"),
    12: .same(proto: "Recorded"),
    13: .same(proto: "Participants"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _windowsDesktopService: String = String()
    var _desktopAddr: String = String()
    var _domain: String = String()
    var _windowsUser: String = String()
    var _desktopLabels: Dictionary<String,String> = [:]
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _desktopName: String = String()
    var _recorded: Bool = false
    var _participants: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _windowsDesktopService = source._windowsDesktopService
      _desktopAddr = source._desktopAddr
      _domain = source._domain
      _windowsUser = source._windowsUser
      _desktopLabels = source._desktopLabels
      _startTime = source._startTime
      _endTime = source._endTime
      _desktopName = source._desktopName
      _recorded = source._recorded
      _participants = source._participants
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._windowsDesktopService) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._desktopAddr) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._domain) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._windowsUser) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._desktopLabels) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._desktopName) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._recorded) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._participants) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._windowsDesktopService.isEmpty {
        try visitor.visitSingularStringField(value: _storage._windowsDesktopService, fieldNumber: 4)
      }
      if !_storage._desktopAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desktopAddr, fieldNumber: 5)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 6)
      }
      if !_storage._windowsUser.isEmpty {
        try visitor.visitSingularStringField(value: _storage._windowsUser, fieldNumber: 7)
      }
      if !_storage._desktopLabels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._desktopLabels, fieldNumber: 8)
      }
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._desktopName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desktopName, fieldNumber: 11)
      }
      if _storage._recorded != false {
        try visitor.visitSingularBoolField(value: _storage._recorded, fieldNumber: 12)
      }
      if !_storage._participants.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._participants, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_WindowsDesktopSessionEnd, rhs: Events_WindowsDesktopSessionEnd) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._windowsDesktopService != rhs_storage._windowsDesktopService {return false}
        if _storage._desktopAddr != rhs_storage._desktopAddr {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._windowsUser != rhs_storage._windowsUser {return false}
        if _storage._desktopLabels != rhs_storage._desktopLabels {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._desktopName != rhs_storage._desktopName {return false}
        if _storage._recorded != rhs_storage._recorded {return false}
        if _storage._participants != rhs_storage._participants {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_CertificateCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertificateCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "CertificateType"),
    3: .same(proto: "Identity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.certificateType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.certificateType.isEmpty {
      try visitor.visitSingularStringField(value: self.certificateType, fieldNumber: 2)
    }
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_CertificateCreate, rhs: Events_CertificateCreate) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.certificateType != rhs.certificateType {return false}
    if lhs._identity != rhs._identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_RenewableCertificateGenerationMismatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RenewableCertificateGenerationMismatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "UserMetadata"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _userMetadata: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _userMetadata = source._userMetadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_RenewableCertificateGenerationMismatch, rhs: Events_RenewableCertificateGenerationMismatch) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_BotJoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BotJoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Status"),
    3: .same(proto: "BotName"),
    4: .same(proto: "Method"),
    5: .same(proto: "TokenName"),
    6: .same(proto: "Attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.botName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tokenName) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.botName.isEmpty {
      try visitor.visitSingularStringField(value: self.botName, fieldNumber: 3)
    }
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 4)
    }
    if !self.tokenName.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenName, fieldNumber: 5)
    }
    try { if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_BotJoin, rhs: Events_BotJoin) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._status != rhs._status {return false}
    if lhs.botName != rhs.botName {return false}
    if lhs.method != rhs.method {return false}
    if lhs.tokenName != rhs.tokenName {return false}
    if lhs._attributes != rhs._attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_InstanceJoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceJoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Status"),
    3: .same(proto: "HostID"),
    4: .same(proto: "NodeName"),
    5: .same(proto: "Role"),
    6: .same(proto: "Method"),
    7: .same(proto: "TokenName"),
    8: .same(proto: "Attributes"),
    9: .same(proto: "TokenExpires"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _status: Events_Status? = nil
    var _hostID: String = String()
    var _nodeName: String = String()
    var _role: String = String()
    var _method: String = String()
    var _tokenName: String = String()
    var _attributes: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _tokenExpires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _status = source._status
      _hostID = source._hostID
      _nodeName = source._nodeName
      _role = source._role
      _method = source._method
      _tokenName = source._tokenName
      _attributes = source._attributes
      _tokenExpires = source._tokenExpires
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._hostID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._nodeName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._role) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._tokenName) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._attributes) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._tokenExpires) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._hostID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostID, fieldNumber: 3)
      }
      if !_storage._nodeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nodeName, fieldNumber: 4)
      }
      if !_storage._role.isEmpty {
        try visitor.visitSingularStringField(value: _storage._role, fieldNumber: 5)
      }
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 6)
      }
      if !_storage._tokenName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tokenName, fieldNumber: 7)
      }
      try { if let v = _storage._attributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._tokenExpires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_InstanceJoin, rhs: Events_InstanceJoin) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._hostID != rhs_storage._hostID {return false}
        if _storage._nodeName != rhs_storage._nodeName {return false}
        if _storage._role != rhs_storage._role {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._tokenName != rhs_storage._tokenName {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._tokenExpires != rhs_storage._tokenExpires {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_Unknown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Unknown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "UnknownType"),
    3: .same(proto: "UnknownCode"),
    4: .same(proto: "Data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.unknownType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.unknownCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.unknownType.isEmpty {
      try visitor.visitSingularStringField(value: self.unknownType, fieldNumber: 2)
    }
    if !self.unknownCode.isEmpty {
      try visitor.visitSingularStringField(value: self.unknownCode, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_Unknown, rhs: Events_Unknown) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownType != rhs.unknownType {return false}
    if lhs.unknownCode != rhs.unknownCode {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DeviceMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "os_type"),
    3: .standard(proto: "asset_tag"),
    4: .standard(proto: "credential_id"),
    5: .standard(proto: "device_origin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.osType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.assetTag) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.credentialID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.deviceOrigin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.osType != .unspecified {
      try visitor.visitSingularEnumField(value: self.osType, fieldNumber: 2)
    }
    if !self.assetTag.isEmpty {
      try visitor.visitSingularStringField(value: self.assetTag, fieldNumber: 3)
    }
    if !self.credentialID.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialID, fieldNumber: 4)
    }
    if self.deviceOrigin != .unspecified {
      try visitor.visitSingularEnumField(value: self.deviceOrigin, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DeviceMetadata, rhs: Events_DeviceMetadata) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.osType != rhs.osType {return false}
    if lhs.assetTag != rhs.assetTag {return false}
    if lhs.credentialID != rhs.credentialID {return false}
    if lhs.deviceOrigin != rhs.deviceOrigin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DeviceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "status"),
    3: .same(proto: "device"),
    4: .same(proto: "user"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _status: Events_Status? = nil
    var _device: Events_DeviceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _status = source._status
      _device = source._device
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DeviceEvent, rhs: Events_DeviceEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DeviceEvent2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceEvent2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    3: .same(proto: "device"),
    5: .same(proto: "status"),
    6: .same(proto: "user"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _device: Events_DeviceMetadata? = nil
    var _status: Events_Status? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _device = source._device
      _status = source._status
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DeviceEvent2, rhs: Events_DeviceEvent2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OneOf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OneOf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserLogin"),
    2: .same(proto: "UserCreate"),
    3: .same(proto: "UserDelete"),
    4: .same(proto: "UserPasswordChange"),
    5: .same(proto: "SessionStart"),
    6: .same(proto: "SessionJoin"),
    7: .same(proto: "SessionPrint"),
    8: .same(proto: "SessionReject"),
    9: .same(proto: "Resize"),
    10: .same(proto: "SessionEnd"),
    11: .same(proto: "SessionCommand"),
    12: .same(proto: "SessionDisk"),
    13: .same(proto: "SessionNetwork"),
    14: .same(proto: "SessionData"),
    15: .same(proto: "SessionLeave"),
    16: .same(proto: "PortForward"),
    17: .same(proto: "X11Forward"),
    18: .same(proto: "SCP"),
    19: .same(proto: "Exec"),
    20: .same(proto: "Subsystem"),
    21: .same(proto: "ClientDisconnect"),
    22: .same(proto: "AuthAttempt"),
    23: .same(proto: "AccessRequestCreate"),
    24: .same(proto: "UserTokenCreate"),
    25: .same(proto: "RoleCreate"),
    26: .same(proto: "RoleDelete"),
    27: .same(proto: "TrustedClusterCreate"),
    28: .same(proto: "TrustedClusterDelete"),
    29: .same(proto: "TrustedClusterTokenCreate"),
    30: .same(proto: "GithubConnectorCreate"),
    31: .same(proto: "GithubConnectorDelete"),
    32: .same(proto: "OIDCConnectorCreate"),
    33: .same(proto: "OIDCConnectorDelete"),
    34: .same(proto: "SAMLConnectorCreate"),
    35: .same(proto: "SAMLConnectorDelete"),
    36: .same(proto: "KubeRequest"),
    37: .same(proto: "AppSessionStart"),
    38: .same(proto: "AppSessionChunk"),
    39: .same(proto: "AppSessionRequest"),
    40: .same(proto: "DatabaseSessionStart"),
    41: .same(proto: "DatabaseSessionEnd"),
    42: .same(proto: "DatabaseSessionQuery"),
    43: .same(proto: "SessionUpload"),
    44: .same(proto: "MFADeviceAdd"),
    45: .same(proto: "MFADeviceDelete"),
    46: .same(proto: "BillingInformationUpdate"),
    47: .same(proto: "BillingCardCreate"),
    48: .same(proto: "BillingCardDelete"),
    49: .same(proto: "LockCreate"),
    50: .same(proto: "LockDelete"),
    51: .same(proto: "RecoveryCodeGenerate"),
    52: .same(proto: "RecoveryCodeUsed"),
    53: .same(proto: "DatabaseCreate"),
    54: .same(proto: "DatabaseUpdate"),
    55: .same(proto: "DatabaseDelete"),
    56: .same(proto: "AppCreate"),
    57: .same(proto: "AppUpdate"),
    58: .same(proto: "AppDelete"),
    59: .same(proto: "WindowsDesktopSessionStart"),
    60: .same(proto: "WindowsDesktopSessionEnd"),
    61: .same(proto: "PostgresParse"),
    62: .same(proto: "PostgresBind"),
    63: .same(proto: "PostgresExecute"),
    64: .same(proto: "PostgresClose"),
    65: .same(proto: "PostgresFunctionCall"),
    66: .same(proto: "AccessRequestDelete"),
    67: .same(proto: "SessionConnect"),
    68: .same(proto: "CertificateCreate"),
    69: .same(proto: "DesktopRecording"),
    70: .same(proto: "DesktopClipboardSend"),
    71: .same(proto: "DesktopClipboardReceive"),
    72: .same(proto: "MySQLStatementPrepare"),
    73: .same(proto: "MySQLStatementExecute"),
    74: .same(proto: "MySQLStatementSendLongData"),
    75: .same(proto: "MySQLStatementClose"),
    76: .same(proto: "MySQLStatementReset"),
    77: .same(proto: "MySQLStatementFetch"),
    78: .same(proto: "MySQLStatementBulkExecute"),
    79: .same(proto: "RenewableCertificateGenerationMismatch"),
    80: .same(proto: "Unknown"),
    81: .same(proto: "MySQLInitDB"),
    82: .same(proto: "MySQLCreateDB"),
    83: .same(proto: "MySQLDropDB"),
    84: .same(proto: "MySQLShutDown"),
    85: .same(proto: "MySQLProcessKill"),
    86: .same(proto: "MySQLDebug"),
    87: .same(proto: "MySQLRefresh"),
    88: .same(proto: "AccessRequestResourceSearch"),
    89: .same(proto: "SQLServerRPCRequest"),
    90: .same(proto: "DatabaseSessionMalformedPacket"),
    91: .same(proto: "SFTP"),
    92: .same(proto: "UpgradeWindowStartUpdate"),
    93: .same(proto: "AppSessionEnd"),
    94: .same(proto: "SessionRecordingAccess"),
    96: .same(proto: "KubernetesClusterCreate"),
    97: .same(proto: "KubernetesClusterUpdate"),
    98: .same(proto: "KubernetesClusterDelete"),
    99: .same(proto: "SSMRun"),
    100: .same(proto: "ElasticsearchRequest"),
    101: .same(proto: "CassandraBatch"),
    102: .same(proto: "CassandraPrepare"),
    103: .same(proto: "CassandraRegister"),
    104: .same(proto: "CassandraExecute"),
    105: .same(proto: "AppSessionDynamoDBRequest"),
    106: .same(proto: "DesktopSharedDirectoryStart"),
    107: .same(proto: "DesktopSharedDirectoryRead"),
    108: .same(proto: "DesktopSharedDirectoryWrite"),
    109: .same(proto: "DynamoDBRequest"),
    110: .same(proto: "BotJoin"),
    111: .same(proto: "InstanceJoin"),
    112: .same(proto: "DeviceEvent"),
    113: .same(proto: "LoginRuleCreate"),
    114: .same(proto: "LoginRuleDelete"),
    115: .same(proto: "SAMLIdPAuthAttempt"),
    116: .same(proto: "SAMLIdPServiceProviderCreate"),
    117: .same(proto: "SAMLIdPServiceProviderUpdate"),
    118: .same(proto: "SAMLIdPServiceProviderDelete"),
    119: .same(proto: "SAMLIdPServiceProviderDeleteAll"),
    120: .same(proto: "OpenSearchRequest"),
    121: .same(proto: "DeviceEvent2"),
    122: .same(proto: "OktaResourcesUpdate"),
    123: .same(proto: "OktaSyncFailure"),
    124: .same(proto: "OktaAssignmentResult"),
    125: .same(proto: "ProvisionTokenCreate"),
    126: .same(proto: "AccessListCreate"),
    127: .same(proto: "AccessListUpdate"),
    128: .same(proto: "AccessListDelete"),
    129: .same(proto: "AccessListReview"),
    130: .same(proto: "AccessListMemberCreate"),
    131: .same(proto: "AccessListMemberUpdate"),
    132: .same(proto: "AccessListMemberDelete"),
    133: .same(proto: "AccessListMemberDeleteAllForAccessList"),
    134: .same(proto: "AuditQueryRun"),
    135: .same(proto: "SecurityReportRun"),
    136: .same(proto: "GithubConnectorUpdate"),
    137: .same(proto: "OIDCConnectorUpdate"),
    138: .same(proto: "SAMLConnectorUpdate"),
    139: .same(proto: "RoleUpdate"),
    140: .same(proto: "UserUpdate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Events_UserLogin?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .userLogin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .userLogin(v)
        }
      }()
      case 2: try {
        var v: Events_UserCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .userCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .userCreate(v)
        }
      }()
      case 3: try {
        var v: Events_UserDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .userDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .userDelete(v)
        }
      }()
      case 4: try {
        var v: Events_UserPasswordChange?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .userPasswordChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .userPasswordChange(v)
        }
      }()
      case 5: try {
        var v: Events_SessionStart?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionStart(v)
        }
      }()
      case 6: try {
        var v: Events_SessionJoin?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionJoin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionJoin(v)
        }
      }()
      case 7: try {
        var v: Events_SessionPrint?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionPrint(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionPrint(v)
        }
      }()
      case 8: try {
        var v: Events_SessionReject?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionReject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionReject(v)
        }
      }()
      case 9: try {
        var v: Events_Resize?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .resize(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .resize(v)
        }
      }()
      case 10: try {
        var v: Events_SessionEnd?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionEnd(v)
        }
      }()
      case 11: try {
        var v: Events_SessionCommand?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionCommand(v)
        }
      }()
      case 12: try {
        var v: Events_SessionDisk?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionDisk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionDisk(v)
        }
      }()
      case 13: try {
        var v: Events_SessionNetwork?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionNetwork(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionNetwork(v)
        }
      }()
      case 14: try {
        var v: Events_SessionData?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionData(v)
        }
      }()
      case 15: try {
        var v: Events_SessionLeave?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionLeave(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionLeave(v)
        }
      }()
      case 16: try {
        var v: Events_PortForward?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .portForward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .portForward(v)
        }
      }()
      case 17: try {
        var v: Events_X11Forward?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .x11Forward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .x11Forward(v)
        }
      }()
      case 18: try {
        var v: Events_SCP?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .scp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .scp(v)
        }
      }()
      case 19: try {
        var v: Events_Exec?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .exec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .exec(v)
        }
      }()
      case 20: try {
        var v: Events_Subsystem?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .subsystem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .subsystem(v)
        }
      }()
      case 21: try {
        var v: Events_ClientDisconnect?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .clientDisconnect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .clientDisconnect(v)
        }
      }()
      case 22: try {
        var v: Events_AuthAttempt?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .authAttempt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .authAttempt(v)
        }
      }()
      case 23: try {
        var v: Events_AccessRequestCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessRequestCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessRequestCreate(v)
        }
      }()
      case 24: try {
        var v: Events_UserTokenCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .userTokenCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .userTokenCreate(v)
        }
      }()
      case 25: try {
        var v: Events_RoleCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .roleCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .roleCreate(v)
        }
      }()
      case 26: try {
        var v: Events_RoleDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .roleDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .roleDelete(v)
        }
      }()
      case 27: try {
        var v: Events_TrustedClusterCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .trustedClusterCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .trustedClusterCreate(v)
        }
      }()
      case 28: try {
        var v: Events_TrustedClusterDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .trustedClusterDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .trustedClusterDelete(v)
        }
      }()
      case 29: try {
        var v: Events_TrustedClusterTokenCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .trustedClusterTokenCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .trustedClusterTokenCreate(v)
        }
      }()
      case 30: try {
        var v: Events_GithubConnectorCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .githubConnectorCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .githubConnectorCreate(v)
        }
      }()
      case 31: try {
        var v: Events_GithubConnectorDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .githubConnectorDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .githubConnectorDelete(v)
        }
      }()
      case 32: try {
        var v: Events_OIDCConnectorCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .oidcconnectorCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .oidcconnectorCreate(v)
        }
      }()
      case 33: try {
        var v: Events_OIDCConnectorDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .oidcconnectorDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .oidcconnectorDelete(v)
        }
      }()
      case 34: try {
        var v: Events_SAMLConnectorCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .samlconnectorCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .samlconnectorCreate(v)
        }
      }()
      case 35: try {
        var v: Events_SAMLConnectorDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .samlconnectorDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .samlconnectorDelete(v)
        }
      }()
      case 36: try {
        var v: Events_KubeRequest?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .kubeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .kubeRequest(v)
        }
      }()
      case 37: try {
        var v: Events_AppSessionStart?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .appSessionStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .appSessionStart(v)
        }
      }()
      case 38: try {
        var v: Events_AppSessionChunk?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .appSessionChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .appSessionChunk(v)
        }
      }()
      case 39: try {
        var v: Events_AppSessionRequest?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .appSessionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .appSessionRequest(v)
        }
      }()
      case 40: try {
        var v: Events_DatabaseSessionStart?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .databaseSessionStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .databaseSessionStart(v)
        }
      }()
      case 41: try {
        var v: Events_DatabaseSessionEnd?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .databaseSessionEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .databaseSessionEnd(v)
        }
      }()
      case 42: try {
        var v: Events_DatabaseSessionQuery?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .databaseSessionQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .databaseSessionQuery(v)
        }
      }()
      case 43: try {
        var v: Events_SessionUpload?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionUpload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionUpload(v)
        }
      }()
      case 44: try {
        var v: Events_MFADeviceAdd?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mfadeviceAdd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mfadeviceAdd(v)
        }
      }()
      case 45: try {
        var v: Events_MFADeviceDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mfadeviceDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mfadeviceDelete(v)
        }
      }()
      case 46: try {
        var v: Events_BillingInformationUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .billingInformationUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .billingInformationUpdate(v)
        }
      }()
      case 47: try {
        var v: Events_BillingCardCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .billingCardCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .billingCardCreate(v)
        }
      }()
      case 48: try {
        var v: Events_BillingCardDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .billingCardDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .billingCardDelete(v)
        }
      }()
      case 49: try {
        var v: Events_LockCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .lockCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .lockCreate(v)
        }
      }()
      case 50: try {
        var v: Events_LockDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .lockDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .lockDelete(v)
        }
      }()
      case 51: try {
        var v: Events_RecoveryCodeGenerate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .recoveryCodeGenerate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .recoveryCodeGenerate(v)
        }
      }()
      case 52: try {
        var v: Events_RecoveryCodeUsed?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .recoveryCodeUsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .recoveryCodeUsed(v)
        }
      }()
      case 53: try {
        var v: Events_DatabaseCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .databaseCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .databaseCreate(v)
        }
      }()
      case 54: try {
        var v: Events_DatabaseUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .databaseUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .databaseUpdate(v)
        }
      }()
      case 55: try {
        var v: Events_DatabaseDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .databaseDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .databaseDelete(v)
        }
      }()
      case 56: try {
        var v: Events_AppCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .appCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .appCreate(v)
        }
      }()
      case 57: try {
        var v: Events_AppUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .appUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .appUpdate(v)
        }
      }()
      case 58: try {
        var v: Events_AppDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .appDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .appDelete(v)
        }
      }()
      case 59: try {
        var v: Events_WindowsDesktopSessionStart?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .windowsDesktopSessionStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .windowsDesktopSessionStart(v)
        }
      }()
      case 60: try {
        var v: Events_WindowsDesktopSessionEnd?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .windowsDesktopSessionEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .windowsDesktopSessionEnd(v)
        }
      }()
      case 61: try {
        var v: Events_PostgresParse?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .postgresParse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .postgresParse(v)
        }
      }()
      case 62: try {
        var v: Events_PostgresBind?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .postgresBind(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .postgresBind(v)
        }
      }()
      case 63: try {
        var v: Events_PostgresExecute?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .postgresExecute(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .postgresExecute(v)
        }
      }()
      case 64: try {
        var v: Events_PostgresClose?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .postgresClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .postgresClose(v)
        }
      }()
      case 65: try {
        var v: Events_PostgresFunctionCall?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .postgresFunctionCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .postgresFunctionCall(v)
        }
      }()
      case 66: try {
        var v: Events_AccessRequestDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessRequestDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessRequestDelete(v)
        }
      }()
      case 67: try {
        var v: Events_SessionConnect?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionConnect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionConnect(v)
        }
      }()
      case 68: try {
        var v: Events_CertificateCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .certificateCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .certificateCreate(v)
        }
      }()
      case 69: try {
        var v: Events_DesktopRecording?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .desktopRecording(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .desktopRecording(v)
        }
      }()
      case 70: try {
        var v: Events_DesktopClipboardSend?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .desktopClipboardSend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .desktopClipboardSend(v)
        }
      }()
      case 71: try {
        var v: Events_DesktopClipboardReceive?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .desktopClipboardReceive(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .desktopClipboardReceive(v)
        }
      }()
      case 72: try {
        var v: Events_MySQLStatementPrepare?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlstatementPrepare(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlstatementPrepare(v)
        }
      }()
      case 73: try {
        var v: Events_MySQLStatementExecute?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlstatementExecute(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlstatementExecute(v)
        }
      }()
      case 74: try {
        var v: Events_MySQLStatementSendLongData?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlstatementSendLongData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlstatementSendLongData(v)
        }
      }()
      case 75: try {
        var v: Events_MySQLStatementClose?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlstatementClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlstatementClose(v)
        }
      }()
      case 76: try {
        var v: Events_MySQLStatementReset?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlstatementReset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlstatementReset(v)
        }
      }()
      case 77: try {
        var v: Events_MySQLStatementFetch?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlstatementFetch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlstatementFetch(v)
        }
      }()
      case 78: try {
        var v: Events_MySQLStatementBulkExecute?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlstatementBulkExecute(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlstatementBulkExecute(v)
        }
      }()
      case 79: try {
        var v: Events_RenewableCertificateGenerationMismatch?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .renewableCertificateGenerationMismatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .renewableCertificateGenerationMismatch(v)
        }
      }()
      case 80: try {
        var v: Events_Unknown?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .unknown(v)
        }
      }()
      case 81: try {
        var v: Events_MySQLInitDB?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlinitDb(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlinitDb(v)
        }
      }()
      case 82: try {
        var v: Events_MySQLCreateDB?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlcreateDb(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlcreateDb(v)
        }
      }()
      case 83: try {
        var v: Events_MySQLDropDB?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqldropDb(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqldropDb(v)
        }
      }()
      case 84: try {
        var v: Events_MySQLShutDown?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlshutDown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlshutDown(v)
        }
      }()
      case 85: try {
        var v: Events_MySQLProcessKill?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlprocessKill(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlprocessKill(v)
        }
      }()
      case 86: try {
        var v: Events_MySQLDebug?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqldebug(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqldebug(v)
        }
      }()
      case 87: try {
        var v: Events_MySQLRefresh?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mySqlrefresh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mySqlrefresh(v)
        }
      }()
      case 88: try {
        var v: Events_AccessRequestResourceSearch?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessRequestResourceSearch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessRequestResourceSearch(v)
        }
      }()
      case 89: try {
        var v: Events_SQLServerRPCRequest?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sqlserverRpcrequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sqlserverRpcrequest(v)
        }
      }()
      case 90: try {
        var v: Events_DatabaseSessionMalformedPacket?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .databaseSessionMalformedPacket(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .databaseSessionMalformedPacket(v)
        }
      }()
      case 91: try {
        var v: Events_SFTP?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sftp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sftp(v)
        }
      }()
      case 92: try {
        var v: Events_UpgradeWindowStartUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .upgradeWindowStartUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .upgradeWindowStartUpdate(v)
        }
      }()
      case 93: try {
        var v: Events_AppSessionEnd?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .appSessionEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .appSessionEnd(v)
        }
      }()
      case 94: try {
        var v: Events_SessionRecordingAccess?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sessionRecordingAccess(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sessionRecordingAccess(v)
        }
      }()
      case 96: try {
        var v: Events_KubernetesClusterCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .kubernetesClusterCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .kubernetesClusterCreate(v)
        }
      }()
      case 97: try {
        var v: Events_KubernetesClusterUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .kubernetesClusterUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .kubernetesClusterUpdate(v)
        }
      }()
      case 98: try {
        var v: Events_KubernetesClusterDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .kubernetesClusterDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .kubernetesClusterDelete(v)
        }
      }()
      case 99: try {
        var v: Events_SSMRun?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .ssmrun(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .ssmrun(v)
        }
      }()
      case 100: try {
        var v: Events_ElasticsearchRequest?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .elasticsearchRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .elasticsearchRequest(v)
        }
      }()
      case 101: try {
        var v: Events_CassandraBatch?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .cassandraBatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .cassandraBatch(v)
        }
      }()
      case 102: try {
        var v: Events_CassandraPrepare?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .cassandraPrepare(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .cassandraPrepare(v)
        }
      }()
      case 103: try {
        var v: Events_CassandraRegister?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .cassandraRegister(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .cassandraRegister(v)
        }
      }()
      case 104: try {
        var v: Events_CassandraExecute?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .cassandraExecute(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .cassandraExecute(v)
        }
      }()
      case 105: try {
        var v: Events_AppSessionDynamoDBRequest?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .appSessionDynamoDbrequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .appSessionDynamoDbrequest(v)
        }
      }()
      case 106: try {
        var v: Events_DesktopSharedDirectoryStart?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .desktopSharedDirectoryStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .desktopSharedDirectoryStart(v)
        }
      }()
      case 107: try {
        var v: Events_DesktopSharedDirectoryRead?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .desktopSharedDirectoryRead(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .desktopSharedDirectoryRead(v)
        }
      }()
      case 108: try {
        var v: Events_DesktopSharedDirectoryWrite?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .desktopSharedDirectoryWrite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .desktopSharedDirectoryWrite(v)
        }
      }()
      case 109: try {
        var v: Events_DynamoDBRequest?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .dynamoDbrequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .dynamoDbrequest(v)
        }
      }()
      case 110: try {
        var v: Events_BotJoin?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .botJoin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .botJoin(v)
        }
      }()
      case 111: try {
        var v: Events_InstanceJoin?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .instanceJoin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .instanceJoin(v)
        }
      }()
      case 112: try {
        var v: Events_DeviceEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .deviceEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .deviceEvent(v)
        }
      }()
      case 113: try {
        var v: Events_LoginRuleCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .loginRuleCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .loginRuleCreate(v)
        }
      }()
      case 114: try {
        var v: Events_LoginRuleDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .loginRuleDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .loginRuleDelete(v)
        }
      }()
      case 115: try {
        var v: Events_SAMLIdPAuthAttempt?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .samlidPauthAttempt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .samlidPauthAttempt(v)
        }
      }()
      case 116: try {
        var v: Events_SAMLIdPServiceProviderCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .samlidPserviceProviderCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .samlidPserviceProviderCreate(v)
        }
      }()
      case 117: try {
        var v: Events_SAMLIdPServiceProviderUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .samlidPserviceProviderUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .samlidPserviceProviderUpdate(v)
        }
      }()
      case 118: try {
        var v: Events_SAMLIdPServiceProviderDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .samlidPserviceProviderDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .samlidPserviceProviderDelete(v)
        }
      }()
      case 119: try {
        var v: Events_SAMLIdPServiceProviderDeleteAll?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .samlidPserviceProviderDeleteAll(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .samlidPserviceProviderDeleteAll(v)
        }
      }()
      case 120: try {
        var v: Events_OpenSearchRequest?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .openSearchRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .openSearchRequest(v)
        }
      }()
      case 121: try {
        var v: Events_DeviceEvent2?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .deviceEvent2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .deviceEvent2(v)
        }
      }()
      case 122: try {
        var v: Events_OktaResourcesUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .oktaResourcesUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .oktaResourcesUpdate(v)
        }
      }()
      case 123: try {
        var v: Events_OktaSyncFailure?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .oktaSyncFailure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .oktaSyncFailure(v)
        }
      }()
      case 124: try {
        var v: Events_OktaAssignmentResult?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .oktaAssignmentResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .oktaAssignmentResult(v)
        }
      }()
      case 125: try {
        var v: Events_ProvisionTokenCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .provisionTokenCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .provisionTokenCreate(v)
        }
      }()
      case 126: try {
        var v: Events_AccessListCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListCreate(v)
        }
      }()
      case 127: try {
        var v: Events_AccessListUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListUpdate(v)
        }
      }()
      case 128: try {
        var v: Events_AccessListDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListDelete(v)
        }
      }()
      case 129: try {
        var v: Events_AccessListReview?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListReview(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListReview(v)
        }
      }()
      case 130: try {
        var v: Events_AccessListMemberCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListMemberCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListMemberCreate(v)
        }
      }()
      case 131: try {
        var v: Events_AccessListMemberUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListMemberUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListMemberUpdate(v)
        }
      }()
      case 132: try {
        var v: Events_AccessListMemberDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListMemberDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListMemberDelete(v)
        }
      }()
      case 133: try {
        var v: Events_AccessListMemberDeleteAllForAccessList?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListMemberDeleteAllForAccessList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListMemberDeleteAllForAccessList(v)
        }
      }()
      case 134: try {
        var v: Events_AuditQueryRun?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .auditQueryRun(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .auditQueryRun(v)
        }
      }()
      case 135: try {
        var v: Events_SecurityReportRun?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .securityReportRun(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .securityReportRun(v)
        }
      }()
      case 136: try {
        var v: Events_GithubConnectorUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .githubConnectorUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .githubConnectorUpdate(v)
        }
      }()
      case 137: try {
        var v: Events_OIDCConnectorUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .oidcconnectorUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .oidcconnectorUpdate(v)
        }
      }()
      case 138: try {
        var v: Events_SAMLConnectorUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .samlconnectorUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .samlconnectorUpdate(v)
        }
      }()
      case 139: try {
        var v: Events_RoleUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .roleUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .roleUpdate(v)
        }
      }()
      case 140: try {
        var v: Events_UserUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .userUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .userUpdate(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .userLogin?: try {
      guard case .userLogin(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .userCreate?: try {
      guard case .userCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .userDelete?: try {
      guard case .userDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .userPasswordChange?: try {
      guard case .userPasswordChange(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .sessionStart?: try {
      guard case .sessionStart(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .sessionJoin?: try {
      guard case .sessionJoin(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .sessionPrint?: try {
      guard case .sessionPrint(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .sessionReject?: try {
      guard case .sessionReject(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .resize?: try {
      guard case .resize(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .sessionEnd?: try {
      guard case .sessionEnd(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .sessionCommand?: try {
      guard case .sessionCommand(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .sessionDisk?: try {
      guard case .sessionDisk(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .sessionNetwork?: try {
      guard case .sessionNetwork(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .sessionData?: try {
      guard case .sessionData(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .sessionLeave?: try {
      guard case .sessionLeave(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .portForward?: try {
      guard case .portForward(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .x11Forward?: try {
      guard case .x11Forward(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .scp?: try {
      guard case .scp(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .exec?: try {
      guard case .exec(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .subsystem?: try {
      guard case .subsystem(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .clientDisconnect?: try {
      guard case .clientDisconnect(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .authAttempt?: try {
      guard case .authAttempt(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .accessRequestCreate?: try {
      guard case .accessRequestCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .userTokenCreate?: try {
      guard case .userTokenCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .roleCreate?: try {
      guard case .roleCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .roleDelete?: try {
      guard case .roleDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .trustedClusterCreate?: try {
      guard case .trustedClusterCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .trustedClusterDelete?: try {
      guard case .trustedClusterDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .trustedClusterTokenCreate?: try {
      guard case .trustedClusterTokenCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .githubConnectorCreate?: try {
      guard case .githubConnectorCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .githubConnectorDelete?: try {
      guard case .githubConnectorDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .oidcconnectorCreate?: try {
      guard case .oidcconnectorCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .oidcconnectorDelete?: try {
      guard case .oidcconnectorDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .samlconnectorCreate?: try {
      guard case .samlconnectorCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .samlconnectorDelete?: try {
      guard case .samlconnectorDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .kubeRequest?: try {
      guard case .kubeRequest(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .appSessionStart?: try {
      guard case .appSessionStart(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .appSessionChunk?: try {
      guard case .appSessionChunk(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .appSessionRequest?: try {
      guard case .appSessionRequest(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .databaseSessionStart?: try {
      guard case .databaseSessionStart(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .databaseSessionEnd?: try {
      guard case .databaseSessionEnd(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .databaseSessionQuery?: try {
      guard case .databaseSessionQuery(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .sessionUpload?: try {
      guard case .sessionUpload(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .mfadeviceAdd?: try {
      guard case .mfadeviceAdd(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .mfadeviceDelete?: try {
      guard case .mfadeviceDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .billingInformationUpdate?: try {
      guard case .billingInformationUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .billingCardCreate?: try {
      guard case .billingCardCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .billingCardDelete?: try {
      guard case .billingCardDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .lockCreate?: try {
      guard case .lockCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .lockDelete?: try {
      guard case .lockDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .recoveryCodeGenerate?: try {
      guard case .recoveryCodeGenerate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .recoveryCodeUsed?: try {
      guard case .recoveryCodeUsed(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .databaseCreate?: try {
      guard case .databaseCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .databaseUpdate?: try {
      guard case .databaseUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .databaseDelete?: try {
      guard case .databaseDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .appCreate?: try {
      guard case .appCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
    }()
    case .appUpdate?: try {
      guard case .appUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
    }()
    case .appDelete?: try {
      guard case .appDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
    }()
    case .windowsDesktopSessionStart?: try {
      guard case .windowsDesktopSessionStart(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
    }()
    case .windowsDesktopSessionEnd?: try {
      guard case .windowsDesktopSessionEnd(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
    }()
    case .postgresParse?: try {
      guard case .postgresParse(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case .postgresBind?: try {
      guard case .postgresBind(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
    }()
    case .postgresExecute?: try {
      guard case .postgresExecute(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
    }()
    case .postgresClose?: try {
      guard case .postgresClose(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
    }()
    case .postgresFunctionCall?: try {
      guard case .postgresFunctionCall(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
    }()
    case .accessRequestDelete?: try {
      guard case .accessRequestDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
    }()
    case .sessionConnect?: try {
      guard case .sessionConnect(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
    }()
    case .certificateCreate?: try {
      guard case .certificateCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
    }()
    case .desktopRecording?: try {
      guard case .desktopRecording(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
    }()
    case .desktopClipboardSend?: try {
      guard case .desktopClipboardSend(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
    }()
    case .desktopClipboardReceive?: try {
      guard case .desktopClipboardReceive(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
    }()
    case .mySqlstatementPrepare?: try {
      guard case .mySqlstatementPrepare(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
    }()
    case .mySqlstatementExecute?: try {
      guard case .mySqlstatementExecute(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
    }()
    case .mySqlstatementSendLongData?: try {
      guard case .mySqlstatementSendLongData(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
    }()
    case .mySqlstatementClose?: try {
      guard case .mySqlstatementClose(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 75)
    }()
    case .mySqlstatementReset?: try {
      guard case .mySqlstatementReset(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 76)
    }()
    case .mySqlstatementFetch?: try {
      guard case .mySqlstatementFetch(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
    }()
    case .mySqlstatementBulkExecute?: try {
      guard case .mySqlstatementBulkExecute(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
    }()
    case .renewableCertificateGenerationMismatch?: try {
      guard case .renewableCertificateGenerationMismatch(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
    }()
    case .unknown?: try {
      guard case .unknown(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
    }()
    case .mySqlinitDb?: try {
      guard case .mySqlinitDb(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
    }()
    case .mySqlcreateDb?: try {
      guard case .mySqlcreateDb(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
    }()
    case .mySqldropDb?: try {
      guard case .mySqldropDb(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 83)
    }()
    case .mySqlshutDown?: try {
      guard case .mySqlshutDown(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
    }()
    case .mySqlprocessKill?: try {
      guard case .mySqlprocessKill(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
    }()
    case .mySqldebug?: try {
      guard case .mySqldebug(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
    }()
    case .mySqlrefresh?: try {
      guard case .mySqlrefresh(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
    }()
    case .accessRequestResourceSearch?: try {
      guard case .accessRequestResourceSearch(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
    }()
    case .sqlserverRpcrequest?: try {
      guard case .sqlserverRpcrequest(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 89)
    }()
    case .databaseSessionMalformedPacket?: try {
      guard case .databaseSessionMalformedPacket(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
    }()
    case .sftp?: try {
      guard case .sftp(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
    }()
    case .upgradeWindowStartUpdate?: try {
      guard case .upgradeWindowStartUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 92)
    }()
    case .appSessionEnd?: try {
      guard case .appSessionEnd(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 93)
    }()
    case .sessionRecordingAccess?: try {
      guard case .sessionRecordingAccess(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 94)
    }()
    case .kubernetesClusterCreate?: try {
      guard case .kubernetesClusterCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 96)
    }()
    case .kubernetesClusterUpdate?: try {
      guard case .kubernetesClusterUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 97)
    }()
    case .kubernetesClusterDelete?: try {
      guard case .kubernetesClusterDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }()
    case .ssmrun?: try {
      guard case .ssmrun(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }()
    case .elasticsearchRequest?: try {
      guard case .elasticsearchRequest(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .cassandraBatch?: try {
      guard case .cassandraBatch(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .cassandraPrepare?: try {
      guard case .cassandraPrepare(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .cassandraRegister?: try {
      guard case .cassandraRegister(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .cassandraExecute?: try {
      guard case .cassandraExecute(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .appSessionDynamoDbrequest?: try {
      guard case .appSessionDynamoDbrequest(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .desktopSharedDirectoryStart?: try {
      guard case .desktopSharedDirectoryStart(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .desktopSharedDirectoryRead?: try {
      guard case .desktopSharedDirectoryRead(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .desktopSharedDirectoryWrite?: try {
      guard case .desktopSharedDirectoryWrite(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .dynamoDbrequest?: try {
      guard case .dynamoDbrequest(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .botJoin?: try {
      guard case .botJoin(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .instanceJoin?: try {
      guard case .instanceJoin(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
    }()
    case .deviceEvent?: try {
      guard case .deviceEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
    }()
    case .loginRuleCreate?: try {
      guard case .loginRuleCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
    }()
    case .loginRuleDelete?: try {
      guard case .loginRuleDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
    }()
    case .samlidPauthAttempt?: try {
      guard case .samlidPauthAttempt(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
    }()
    case .samlidPserviceProviderCreate?: try {
      guard case .samlidPserviceProviderCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
    }()
    case .samlidPserviceProviderUpdate?: try {
      guard case .samlidPserviceProviderUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
    }()
    case .samlidPserviceProviderDelete?: try {
      guard case .samlidPserviceProviderDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
    }()
    case .samlidPserviceProviderDeleteAll?: try {
      guard case .samlidPserviceProviderDeleteAll(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 119)
    }()
    case .openSearchRequest?: try {
      guard case .openSearchRequest(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
    }()
    case .deviceEvent2?: try {
      guard case .deviceEvent2(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
    }()
    case .oktaResourcesUpdate?: try {
      guard case .oktaResourcesUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
    }()
    case .oktaSyncFailure?: try {
      guard case .oktaSyncFailure(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 123)
    }()
    case .oktaAssignmentResult?: try {
      guard case .oktaAssignmentResult(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 124)
    }()
    case .provisionTokenCreate?: try {
      guard case .provisionTokenCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 125)
    }()
    case .accessListCreate?: try {
      guard case .accessListCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 126)
    }()
    case .accessListUpdate?: try {
      guard case .accessListUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 127)
    }()
    case .accessListDelete?: try {
      guard case .accessListDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 128)
    }()
    case .accessListReview?: try {
      guard case .accessListReview(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
    }()
    case .accessListMemberCreate?: try {
      guard case .accessListMemberCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
    }()
    case .accessListMemberUpdate?: try {
      guard case .accessListMemberUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 131)
    }()
    case .accessListMemberDelete?: try {
      guard case .accessListMemberDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 132)
    }()
    case .accessListMemberDeleteAllForAccessList?: try {
      guard case .accessListMemberDeleteAllForAccessList(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 133)
    }()
    case .auditQueryRun?: try {
      guard case .auditQueryRun(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 134)
    }()
    case .securityReportRun?: try {
      guard case .securityReportRun(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 135)
    }()
    case .githubConnectorUpdate?: try {
      guard case .githubConnectorUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 136)
    }()
    case .oidcconnectorUpdate?: try {
      guard case .oidcconnectorUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 137)
    }()
    case .samlconnectorUpdate?: try {
      guard case .samlconnectorUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 138)
    }()
    case .roleUpdate?: try {
      guard case .roleUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 139)
    }()
    case .userUpdate?: try {
      guard case .userUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 140)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OneOf, rhs: Events_OneOf) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_StreamStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UploadID"),
    2: .same(proto: "LastEventIndex"),
    3: .same(proto: "LastUploadTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uploadID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.lastEventIndex) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastUploadTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uploadID.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadID, fieldNumber: 1)
    }
    if self.lastEventIndex != 0 {
      try visitor.visitSingularInt64Field(value: self.lastEventIndex, fieldNumber: 2)
    }
    try { if let v = self._lastUploadTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_StreamStatus, rhs: Events_StreamStatus) -> Bool {
    if lhs.uploadID != rhs.uploadID {return false}
    if lhs.lastEventIndex != rhs.lastEventIndex {return false}
    if lhs._lastUploadTime != rhs._lastUploadTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionUpload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "SessionMetadata"),
    5: .same(proto: "SessionURL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sessionMetadata) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sessionURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sessionMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.sessionURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionURL, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionUpload, rhs: Events_SessionUpload) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._sessionMetadata != rhs._sessionMetadata {return false}
    if lhs.sessionURL != rhs.sessionURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Identity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "Impersonator"),
    3: .same(proto: "Roles"),
    4: .same(proto: "Usage"),
    5: .same(proto: "Logins"),
    6: .same(proto: "KubernetesGroups"),
    7: .same(proto: "KubernetesUsers"),
    8: .same(proto: "Expires"),
    9: .same(proto: "RouteToCluster"),
    10: .same(proto: "KubernetesCluster"),
    11: .same(proto: "Traits"),
    12: .same(proto: "RouteToApp"),
    13: .same(proto: "TeleportCluster"),
    14: .same(proto: "RouteToDatabase"),
    15: .same(proto: "DatabaseNames"),
    16: .same(proto: "DatabaseUsers"),
    17: .same(proto: "MFADeviceUUID"),
    18: .same(proto: "ClientIP"),
    19: .same(proto: "AWSRoleARNs"),
    20: .same(proto: "AccessRequests"),
    21: .same(proto: "DisallowReissue"),
    22: .same(proto: "AllowedResourceIDs"),
    23: .same(proto: "PreviousIdentityExpires"),
    24: .same(proto: "AzureIdentities"),
    25: .same(proto: "GCPServiceAccounts"),
    26: .same(proto: "PrivateKeyPolicy"),
  ]

  fileprivate class _StorageClass {
    var _user: String = String()
    var _impersonator: String = String()
    var _roles: [String] = []
    var _usage: [String] = []
    var _logins: [String] = []
    var _kubernetesGroups: [String] = []
    var _kubernetesUsers: [String] = []
    var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _routeToCluster: String = String()
    var _kubernetesCluster: String = String()
    var _traits: Wrappers_LabelValues? = nil
    var _routeToApp: Events_RouteToApp? = nil
    var _teleportCluster: String = String()
    var _routeToDatabase: Events_RouteToDatabase? = nil
    var _databaseNames: [String] = []
    var _databaseUsers: [String] = []
    var _mfadeviceUuid: String = String()
    var _clientIp: String = String()
    var _awsroleArns: [String] = []
    var _accessRequests: [String] = []
    var _disallowReissue: Bool = false
    var _allowedResourceIds: [Events_ResourceID] = []
    var _previousIdentityExpires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _azureIdentities: [String] = []
    var _gcpserviceAccounts: [String] = []
    var _privateKeyPolicy: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _impersonator = source._impersonator
      _roles = source._roles
      _usage = source._usage
      _logins = source._logins
      _kubernetesGroups = source._kubernetesGroups
      _kubernetesUsers = source._kubernetesUsers
      _expires = source._expires
      _routeToCluster = source._routeToCluster
      _kubernetesCluster = source._kubernetesCluster
      _traits = source._traits
      _routeToApp = source._routeToApp
      _teleportCluster = source._teleportCluster
      _routeToDatabase = source._routeToDatabase
      _databaseNames = source._databaseNames
      _databaseUsers = source._databaseUsers
      _mfadeviceUuid = source._mfadeviceUuid
      _clientIp = source._clientIp
      _awsroleArns = source._awsroleArns
      _accessRequests = source._accessRequests
      _disallowReissue = source._disallowReissue
      _allowedResourceIds = source._allowedResourceIds
      _previousIdentityExpires = source._previousIdentityExpires
      _azureIdentities = source._azureIdentities
      _gcpserviceAccounts = source._gcpserviceAccounts
      _privateKeyPolicy = source._privateKeyPolicy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._user) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._impersonator) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._roles) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._usage) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._logins) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._kubernetesGroups) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._kubernetesUsers) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._expires) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._routeToCluster) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._kubernetesCluster) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._traits) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._routeToApp) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._teleportCluster) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._routeToDatabase) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._databaseNames) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._databaseUsers) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._mfadeviceUuid) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._clientIp) }()
        case 19: try { try decoder.decodeRepeatedStringField(value: &_storage._awsroleArns) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._accessRequests) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._disallowReissue) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._allowedResourceIds) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._previousIdentityExpires) }()
        case 24: try { try decoder.decodeRepeatedStringField(value: &_storage._azureIdentities) }()
        case 25: try { try decoder.decodeRepeatedStringField(value: &_storage._gcpserviceAccounts) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._privateKeyPolicy) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._user.isEmpty {
        try visitor.visitSingularStringField(value: _storage._user, fieldNumber: 1)
      }
      if !_storage._impersonator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._impersonator, fieldNumber: 2)
      }
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roles, fieldNumber: 3)
      }
      if !_storage._usage.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._usage, fieldNumber: 4)
      }
      if !_storage._logins.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._logins, fieldNumber: 5)
      }
      if !_storage._kubernetesGroups.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._kubernetesGroups, fieldNumber: 6)
      }
      if !_storage._kubernetesUsers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._kubernetesUsers, fieldNumber: 7)
      }
      try { if let v = _storage._expires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._routeToCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._routeToCluster, fieldNumber: 9)
      }
      if !_storage._kubernetesCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kubernetesCluster, fieldNumber: 10)
      }
      try { if let v = _storage._traits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._routeToApp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._teleportCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._teleportCluster, fieldNumber: 13)
      }
      try { if let v = _storage._routeToDatabase {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._databaseNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._databaseNames, fieldNumber: 15)
      }
      if !_storage._databaseUsers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._databaseUsers, fieldNumber: 16)
      }
      if !_storage._mfadeviceUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mfadeviceUuid, fieldNumber: 17)
      }
      if !_storage._clientIp.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientIp, fieldNumber: 18)
      }
      if !_storage._awsroleArns.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._awsroleArns, fieldNumber: 19)
      }
      if !_storage._accessRequests.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._accessRequests, fieldNumber: 20)
      }
      if _storage._disallowReissue != false {
        try visitor.visitSingularBoolField(value: _storage._disallowReissue, fieldNumber: 21)
      }
      if !_storage._allowedResourceIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allowedResourceIds, fieldNumber: 22)
      }
      try { if let v = _storage._previousIdentityExpires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if !_storage._azureIdentities.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._azureIdentities, fieldNumber: 24)
      }
      if !_storage._gcpserviceAccounts.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._gcpserviceAccounts, fieldNumber: 25)
      }
      if !_storage._privateKeyPolicy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._privateKeyPolicy, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_Identity, rhs: Events_Identity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._impersonator != rhs_storage._impersonator {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._usage != rhs_storage._usage {return false}
        if _storage._logins != rhs_storage._logins {return false}
        if _storage._kubernetesGroups != rhs_storage._kubernetesGroups {return false}
        if _storage._kubernetesUsers != rhs_storage._kubernetesUsers {return false}
        if _storage._expires != rhs_storage._expires {return false}
        if _storage._routeToCluster != rhs_storage._routeToCluster {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        if _storage._traits != rhs_storage._traits {return false}
        if _storage._routeToApp != rhs_storage._routeToApp {return false}
        if _storage._teleportCluster != rhs_storage._teleportCluster {return false}
        if _storage._routeToDatabase != rhs_storage._routeToDatabase {return false}
        if _storage._databaseNames != rhs_storage._databaseNames {return false}
        if _storage._databaseUsers != rhs_storage._databaseUsers {return false}
        if _storage._mfadeviceUuid != rhs_storage._mfadeviceUuid {return false}
        if _storage._clientIp != rhs_storage._clientIp {return false}
        if _storage._awsroleArns != rhs_storage._awsroleArns {return false}
        if _storage._accessRequests != rhs_storage._accessRequests {return false}
        if _storage._disallowReissue != rhs_storage._disallowReissue {return false}
        if _storage._allowedResourceIds != rhs_storage._allowedResourceIds {return false}
        if _storage._previousIdentityExpires != rhs_storage._previousIdentityExpires {return false}
        if _storage._azureIdentities != rhs_storage._azureIdentities {return false}
        if _storage._gcpserviceAccounts != rhs_storage._gcpserviceAccounts {return false}
        if _storage._privateKeyPolicy != rhs_storage._privateKeyPolicy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_RouteToApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteToApp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "SessionID"),
    3: .same(proto: "PublicAddr"),
    4: .same(proto: "ClusterName"),
    5: .same(proto: "AWSRoleARN"),
    6: .same(proto: "AzureIdentity"),
    7: .same(proto: "GCPServiceAccount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicAddr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.awsroleArn) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.azureIdentity) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.gcpserviceAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if !self.publicAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.publicAddr, fieldNumber: 3)
    }
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 4)
    }
    if !self.awsroleArn.isEmpty {
      try visitor.visitSingularStringField(value: self.awsroleArn, fieldNumber: 5)
    }
    if !self.azureIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.azureIdentity, fieldNumber: 6)
    }
    if !self.gcpserviceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.gcpserviceAccount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_RouteToApp, rhs: Events_RouteToApp) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.publicAddr != rhs.publicAddr {return false}
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.awsroleArn != rhs.awsroleArn {return false}
    if lhs.azureIdentity != rhs.azureIdentity {return false}
    if lhs.gcpserviceAccount != rhs.gcpserviceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_RouteToDatabase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteToDatabase"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServiceName"),
    2: .same(proto: "Protocol"),
    3: .same(proto: "Username"),
    4: .same(proto: "Database"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.database) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 1)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_RouteToDatabase, rhs: Events_RouteToDatabase) -> Bool {
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.username != rhs.username {return false}
    if lhs.database != rhs.database {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessRequestResourceSearch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestResourceSearch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "SearchAsRoles"),
    4: .same(proto: "ResourceType"),
    5: .same(proto: "Namespace"),
    6: .same(proto: "Labels"),
    7: .same(proto: "PredicateExpression"),
    8: .same(proto: "SearchKeywords"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _searchAsRoles: [String] = []
    var _resourceType: String = String()
    var _namespace: String = String()
    var _labels: Dictionary<String,String> = [:]
    var _predicateExpression: String = String()
    var _searchKeywords: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _searchAsRoles = source._searchAsRoles
      _resourceType = source._resourceType
      _namespace = source._namespace
      _labels = source._labels
      _predicateExpression = source._predicateExpression
      _searchKeywords = source._searchKeywords
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._searchAsRoles) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._resourceType) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._predicateExpression) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._searchKeywords) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._searchAsRoles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._searchAsRoles, fieldNumber: 3)
      }
      if !_storage._resourceType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceType, fieldNumber: 4)
      }
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 5)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 6)
      }
      if !_storage._predicateExpression.isEmpty {
        try visitor.visitSingularStringField(value: _storage._predicateExpression, fieldNumber: 7)
      }
      if !_storage._searchKeywords.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._searchKeywords, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessRequestResourceSearch, rhs: Events_AccessRequestResourceSearch) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._searchAsRoles != rhs_storage._searchAsRoles {return false}
        if _storage._resourceType != rhs_storage._resourceType {return false}
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._predicateExpression != rhs_storage._predicateExpression {return false}
        if _storage._searchKeywords != rhs_storage._searchKeywords {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLStatementPrepare: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLStatementPrepare"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "Query"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _query: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _query = source._query
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._query) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._query.isEmpty {
        try visitor.visitSingularStringField(value: _storage._query, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLStatementPrepare, rhs: Events_MySQLStatementPrepare) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._query != rhs_storage._query {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLStatementExecute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLStatementExecute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "StatementID"),
    6: .same(proto: "Parameters"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _statementID: UInt32 = 0
    var _parameters: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _statementID = source._statementID
      _parameters = source._parameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._statementID) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._parameters) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._statementID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statementID, fieldNumber: 5)
      }
      if !_storage._parameters.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._parameters, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLStatementExecute, rhs: Events_MySQLStatementExecute) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._statementID != rhs_storage._statementID {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLStatementSendLongData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLStatementSendLongData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "StatementID"),
    6: .same(proto: "ParameterID"),
    7: .same(proto: "DataSize"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _statementID: UInt32 = 0
    var _parameterID: UInt32 = 0
    var _dataSize: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _statementID = source._statementID
      _parameterID = source._parameterID
      _dataSize = source._dataSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._statementID) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._parameterID) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._dataSize) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._statementID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statementID, fieldNumber: 5)
      }
      if _storage._parameterID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._parameterID, fieldNumber: 6)
      }
      if _storage._dataSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._dataSize, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLStatementSendLongData, rhs: Events_MySQLStatementSendLongData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._statementID != rhs_storage._statementID {return false}
        if _storage._parameterID != rhs_storage._parameterID {return false}
        if _storage._dataSize != rhs_storage._dataSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLStatementClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLStatementClose"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "StatementID"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _statementID: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _statementID = source._statementID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._statementID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._statementID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statementID, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLStatementClose, rhs: Events_MySQLStatementClose) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._statementID != rhs_storage._statementID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLStatementReset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLStatementReset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "StatementID"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _statementID: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _statementID = source._statementID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._statementID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._statementID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statementID, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLStatementReset, rhs: Events_MySQLStatementReset) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._statementID != rhs_storage._statementID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLStatementFetch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLStatementFetch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "StatementID"),
    6: .same(proto: "RowsCount"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _statementID: UInt32 = 0
    var _rowsCount: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _statementID = source._statementID
      _rowsCount = source._rowsCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._statementID) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._rowsCount) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._statementID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statementID, fieldNumber: 5)
      }
      if _storage._rowsCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rowsCount, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLStatementFetch, rhs: Events_MySQLStatementFetch) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._statementID != rhs_storage._statementID {return false}
        if _storage._rowsCount != rhs_storage._rowsCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLStatementBulkExecute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLStatementBulkExecute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "StatementID"),
    6: .same(proto: "Parameters"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _statementID: UInt32 = 0
    var _parameters: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _statementID = source._statementID
      _parameters = source._parameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._statementID) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._parameters) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._statementID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statementID, fieldNumber: 5)
      }
      if !_storage._parameters.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._parameters, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLStatementBulkExecute, rhs: Events_MySQLStatementBulkExecute) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._statementID != rhs_storage._statementID {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLInitDB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLInitDB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "SchemaName"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _schemaName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _schemaName = source._schemaName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._schemaName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._schemaName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._schemaName, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLInitDB, rhs: Events_MySQLInitDB) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._schemaName != rhs_storage._schemaName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLCreateDB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLCreateDB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "SchemaName"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _schemaName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _schemaName = source._schemaName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._schemaName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._schemaName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._schemaName, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLCreateDB, rhs: Events_MySQLCreateDB) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._schemaName != rhs_storage._schemaName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLDropDB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLDropDB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "SchemaName"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _schemaName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _schemaName = source._schemaName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._schemaName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._schemaName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._schemaName, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLDropDB, rhs: Events_MySQLDropDB) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._schemaName != rhs_storage._schemaName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLShutDown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLShutDown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLShutDown, rhs: Events_MySQLShutDown) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLProcessKill: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLProcessKill"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "ProcessID"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _processID: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _processID = source._processID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._processID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._processID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._processID, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLProcessKill, rhs: Events_MySQLProcessKill) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._processID != rhs_storage._processID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLDebug: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLDebug"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLDebug, rhs: Events_MySQLDebug) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MySQLRefresh: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLRefresh"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "Subcommand"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _subcommand: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _subcommand = source._subcommand
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._subcommand) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._subcommand.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subcommand, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_MySQLRefresh, rhs: Events_MySQLRefresh) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._subcommand != rhs_storage._subcommand {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SQLServerRPCRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SQLServerRPCRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "Procname"),
    6: .same(proto: "Parameters"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _procname: String = String()
    var _parameters: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _procname = source._procname
      _parameters = source._parameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._procname) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._parameters) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._procname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._procname, fieldNumber: 5)
      }
      if !_storage._parameters.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._parameters, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SQLServerRPCRequest, rhs: Events_SQLServerRPCRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._procname != rhs_storage._procname {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DatabaseSessionMalformedPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseSessionMalformedPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "Payload"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _payload: Data = Data()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._payload) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DatabaseSessionMalformedPacket, rhs: Events_DatabaseSessionMalformedPacket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ElasticsearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ElasticsearchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "Path"),
    6: .same(proto: "RawQuery"),
    7: .same(proto: "Method"),
    8: .same(proto: "Body"),
    9: .same(proto: "Headers"),
    10: .same(proto: "Category"),
    11: .same(proto: "Target"),
    12: .same(proto: "Query"),
    13: .same(proto: "StatusCode"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _path: String = String()
    var _rawQuery: String = String()
    var _method: String = String()
    var _body: Data = Data()
    var _headers: Wrappers_LabelValues? = nil
    var _category: Events_ElasticsearchCategory = .general
    var _target: String = String()
    var _query: String = String()
    var _statusCode: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _path = source._path
      _rawQuery = source._rawQuery
      _method = source._method
      _body = source._body
      _headers = source._headers
      _category = source._category
      _target = source._target
      _query = source._query
      _statusCode = source._statusCode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._rawQuery) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._body) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._headers) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._category) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._target) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._query) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._statusCode) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 5)
      }
      if !_storage._rawQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rawQuery, fieldNumber: 6)
      }
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 7)
      }
      if !_storage._body.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._body, fieldNumber: 8)
      }
      try { if let v = _storage._headers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._category != .general {
        try visitor.visitSingularEnumField(value: _storage._category, fieldNumber: 10)
      }
      if !_storage._target.isEmpty {
        try visitor.visitSingularStringField(value: _storage._target, fieldNumber: 11)
      }
      if !_storage._query.isEmpty {
        try visitor.visitSingularStringField(value: _storage._query, fieldNumber: 12)
      }
      if _storage._statusCode != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statusCode, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_ElasticsearchRequest, rhs: Events_ElasticsearchRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._rawQuery != rhs_storage._rawQuery {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._body != rhs_storage._body {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._statusCode != rhs_storage._statusCode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OpenSearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenSearchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "Path"),
    6: .same(proto: "RawQuery"),
    7: .same(proto: "Method"),
    8: .same(proto: "Body"),
    9: .same(proto: "Headers"),
    10: .same(proto: "Category"),
    11: .same(proto: "Target"),
    12: .same(proto: "Query"),
    13: .same(proto: "StatusCode"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _path: String = String()
    var _rawQuery: String = String()
    var _method: String = String()
    var _body: Data = Data()
    var _headers: Wrappers_LabelValues? = nil
    var _category: Events_OpenSearchCategory = .general
    var _target: String = String()
    var _query: String = String()
    var _statusCode: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _path = source._path
      _rawQuery = source._rawQuery
      _method = source._method
      _body = source._body
      _headers = source._headers
      _category = source._category
      _target = source._target
      _query = source._query
      _statusCode = source._statusCode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._rawQuery) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._body) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._headers) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._category) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._target) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._query) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._statusCode) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 5)
      }
      if !_storage._rawQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rawQuery, fieldNumber: 6)
      }
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 7)
      }
      if !_storage._body.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._body, fieldNumber: 8)
      }
      try { if let v = _storage._headers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._category != .general {
        try visitor.visitSingularEnumField(value: _storage._category, fieldNumber: 10)
      }
      if !_storage._target.isEmpty {
        try visitor.visitSingularStringField(value: _storage._target, fieldNumber: 11)
      }
      if !_storage._query.isEmpty {
        try visitor.visitSingularStringField(value: _storage._query, fieldNumber: 12)
      }
      if _storage._statusCode != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statusCode, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OpenSearchRequest, rhs: Events_OpenSearchRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._rawQuery != rhs_storage._rawQuery {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._body != rhs_storage._body {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._statusCode != rhs_storage._statusCode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_DynamoDBRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DynamoDBRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "StatusCode"),
    6: .same(proto: "Path"),
    7: .same(proto: "RawQuery"),
    8: .same(proto: "Method"),
    9: .same(proto: "Target"),
    10: .same(proto: "Body"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _statusCode: UInt32 = 0
    var _path: String = String()
    var _rawQuery: String = String()
    var _method: String = String()
    var _target: String = String()
    var _body: SwiftProtobuf.Google_Protobuf_Struct? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _statusCode = source._statusCode
      _path = source._path
      _rawQuery = source._rawQuery
      _method = source._method
      _target = source._target
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._statusCode) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._rawQuery) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._target) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._body) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._statusCode != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statusCode, fieldNumber: 5)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 6)
      }
      if !_storage._rawQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rawQuery, fieldNumber: 7)
      }
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 8)
      }
      if !_storage._target.isEmpty {
        try visitor.visitSingularStringField(value: _storage._target, fieldNumber: 9)
      }
      try { if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_DynamoDBRequest, rhs: Events_DynamoDBRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._statusCode != rhs_storage._statusCode {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._rawQuery != rhs_storage._rawQuery {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AppSessionDynamoDBRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppSessionDynamoDBRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "App"),
    4: .same(proto: "AWS"),
    5: .same(proto: "SessionChunkID"),
    6: .same(proto: "StatusCode"),
    7: .same(proto: "Path"),
    8: .same(proto: "RawQuery"),
    9: .same(proto: "Method"),
    10: .same(proto: "Target"),
    11: .same(proto: "Body"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _app: Events_AppMetadata? = nil
    var _aws: Events_AWSRequestMetadata? = nil
    var _sessionChunkID: String = String()
    var _statusCode: UInt32 = 0
    var _path: String = String()
    var _rawQuery: String = String()
    var _method: String = String()
    var _target: String = String()
    var _body: SwiftProtobuf.Google_Protobuf_Struct? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _app = source._app
      _aws = source._aws
      _sessionChunkID = source._sessionChunkID
      _statusCode = source._statusCode
      _path = source._path
      _rawQuery = source._rawQuery
      _method = source._method
      _target = source._target
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._aws) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._sessionChunkID) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._statusCode) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._rawQuery) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._target) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._body) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._aws {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._sessionChunkID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionChunkID, fieldNumber: 5)
      }
      if _storage._statusCode != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._statusCode, fieldNumber: 6)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 7)
      }
      if !_storage._rawQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rawQuery, fieldNumber: 8)
      }
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 9)
      }
      if !_storage._target.isEmpty {
        try visitor.visitSingularStringField(value: _storage._target, fieldNumber: 10)
      }
      try { if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AppSessionDynamoDBRequest, rhs: Events_AppSessionDynamoDBRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._app != rhs_storage._app {return false}
        if _storage._aws != rhs_storage._aws {return false}
        if _storage._sessionChunkID != rhs_storage._sessionChunkID {return false}
        if _storage._statusCode != rhs_storage._statusCode {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._rawQuery != rhs_storage._rawQuery {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_UpgradeWindowStartMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpgradeWindowStartMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UpgradeWindowStart"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.upgradeWindowStart) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.upgradeWindowStart.isEmpty {
      try visitor.visitSingularStringField(value: self.upgradeWindowStart, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_UpgradeWindowStartMetadata, rhs: Events_UpgradeWindowStartMetadata) -> Bool {
    if lhs.upgradeWindowStart != rhs.upgradeWindowStart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_UpgradeWindowStartUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpgradeWindowStartUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "UpgradeWindowStart"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _upgradeWindowStart: Events_UpgradeWindowStartMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _upgradeWindowStart = source._upgradeWindowStart
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._upgradeWindowStart) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._upgradeWindowStart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_UpgradeWindowStartUpdate, rhs: Events_UpgradeWindowStartUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._upgradeWindowStart != rhs_storage._upgradeWindowStart {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SessionRecordingAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionRecordingAccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "SessionID"),
    3: .same(proto: "UserMetadata"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _sessionID: String = String()
    var _userMetadata: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _sessionID = source._sessionID
      _userMetadata = source._userMetadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 2)
      }
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SessionRecordingAccess, rhs: Events_SessionRecordingAccess) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_KubeClusterMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubeClusterMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "KubeLabels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.kubeLabels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kubeLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.kubeLabels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_KubeClusterMetadata, rhs: Events_KubeClusterMetadata) -> Bool {
    if lhs.kubeLabels != rhs.kubeLabels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_KubernetesClusterCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesClusterCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
    4: .same(proto: "KubeClusterMetadata"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _kubeClusterMetadata: Events_KubeClusterMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
      _kubeClusterMetadata = source._kubeClusterMetadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._kubeClusterMetadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._kubeClusterMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_KubernetesClusterCreate, rhs: Events_KubernetesClusterCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._kubeClusterMetadata != rhs_storage._kubeClusterMetadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_KubernetesClusterUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesClusterUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
    4: .same(proto: "KubeClusterMetadata"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _kubeClusterMetadata: Events_KubeClusterMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
      _kubeClusterMetadata = source._kubeClusterMetadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._kubeClusterMetadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._kubeClusterMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_KubernetesClusterUpdate, rhs: Events_KubernetesClusterUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._kubeClusterMetadata != rhs_storage._kubeClusterMetadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_KubernetesClusterDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesClusterDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Resource"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _resource = source._resource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_KubernetesClusterDelete, rhs: Events_KubernetesClusterDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._resource != rhs_storage._resource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SSMRun: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SSMRun"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "CommandID"),
    3: .same(proto: "InstanceID"),
    4: .same(proto: "ExitCode"),
    5: .same(proto: "Status"),
    6: .same(proto: "AccountID"),
    7: .same(proto: "Region"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.commandID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instanceID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.exitCode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.region) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.commandID.isEmpty {
      try visitor.visitSingularStringField(value: self.commandID, fieldNumber: 2)
    }
    if !self.instanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceID, fieldNumber: 3)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt64Field(value: self.exitCode, fieldNumber: 4)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 5)
    }
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 6)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SSMRun, rhs: Events_SSMRun) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.commandID != rhs.commandID {return false}
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.status != rhs.status {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.region != rhs.region {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_CassandraPrepare: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CassandraPrepare"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "Query"),
    6: .same(proto: "Keyspace"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _query: String = String()
    var _keyspace: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _query = source._query
      _keyspace = source._keyspace
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._query) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._keyspace) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._query.isEmpty {
        try visitor.visitSingularStringField(value: _storage._query, fieldNumber: 5)
      }
      if !_storage._keyspace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._keyspace, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_CassandraPrepare, rhs: Events_CassandraPrepare) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._keyspace != rhs_storage._keyspace {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_CassandraExecute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CassandraExecute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "QueryId"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _queryID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _queryID = source._queryID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._queryID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._queryID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._queryID, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_CassandraExecute, rhs: Events_CassandraExecute) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._queryID != rhs_storage._queryID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_CassandraBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CassandraBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "Consistency"),
    6: .same(proto: "Keyspace"),
    7: .same(proto: "BatchType"),
    8: .same(proto: "Children"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _consistency: String = String()
    var _keyspace: String = String()
    var _batchType: String = String()
    var _children: [Events_CassandraBatch.BatchChild] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _consistency = source._consistency
      _keyspace = source._keyspace
      _batchType = source._batchType
      _children = source._children
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._consistency) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._keyspace) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._batchType) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._children) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._consistency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._consistency, fieldNumber: 5)
      }
      if !_storage._keyspace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._keyspace, fieldNumber: 6)
      }
      if !_storage._batchType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._batchType, fieldNumber: 7)
      }
      if !_storage._children.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._children, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_CassandraBatch, rhs: Events_CassandraBatch) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._consistency != rhs_storage._consistency {return false}
        if _storage._keyspace != rhs_storage._keyspace {return false}
        if _storage._batchType != rhs_storage._batchType {return false}
        if _storage._children != rhs_storage._children {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_CassandraBatch.BatchChild: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Events_CassandraBatch.protoMessageName + ".BatchChild"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "Query"),
    3: .same(proto: "Values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 2)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_CassandraBatch.BatchChild, rhs: Events_CassandraBatch.BatchChild) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.query != rhs.query {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_CassandraBatch.BatchChild.Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Events_CassandraBatch.BatchChild.protoMessageName + ".Value"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "Contents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.contents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularUInt32Field(value: self.type, fieldNumber: 1)
    }
    if !self.contents.isEmpty {
      try visitor.visitSingularBytesField(value: self.contents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_CassandraBatch.BatchChild.Value, rhs: Events_CassandraBatch.BatchChild.Value) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_CassandraRegister: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CassandraRegister"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Database"),
    5: .same(proto: "EventTypes"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _database: Events_DatabaseMetadata? = nil
    var _eventTypes: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _database = source._database
      _eventTypes = source._eventTypes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._eventTypes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._eventTypes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._eventTypes, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_CassandraRegister, rhs: Events_CassandraRegister) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._eventTypes != rhs_storage._eventTypes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_LoginRuleCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoginRuleCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_LoginRuleCreate, rhs: Events_LoginRuleCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_LoginRuleDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoginRuleDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "User"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _user: Events_UserMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_LoginRuleDelete, rhs: Events_LoginRuleDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SAMLIdPAuthAttempt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLIdPAuthAttempt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Session"),
    4: .same(proto: "Status"),
    5: .same(proto: "ServiceProvider"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _session: Events_SessionMetadata? = nil
    var _status: Events_Status? = nil
    var _serviceProvider: Events_SAMLIdPServiceProviderMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _session = source._session
      _status = source._status
      _serviceProvider = source._serviceProvider
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._session) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._serviceProvider) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._session {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._serviceProvider {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SAMLIdPAuthAttempt, rhs: Events_SAMLIdPAuthAttempt) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._session != rhs_storage._session {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._serviceProvider != rhs_storage._serviceProvider {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SAMLIdPServiceProviderCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLIdPServiceProviderCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "ServiceProvider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._serviceProvider) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._serviceProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SAMLIdPServiceProviderCreate, rhs: Events_SAMLIdPServiceProviderCreate) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._serviceProvider != rhs._serviceProvider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SAMLIdPServiceProviderUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLIdPServiceProviderUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "ServiceProvider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._serviceProvider) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._serviceProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SAMLIdPServiceProviderUpdate, rhs: Events_SAMLIdPServiceProviderUpdate) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._serviceProvider != rhs._serviceProvider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SAMLIdPServiceProviderDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLIdPServiceProviderDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "ServiceProvider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._serviceProvider) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._serviceProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SAMLIdPServiceProviderDelete, rhs: Events_SAMLIdPServiceProviderDelete) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._serviceProvider != rhs._serviceProvider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SAMLIdPServiceProviderDeleteAll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLIdPServiceProviderDeleteAll"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SAMLIdPServiceProviderDeleteAll, rhs: Events_SAMLIdPServiceProviderDeleteAll) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OktaResourcesUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaResourcesUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Server"),
    3: .same(proto: "Updated"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _updated: Events_OktaResourcesUpdatedMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _server = source._server
      _updated = source._updated
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._updated) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._updated {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OktaResourcesUpdate, rhs: Events_OktaResourcesUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._updated != rhs_storage._updated {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OktaSyncFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaSyncFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Server"),
    3: .same(proto: "Status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _status: Events_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _server = source._server
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OktaSyncFailure, rhs: Events_OktaSyncFailure) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_OktaAssignmentResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaAssignmentResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Server"),
    3: .same(proto: "Resource"),
    4: .same(proto: "Status"),
    5: .same(proto: "OktaAssignment"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _server: Events_ServerMetadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _status: Events_Status? = nil
    var _oktaAssignment: Events_OktaAssignmentMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _server = source._server
      _resource = source._resource
      _status = source._status
      _oktaAssignment = source._oktaAssignment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._server) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._oktaAssignment) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._server {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._oktaAssignment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_OktaAssignmentResult, rhs: Events_OktaAssignmentResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._server != rhs_storage._server {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._oktaAssignment != rhs_storage._oktaAssignment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "Status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListCreate, rhs: Events_AccessListCreate) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "Status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListUpdate, rhs: Events_AccessListUpdate) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "Status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListDelete, rhs: Events_AccessListDelete) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListMemberCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListMemberCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "AccessListMember"),
    4: .same(proto: "Status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _accessListMember: Events_AccessListMemberMetadata? = nil
    var _status: Events_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _accessListMember = source._accessListMember
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._accessListMember) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._accessListMember {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListMemberCreate, rhs: Events_AccessListMemberCreate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._accessListMember != rhs_storage._accessListMember {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListMemberUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListMemberUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "AccessListMember"),
    4: .same(proto: "Status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _accessListMember: Events_AccessListMemberMetadata? = nil
    var _status: Events_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _accessListMember = source._accessListMember
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._accessListMember) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._accessListMember {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListMemberUpdate, rhs: Events_AccessListMemberUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._accessListMember != rhs_storage._accessListMember {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListMemberDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListMemberDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "AccessListMember"),
    4: .same(proto: "Status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _accessListMember: Events_AccessListMemberMetadata? = nil
    var _status: Events_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _accessListMember = source._accessListMember
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._accessListMember) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._accessListMember {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListMemberDelete, rhs: Events_AccessListMemberDelete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._accessListMember != rhs_storage._accessListMember {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListMemberDeleteAllForAccessList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListMemberDeleteAllForAccessList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "AccessListMember"),
    4: .same(proto: "Status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _accessListMember: Events_AccessListMemberMetadata? = nil
    var _status: Events_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _accessListMember = source._accessListMember
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._accessListMember) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._accessListMember {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListMemberDeleteAllForAccessList, rhs: Events_AccessListMemberDeleteAllForAccessList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._accessListMember != rhs_storage._accessListMember {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccessListReview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListReview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "Resource"),
    3: .same(proto: "Review"),
    4: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _resource: Events_ResourceMetadata? = nil
    var _review: Events_AccessListReviewMetadata? = nil
    var _status: Events_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _resource = source._resource
      _review = source._review
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._review) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._review {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AccessListReview, rhs: Events_AccessListReview) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._review != rhs_storage._review {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AuditQueryRun: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuditQueryRun"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Status"),
    4: .same(proto: "Query"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _status: Events_Status? = nil
    var _query: Events_AuditQueryDetails? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _status = source._status
      _query = source._query
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._query) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AuditQueryRun, rhs: Events_AuditQueryRun) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._query != rhs_storage._query {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AuditQueryDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuditQueryDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Query"),
    3: .same(proto: "Days"),
    4: .same(proto: "ExecutionTimeInMillis"),
    5: .same(proto: "DataScannedInBytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.days) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.executionTimeInMillis) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.dataScannedInBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 2)
    }
    if self.days != 0 {
      try visitor.visitSingularInt32Field(value: self.days, fieldNumber: 3)
    }
    if self.executionTimeInMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.executionTimeInMillis, fieldNumber: 4)
    }
    if self.dataScannedInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.dataScannedInBytes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_AuditQueryDetails, rhs: Events_AuditQueryDetails) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.query != rhs.query {return false}
    if lhs.days != rhs.days {return false}
    if lhs.executionTimeInMillis != rhs.executionTimeInMillis {return false}
    if lhs.dataScannedInBytes != rhs.dataScannedInBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_SecurityReportRun: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecurityReportRun"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Metadata"),
    2: .same(proto: "User"),
    3: .same(proto: "Status"),
    4: .same(proto: "Name"),
    5: .same(proto: "Version"),
    6: .same(proto: "TotalExecutionTimeInMillis"),
    7: .same(proto: "TotalDataScannedInBytes"),
    8: .same(proto: "AuditQueries"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Events_Metadata? = nil
    var _user: Events_UserMetadata? = nil
    var _status: Events_Status? = nil
    var _name: String = String()
    var _version: String = String()
    var _totalExecutionTimeInMillis: Int64 = 0
    var _totalDataScannedInBytes: Int64 = 0
    var _auditQueries: [Events_AuditQueryDetails] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _user = source._user
      _status = source._status
      _name = source._name
      _version = source._version
      _totalExecutionTimeInMillis = source._totalExecutionTimeInMillis
      _totalDataScannedInBytes = source._totalDataScannedInBytes
      _auditQueries = source._auditQueries
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._totalExecutionTimeInMillis) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._totalDataScannedInBytes) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._auditQueries) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 4)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 5)
      }
      if _storage._totalExecutionTimeInMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalExecutionTimeInMillis, fieldNumber: 6)
      }
      if _storage._totalDataScannedInBytes != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalDataScannedInBytes, fieldNumber: 7)
      }
      if !_storage._auditQueries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._auditQueries, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Events_SecurityReportRun, rhs: Events_SecurityReportRun) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._totalExecutionTimeInMillis != rhs_storage._totalExecutionTimeInMillis {return false}
        if _storage._totalDataScannedInBytes != rhs_storage._totalDataScannedInBytes {return false}
        if _storage._auditQueries != rhs_storage._auditQueries {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
