// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/legacy/types/webauthn/webauthn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2021 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// SessionData stored by the Relying Party during authentication ceremonies.
/// Mirrors https://pkg.go.dev/github.com/go-webauthn/webauthn/webauthn#SessionData.
struct Webauthn_SessionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw challenge used for the ceremony.
  var challenge: Data = Data()

  /// Raw User ID.
  var userID: Data = Data()

  /// Raw Credential IDs of the credentials allowed for the ceremony.
  var allowCredentials: [Data] = []

  /// True if resident keys were required by the server / Relying Party.
  var residentKey: Bool = false

  /// Requested user verification requirement, either "discouraged" or
  /// "required".
  /// An empty value is treated equivalently to "discouraged".
  var userVerification: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// User represents a WebAuthn user.
/// Used mainly to correlated a WebAuthn user handle with a Teleport user.
struct Webauthn_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Teleport user ID.
  var teleportUser: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Credential assertion used for login ceremonies.
struct Webauthn_CredentialAssertion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Webauthn_PublicKeyCredentialRequestOptions {
    get {return _publicKey ?? Webauthn_PublicKeyCredentialRequestOptions()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: Webauthn_PublicKeyCredentialRequestOptions? = nil
}

/// Request options necessary for credential assertions, aka login ceremonies.
/// See https://www.w3.org/TR/webauthn-2/#dictionary-assertion-options or
/// refer to navigator.credentials.get in your browser.
struct Webauthn_PublicKeyCredentialRequestOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw challenge used for assertion.
  var challenge: Data = Data()

  /// Timeout in milliseconds.
  var timeoutMs: Int64 = 0

  /// Relying Party ID.
  var rpID: String = String()

  /// Allowed credentials for assertion.
  var allowCredentials: [Webauthn_CredentialDescriptor] = []

  /// Extensions supplied by the Relying Party.
  var extensions: Webauthn_AuthenticationExtensionsClientInputs {
    get {return _extensions ?? Webauthn_AuthenticationExtensionsClientInputs()}
    set {_extensions = newValue}
  }
  /// Returns true if `extensions` has been explicitly set.
  var hasExtensions: Bool {return self._extensions != nil}
  /// Clears the value of `extensions`. Subsequent reads from it will return its default value.
  mutating func clearExtensions() {self._extensions = nil}

  /// User verification requirement.
  var userVerification: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _extensions: Webauthn_AuthenticationExtensionsClientInputs? = nil
}

/// Assertion response returned by the authenticator.
/// Refer to navigator.credentials.get in your browser.
struct Webauthn_CredentialAssertionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of the credential, usually "public-key".
  var type: String = String()

  /// Raw Credential ID.
  var rawID: Data = Data()

  /// Assertion response from the authenticator.
  var response: Webauthn_AuthenticatorAssertionResponse {
    get {return _response ?? Webauthn_AuthenticatorAssertionResponse()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  mutating func clearResponse() {self._response = nil}

  /// Extensions supplied by the authenticator.
  var extensions: Webauthn_AuthenticationExtensionsClientOutputs {
    get {return _extensions ?? Webauthn_AuthenticationExtensionsClientOutputs()}
    set {_extensions = newValue}
  }
  /// Returns true if `extensions` has been explicitly set.
  var hasExtensions: Bool {return self._extensions != nil}
  /// Clears the value of `extensions`. Subsequent reads from it will return its default value.
  mutating func clearExtensions() {self._extensions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _response: Webauthn_AuthenticatorAssertionResponse? = nil
  fileprivate var _extensions: Webauthn_AuthenticationExtensionsClientOutputs? = nil
}

/// Authenticator assertion response.
/// https://www.w3.org/TR/webauthn-2/#authenticatorassertionresponse
struct Webauthn_AuthenticatorAssertionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw client data JSON, exactly as signed by the authenticator.
  /// https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata.
  var clientDataJson: Data = Data()

  /// Raw authenticator data, exactly as signed by the authenticator.
  /// https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data.
  var authenticatorData: Data = Data()

  /// Raw assertion signature performed authenticatorData|clientDataJSON.
  /// https://www.w3.org/TR/webauthn-2/#assertion-signature.
  var signature: Data = Data()

  /// Raw user handle returned by the authenticator, if any.
  var userHandle: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Credential creation used for registration ceremonies.
struct Webauthn_CredentialCreation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Webauthn_PublicKeyCredentialCreationOptions {
    get {return _publicKey ?? Webauthn_PublicKeyCredentialCreationOptions()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: Webauthn_PublicKeyCredentialCreationOptions? = nil
}

/// Request options necessary for credential creation, aka registration
/// ceremonies.
/// See
/// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions
/// or refer to navigator.credentials.create in your browser.
struct Webauthn_PublicKeyCredentialCreationOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw challenge used for creation.
  var challenge: Data = Data()

  /// Relying party information.
  var rp: Webauthn_RelyingPartyEntity {
    get {return _rp ?? Webauthn_RelyingPartyEntity()}
    set {_rp = newValue}
  }
  /// Returns true if `rp` has been explicitly set.
  var hasRp: Bool {return self._rp != nil}
  /// Clears the value of `rp`. Subsequent reads from it will return its default value.
  mutating func clearRp() {self._rp = nil}

  /// User information.
  var user: Webauthn_UserEntity {
    get {return _user ?? Webauthn_UserEntity()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {self._user = nil}

  /// Desired properties for the credential to be created, from most to least
  /// preferred.
  var credentialParameters: [Webauthn_CredentialParameter] = []

  /// Timeout in milliseconds.
  var timeoutMs: Int64 = 0

  /// Credentials excluded from the ceremony.
  var excludeCredentials: [Webauthn_CredentialDescriptor] = []

  /// Attestation requested, defaulting to "none".
  /// https://www.w3.org/TR/webauthn-2/#enumdef-attestationconveyancepreference.
  var attestation: String = String()

  /// Extensions supplied by the Relying Party.
  var extensions: Webauthn_AuthenticationExtensionsClientInputs {
    get {return _extensions ?? Webauthn_AuthenticationExtensionsClientInputs()}
    set {_extensions = newValue}
  }
  /// Returns true if `extensions` has been explicitly set.
  var hasExtensions: Bool {return self._extensions != nil}
  /// Clears the value of `extensions`. Subsequent reads from it will return its default value.
  mutating func clearExtensions() {self._extensions = nil}

  /// Authenticator selection criteria for the new credential.
  var authenticatorSelection: Webauthn_AuthenticatorSelection {
    get {return _authenticatorSelection ?? Webauthn_AuthenticatorSelection()}
    set {_authenticatorSelection = newValue}
  }
  /// Returns true if `authenticatorSelection` has been explicitly set.
  var hasAuthenticatorSelection: Bool {return self._authenticatorSelection != nil}
  /// Clears the value of `authenticatorSelection`. Subsequent reads from it will return its default value.
  mutating func clearAuthenticatorSelection() {self._authenticatorSelection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rp: Webauthn_RelyingPartyEntity? = nil
  fileprivate var _user: Webauthn_UserEntity? = nil
  fileprivate var _extensions: Webauthn_AuthenticationExtensionsClientInputs? = nil
  fileprivate var _authenticatorSelection: Webauthn_AuthenticatorSelection? = nil
}

/// Credential creation response returned by the authenticator.
/// Refer to navigator.credentials.create in your browser.
struct Webauthn_CredentialCreationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of the credential, usually "public-key".
  var type: String = String()

  /// Raw Credential ID.
  var rawID: Data = Data()

  /// Attestation response from the authenticator.
  var response: Webauthn_AuthenticatorAttestationResponse {
    get {return _response ?? Webauthn_AuthenticatorAttestationResponse()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  mutating func clearResponse() {self._response = nil}

  /// Extensions supplied by the authenticator.
  var extensions: Webauthn_AuthenticationExtensionsClientOutputs {
    get {return _extensions ?? Webauthn_AuthenticationExtensionsClientOutputs()}
    set {_extensions = newValue}
  }
  /// Returns true if `extensions` has been explicitly set.
  var hasExtensions: Bool {return self._extensions != nil}
  /// Clears the value of `extensions`. Subsequent reads from it will return its default value.
  mutating func clearExtensions() {self._extensions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _response: Webauthn_AuthenticatorAttestationResponse? = nil
  fileprivate var _extensions: Webauthn_AuthenticationExtensionsClientOutputs? = nil
}

/// Attestation response from the authentication, ie, the response to a
/// credential creation request.
/// https://www.w3.org/TR/webauthn-2/#authenticatorattestationresponse.
struct Webauthn_AuthenticatorAttestationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw client data JSON, exactly as signed by the authenticator.
  /// https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata.
  var clientDataJson: Data = Data()

  /// Raw attestation object.
  /// https://www.w3.org/TR/webauthn-2/#attestation-object
  var attestationObject: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Extensions supplied by the Relying Party during credential assertion or
/// creation.
/// https://www.w3.org/TR/webauthn-2/#client-extension-input
struct Webauthn_AuthenticationExtensionsClientInputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// U2F application ID to be used by the authenticator, if any.
  /// Only available if using U2F compatibility mode.
  /// https://www.w3.org/TR/webauthn-2/#sctn-appid-extension.
  var appID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Extensions supplied by the authenticator to the Relying Party, during
/// credential assertion or creation.
/// https://www.w3.org/TR/webauthn-2/#client-extension-output.
struct Webauthn_AuthenticationExtensionsClientOutputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, the AppID extension was used by the authenticator, which changes
  /// the rpIdHash accordingly.
  /// https://www.w3.org/TR/webauthn-2/#sctn-appid-extension.
  var appID: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Authenticator selection criteria.
/// Restricts the choice of authenticator for credential creation.
struct Webauthn_AuthenticatorSelection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authenticator attachment, empty means no particular attachment is
  /// required.
  var authenticatorAttachment: String = String()

  /// Resident key requirement, if true the authenticator must create a resident
  /// key.
  var requireResidentKey: Bool = false

  /// User verification requirement for authenticators.
  var userVerification: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Public key credential descriptor.
/// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialdescriptor.
struct Webauthn_CredentialDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of the credential, usually "public-key".
  var type: String = String()

  /// Raw Credential ID.
  var id: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Parameters for credential creation.
/// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialparameters.
struct Webauthn_CredentialParameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Credential type, usually "public-key".
  /// https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype.
  var type: String = String()

  /// COSE algorithm specifier.
  /// Most authenticators support exclusively ES256(-7).
  /// https://www.w3.org/TR/webauthn-2/#typedefdef-cosealgorithmidentifier.
  var alg: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Relying Party information.
/// See https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialrpentity and
/// https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions/rp.
struct Webauthn_RelyingPartyEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// User information.
/// See https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialuserentity
/// and
/// https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions/user.
struct Webauthn_UserEntity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Raw ID of the user.
  var id: Data = Data()

  /// Human-palatable name for a user account.
  /// The Relying Party _may_ let the user choose this value.
  var name: String = String()

  /// Human-palatable name for the user account, intended only for display.
  /// The Relying Party _should_ let the user choose this value.
  var displayName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Webauthn_SessionData: @unchecked Sendable {}
extension Webauthn_User: @unchecked Sendable {}
extension Webauthn_CredentialAssertion: @unchecked Sendable {}
extension Webauthn_PublicKeyCredentialRequestOptions: @unchecked Sendable {}
extension Webauthn_CredentialAssertionResponse: @unchecked Sendable {}
extension Webauthn_AuthenticatorAssertionResponse: @unchecked Sendable {}
extension Webauthn_CredentialCreation: @unchecked Sendable {}
extension Webauthn_PublicKeyCredentialCreationOptions: @unchecked Sendable {}
extension Webauthn_CredentialCreationResponse: @unchecked Sendable {}
extension Webauthn_AuthenticatorAttestationResponse: @unchecked Sendable {}
extension Webauthn_AuthenticationExtensionsClientInputs: @unchecked Sendable {}
extension Webauthn_AuthenticationExtensionsClientOutputs: @unchecked Sendable {}
extension Webauthn_AuthenticatorSelection: @unchecked Sendable {}
extension Webauthn_CredentialDescriptor: @unchecked Sendable {}
extension Webauthn_CredentialParameter: @unchecked Sendable {}
extension Webauthn_RelyingPartyEntity: @unchecked Sendable {}
extension Webauthn_UserEntity: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "webauthn"

extension Webauthn_SessionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "challenge"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "allow_credentials"),
    4: .standard(proto: "resident_key"),
    5: .standard(proto: "user_verification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.challenge) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.allowCredentials) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.residentKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userVerification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.challenge.isEmpty {
      try visitor.visitSingularBytesField(value: self.challenge, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 2)
    }
    if !self.allowCredentials.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.allowCredentials, fieldNumber: 3)
    }
    if self.residentKey != false {
      try visitor.visitSingularBoolField(value: self.residentKey, fieldNumber: 4)
    }
    if !self.userVerification.isEmpty {
      try visitor.visitSingularStringField(value: self.userVerification, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_SessionData, rhs: Webauthn_SessionData) -> Bool {
    if lhs.challenge != rhs.challenge {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.allowCredentials != rhs.allowCredentials {return false}
    if lhs.residentKey != rhs.residentKey {return false}
    if lhs.userVerification != rhs.userVerification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "teleport_user"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.teleportUser) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.teleportUser.isEmpty {
      try visitor.visitSingularStringField(value: self.teleportUser, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_User, rhs: Webauthn_User) -> Bool {
    if lhs.teleportUser != rhs.teleportUser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_CredentialAssertion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialAssertion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_CredentialAssertion, rhs: Webauthn_CredentialAssertion) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_PublicKeyCredentialRequestOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublicKeyCredentialRequestOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "challenge"),
    2: .standard(proto: "timeout_ms"),
    3: .standard(proto: "rp_id"),
    4: .standard(proto: "allow_credentials"),
    5: .same(proto: "extensions"),
    6: .standard(proto: "user_verification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.challenge) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timeoutMs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rpID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.allowCredentials) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._extensions) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.userVerification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.challenge.isEmpty {
      try visitor.visitSingularBytesField(value: self.challenge, fieldNumber: 1)
    }
    if self.timeoutMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timeoutMs, fieldNumber: 2)
    }
    if !self.rpID.isEmpty {
      try visitor.visitSingularStringField(value: self.rpID, fieldNumber: 3)
    }
    if !self.allowCredentials.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allowCredentials, fieldNumber: 4)
    }
    try { if let v = self._extensions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.userVerification.isEmpty {
      try visitor.visitSingularStringField(value: self.userVerification, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_PublicKeyCredentialRequestOptions, rhs: Webauthn_PublicKeyCredentialRequestOptions) -> Bool {
    if lhs.challenge != rhs.challenge {return false}
    if lhs.timeoutMs != rhs.timeoutMs {return false}
    if lhs.rpID != rhs.rpID {return false}
    if lhs.allowCredentials != rhs.allowCredentials {return false}
    if lhs._extensions != rhs._extensions {return false}
    if lhs.userVerification != rhs.userVerification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_CredentialAssertionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialAssertionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "raw_id"),
    3: .same(proto: "response"),
    4: .same(proto: "extensions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rawID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.rawID.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawID, fieldNumber: 2)
    }
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._extensions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_CredentialAssertionResponse, rhs: Webauthn_CredentialAssertionResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.rawID != rhs.rawID {return false}
    if lhs._response != rhs._response {return false}
    if lhs._extensions != rhs._extensions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_AuthenticatorAssertionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticatorAssertionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_data_json"),
    2: .standard(proto: "authenticator_data"),
    3: .same(proto: "signature"),
    4: .standard(proto: "user_handle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.clientDataJson) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.authenticatorData) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.userHandle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientDataJson.isEmpty {
      try visitor.visitSingularBytesField(value: self.clientDataJson, fieldNumber: 1)
    }
    if !self.authenticatorData.isEmpty {
      try visitor.visitSingularBytesField(value: self.authenticatorData, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    if !self.userHandle.isEmpty {
      try visitor.visitSingularBytesField(value: self.userHandle, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_AuthenticatorAssertionResponse, rhs: Webauthn_AuthenticatorAssertionResponse) -> Bool {
    if lhs.clientDataJson != rhs.clientDataJson {return false}
    if lhs.authenticatorData != rhs.authenticatorData {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.userHandle != rhs.userHandle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_CredentialCreation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialCreation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_CredentialCreation, rhs: Webauthn_CredentialCreation) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_PublicKeyCredentialCreationOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublicKeyCredentialCreationOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "challenge"),
    2: .same(proto: "rp"),
    3: .same(proto: "user"),
    4: .standard(proto: "credential_parameters"),
    5: .standard(proto: "timeout_ms"),
    6: .standard(proto: "exclude_credentials"),
    7: .same(proto: "attestation"),
    8: .same(proto: "extensions"),
    9: .standard(proto: "authenticator_selection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.challenge) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.credentialParameters) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.timeoutMs) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.excludeCredentials) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.attestation) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._extensions) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._authenticatorSelection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.challenge.isEmpty {
      try visitor.visitSingularBytesField(value: self.challenge, fieldNumber: 1)
    }
    try { if let v = self._rp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.credentialParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.credentialParameters, fieldNumber: 4)
    }
    if self.timeoutMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timeoutMs, fieldNumber: 5)
    }
    if !self.excludeCredentials.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.excludeCredentials, fieldNumber: 6)
    }
    if !self.attestation.isEmpty {
      try visitor.visitSingularStringField(value: self.attestation, fieldNumber: 7)
    }
    try { if let v = self._extensions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._authenticatorSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_PublicKeyCredentialCreationOptions, rhs: Webauthn_PublicKeyCredentialCreationOptions) -> Bool {
    if lhs.challenge != rhs.challenge {return false}
    if lhs._rp != rhs._rp {return false}
    if lhs._user != rhs._user {return false}
    if lhs.credentialParameters != rhs.credentialParameters {return false}
    if lhs.timeoutMs != rhs.timeoutMs {return false}
    if lhs.excludeCredentials != rhs.excludeCredentials {return false}
    if lhs.attestation != rhs.attestation {return false}
    if lhs._extensions != rhs._extensions {return false}
    if lhs._authenticatorSelection != rhs._authenticatorSelection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_CredentialCreationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialCreationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "raw_id"),
    3: .same(proto: "response"),
    4: .same(proto: "extensions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rawID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extensions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.rawID.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawID, fieldNumber: 2)
    }
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._extensions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_CredentialCreationResponse, rhs: Webauthn_CredentialCreationResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.rawID != rhs.rawID {return false}
    if lhs._response != rhs._response {return false}
    if lhs._extensions != rhs._extensions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_AuthenticatorAttestationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticatorAttestationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_data_json"),
    2: .standard(proto: "attestation_object"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.clientDataJson) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.attestationObject) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientDataJson.isEmpty {
      try visitor.visitSingularBytesField(value: self.clientDataJson, fieldNumber: 1)
    }
    if !self.attestationObject.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationObject, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_AuthenticatorAttestationResponse, rhs: Webauthn_AuthenticatorAttestationResponse) -> Bool {
    if lhs.clientDataJson != rhs.clientDataJson {return false}
    if lhs.attestationObject != rhs.attestationObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_AuthenticationExtensionsClientInputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticationExtensionsClientInputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_AuthenticationExtensionsClientInputs, rhs: Webauthn_AuthenticationExtensionsClientInputs) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_AuthenticationExtensionsClientOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticationExtensionsClientOutputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appID != false {
      try visitor.visitSingularBoolField(value: self.appID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_AuthenticationExtensionsClientOutputs, rhs: Webauthn_AuthenticationExtensionsClientOutputs) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_AuthenticatorSelection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticatorSelection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "authenticator_attachment"),
    2: .standard(proto: "require_resident_key"),
    3: .standard(proto: "user_verification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authenticatorAttachment) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.requireResidentKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userVerification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authenticatorAttachment.isEmpty {
      try visitor.visitSingularStringField(value: self.authenticatorAttachment, fieldNumber: 1)
    }
    if self.requireResidentKey != false {
      try visitor.visitSingularBoolField(value: self.requireResidentKey, fieldNumber: 2)
    }
    if !self.userVerification.isEmpty {
      try visitor.visitSingularStringField(value: self.userVerification, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_AuthenticatorSelection, rhs: Webauthn_AuthenticatorSelection) -> Bool {
    if lhs.authenticatorAttachment != rhs.authenticatorAttachment {return false}
    if lhs.requireResidentKey != rhs.requireResidentKey {return false}
    if lhs.userVerification != rhs.userVerification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_CredentialDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_CredentialDescriptor, rhs: Webauthn_CredentialDescriptor) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_CredentialParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "alg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.alg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.alg != 0 {
      try visitor.visitSingularInt32Field(value: self.alg, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_CredentialParameter, rhs: Webauthn_CredentialParameter) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.alg != rhs.alg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_RelyingPartyEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RelyingPartyEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_RelyingPartyEntity, rhs: Webauthn_RelyingPartyEntity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Webauthn_UserEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserEntity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "display_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Webauthn_UserEntity, rhs: Webauthn_UserEntity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
