/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter long_type_number,eslint_disable,add_pb_suffix,client_grpc1,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/devicetrust/v1/devicetrust_service.proto" (package "teleport.devicetrust.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import { DeviceTrustService } from "./devicetrust_service_pb";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { DevicesUsage } from "./usage_pb";
import type { GetDevicesUsageRequest } from "./devicetrust_service_pb";
import type { SyncInventoryResponse } from "./devicetrust_service_pb";
import type { SyncInventoryRequest } from "./devicetrust_service_pb";
import type { AuthenticateDeviceResponse } from "./devicetrust_service_pb";
import type { AuthenticateDeviceRequest } from "./devicetrust_service_pb";
import type { EnrollDeviceResponse } from "./devicetrust_service_pb";
import type { EnrollDeviceRequest } from "./devicetrust_service_pb";
import type { DeviceEnrollToken } from "./device_enroll_token_pb";
import type { CreateDeviceEnrollTokenRequest } from "./devicetrust_service_pb";
import type { BulkCreateDevicesResponse } from "./devicetrust_service_pb";
import type { BulkCreateDevicesRequest } from "./devicetrust_service_pb";
import type { ListDevicesResponse } from "./devicetrust_service_pb";
import type { ListDevicesRequest } from "./devicetrust_service_pb";
import type { GetDeviceRequest } from "./devicetrust_service_pb";
import type { FindDevicesResponse } from "./devicetrust_service_pb";
import type { FindDevicesRequest } from "./devicetrust_service_pb";
import type { Empty } from "../../../google/protobuf/empty_pb";
import type { DeleteDeviceRequest } from "./devicetrust_service_pb";
import type { UpsertDeviceRequest } from "./devicetrust_service_pb";
import type { UpdateDeviceRequest } from "./devicetrust_service_pb";
import type { Device } from "./device_pb";
import type { CreateDeviceRequest } from "./devicetrust_service_pb";
import * as grpc from "@grpc/grpc-js";
/**
 * DeviceTrustService provides methods to manage, enroll and authenticate
 * trusted devices.
 *
 * A trusted device is a device that is registered and enrolled with Teleport,
 * thus allowing the system to provide some guarantees about its provenance and
 * state.
 *
 * Managing devices requires the corresponding CRUD "device" permission.
 * Additionally, creating enrollment tokens requires the "create_enroll_token"
 * permission and enrolling devices requires the "enroll" permission. See
 * CreateDevice, CreateDeviceEnrollToken and EnrollDevice for reference.
 *
 * An authenticated, trusted device allows its user to perform device-aware
 * actions. Such actions include accessing an SSH node, managing sensitive
 * resources via `tctl`, etc. The enforcement mode is defined via cluster-wide
 * and/or per-role toggles. Device authentication is automatic for enrolled
 * devices communicating with Enterprise clusters. See AuthenticateDevice for
 * reference.
 *
 * Device Trust is a Teleport Enterprise feature. Open Source Teleport clusters
 * treat all Device RPCs as unimplemented (which, in fact, they are for OSS.)
 *
 * @generated from protobuf service teleport.devicetrust.v1.DeviceTrustService
 */
export interface IDeviceTrustServiceClient {
    /**
     * CreateDevice creates a device, effectively registering it on Teleport.
     * Devices need to be registered before they can be enrolled.
     *
     * It is possible to create both a Device and a DeviceEnrollToken in a
     * single invocation, see CreateDeviceRequest.create_enroll_token.
     *
     * @generated from protobuf rpc: CreateDevice(teleport.devicetrust.v1.CreateDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    createDevice(input: CreateDeviceRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    createDevice(input: CreateDeviceRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    createDevice(input: CreateDeviceRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    createDevice(input: CreateDeviceRequest, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    /**
     * UpdateDevice is a masked device update.
     *
     * Only certain fields may be updated, see Device for details.
     *
     * @generated from protobuf rpc: UpdateDevice(teleport.devicetrust.v1.UpdateDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    updateDevice(input: UpdateDeviceRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    updateDevice(input: UpdateDeviceRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    updateDevice(input: UpdateDeviceRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    updateDevice(input: UpdateDeviceRequest, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    /**
     * UpsertDevice creates or updates a device.
     *
     * UpsertDevice attempts a write of all mutable fields on updates, therefore
     * reading a fresh copy of the device is recommended. Update semantics still
     * apply.
     *
     * @generated from protobuf rpc: UpsertDevice(teleport.devicetrust.v1.UpsertDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    upsertDevice(input: UpsertDeviceRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    upsertDevice(input: UpsertDeviceRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    upsertDevice(input: UpsertDeviceRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    upsertDevice(input: UpsertDeviceRequest, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    /**
     * DeleteDevice hard-deletes a device, removing it and all collected data
     * history from the system.
     *
     * Prefer locking the device instead (see the `tctl lock` command). Deleting a
     * device doesn't invalidate existing device certificates, but does prevent
     * new device authentication ceremonies from occurring.
     *
     * Use with caution.
     *
     * @generated from protobuf rpc: DeleteDevice(teleport.devicetrust.v1.DeleteDeviceRequest) returns (google.protobuf.Empty);
     */
    deleteDevice(input: DeleteDeviceRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Empty) => void): grpc.ClientUnaryCall;
    deleteDevice(input: DeleteDeviceRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: Empty) => void): grpc.ClientUnaryCall;
    deleteDevice(input: DeleteDeviceRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Empty) => void): grpc.ClientUnaryCall;
    deleteDevice(input: DeleteDeviceRequest, callback: (err: grpc.ServiceError | null, value?: Empty) => void): grpc.ClientUnaryCall;
    /**
     * FindDevices retrieves devices by device ID and/or asset tag.
     *
     * It provides an in-between search between fetching a device by ID and
     * listing all devices.
     *
     * ID matches are guaranteed to be present in the response.
     *
     * @generated from protobuf rpc: FindDevices(teleport.devicetrust.v1.FindDevicesRequest) returns (teleport.devicetrust.v1.FindDevicesResponse);
     */
    findDevices(input: FindDevicesRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: FindDevicesResponse) => void): grpc.ClientUnaryCall;
    findDevices(input: FindDevicesRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: FindDevicesResponse) => void): grpc.ClientUnaryCall;
    findDevices(input: FindDevicesRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: FindDevicesResponse) => void): grpc.ClientUnaryCall;
    findDevices(input: FindDevicesRequest, callback: (err: grpc.ServiceError | null, value?: FindDevicesResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetDevice retrieves a device by ID.
     *
     * @generated from protobuf rpc: GetDevice(teleport.devicetrust.v1.GetDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    getDevice(input: GetDeviceRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    getDevice(input: GetDeviceRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    getDevice(input: GetDeviceRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    getDevice(input: GetDeviceRequest, callback: (err: grpc.ServiceError | null, value?: Device) => void): grpc.ClientUnaryCall;
    /**
     * ListDevices lists all registered devices.
     *
     * @generated from protobuf rpc: ListDevices(teleport.devicetrust.v1.ListDevicesRequest) returns (teleport.devicetrust.v1.ListDevicesResponse);
     */
    listDevices(input: ListDevicesRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListDevicesResponse) => void): grpc.ClientUnaryCall;
    listDevices(input: ListDevicesRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ListDevicesResponse) => void): grpc.ClientUnaryCall;
    listDevices(input: ListDevicesRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListDevicesResponse) => void): grpc.ClientUnaryCall;
    listDevices(input: ListDevicesRequest, callback: (err: grpc.ServiceError | null, value?: ListDevicesResponse) => void): grpc.ClientUnaryCall;
    /**
     * BulkCreateDevices is a bulk variant of CreateDevice.
     *
     * Unlike CreateDevice, it does not support creation of enrollment tokens, as
     * it is meant for bulk inventory registration.
     *
     * @generated from protobuf rpc: BulkCreateDevices(teleport.devicetrust.v1.BulkCreateDevicesRequest) returns (teleport.devicetrust.v1.BulkCreateDevicesResponse);
     */
    bulkCreateDevices(input: BulkCreateDevicesRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: BulkCreateDevicesResponse) => void): grpc.ClientUnaryCall;
    bulkCreateDevices(input: BulkCreateDevicesRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: BulkCreateDevicesResponse) => void): grpc.ClientUnaryCall;
    bulkCreateDevices(input: BulkCreateDevicesRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: BulkCreateDevicesResponse) => void): grpc.ClientUnaryCall;
    bulkCreateDevices(input: BulkCreateDevicesRequest, callback: (err: grpc.ServiceError | null, value?: BulkCreateDevicesResponse) => void): grpc.ClientUnaryCall;
    /**
     * CreateDeviceEnrollToken creates a DeviceEnrollToken for a Device.
     * An enrollment token is required for the enrollment ceremony. See
     * EnrollDevice.
     *
     * @generated from protobuf rpc: CreateDeviceEnrollToken(teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest) returns (teleport.devicetrust.v1.DeviceEnrollToken);
     */
    createDeviceEnrollToken(input: CreateDeviceEnrollTokenRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DeviceEnrollToken) => void): grpc.ClientUnaryCall;
    createDeviceEnrollToken(input: CreateDeviceEnrollTokenRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: DeviceEnrollToken) => void): grpc.ClientUnaryCall;
    createDeviceEnrollToken(input: CreateDeviceEnrollTokenRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DeviceEnrollToken) => void): grpc.ClientUnaryCall;
    createDeviceEnrollToken(input: CreateDeviceEnrollTokenRequest, callback: (err: grpc.ServiceError | null, value?: DeviceEnrollToken) => void): grpc.ClientUnaryCall;
    /**
     * EnrollDevice performs the device enrollment ceremony.
     *
     * Enrollment requires a previously-registered Device and a DeviceEnrollToken,
     * see CreateDevice and CreateDeviceEnrollToken.
     *
     * An enrolled device is allowed, via AuthenticateDevice, to acquire
     * certificates containing device extensions, thus gaining access to
     * device-aware actions.
     *
     * macOS enrollment flow:
     * -> EnrollDeviceInit (client)
     * <- MacOSEnrollChallenge (server)
     * -> MacOSEnrollChallengeResponse
     * <- EnrollDeviceSuccess
     *
     * TPM enrollment flow:
     * -> EnrollDeviceInit (client)
     * <- TPMEnrollChallenge (server)
     * -> TPMEnrollChallengeResponse
     * <- EnrollDeviceSuccess
     *
     * @generated from protobuf rpc: EnrollDevice(stream teleport.devicetrust.v1.EnrollDeviceRequest) returns (stream teleport.devicetrust.v1.EnrollDeviceResponse);
     */
    enrollDevice(metadata: grpc.Metadata, options?: grpc.CallOptions): grpc.ClientDuplexStream<EnrollDeviceRequest, EnrollDeviceResponse>;
    enrollDevice(options?: grpc.CallOptions): grpc.ClientDuplexStream<EnrollDeviceRequest, EnrollDeviceResponse>;
    /**
     * AuthenticateDevice performs the device authentication ceremony.
     *
     * Device authentication exchanges existing user certificates without device
     * extensions for certificates augmented with device extensions. The new
     * certificates allow the user to perform device-aware actions.
     *
     * Only registered and enrolled devices may perform device authentication.
     *
     * @generated from protobuf rpc: AuthenticateDevice(stream teleport.devicetrust.v1.AuthenticateDeviceRequest) returns (stream teleport.devicetrust.v1.AuthenticateDeviceResponse);
     */
    authenticateDevice(metadata: grpc.Metadata, options?: grpc.CallOptions): grpc.ClientDuplexStream<AuthenticateDeviceRequest, AuthenticateDeviceResponse>;
    authenticateDevice(options?: grpc.CallOptions): grpc.ClientDuplexStream<AuthenticateDeviceRequest, AuthenticateDeviceResponse>;
    /**
     * Syncs device inventory from a source exterior to Teleport, for example an
     * MDM.
     * Allows both partial and full syncs; for the latter, devices missing from
     * the external inventory are handled as specified.
     * Authorized either by a valid MDM service certificate or the appropriate
     * "device" permissions (create/update/delete).
     *
     * @generated from protobuf rpc: SyncInventory(stream teleport.devicetrust.v1.SyncInventoryRequest) returns (stream teleport.devicetrust.v1.SyncInventoryResponse);
     */
    syncInventory(metadata: grpc.Metadata, options?: grpc.CallOptions): grpc.ClientDuplexStream<SyncInventoryRequest, SyncInventoryResponse>;
    syncInventory(options?: grpc.CallOptions): grpc.ClientDuplexStream<SyncInventoryRequest, SyncInventoryResponse>;
    /**
     * Superseded by ResourceUsageService.GetUsage.
     *
     * @deprecated
     * @generated from protobuf rpc: GetDevicesUsage(teleport.devicetrust.v1.GetDevicesUsageRequest) returns (teleport.devicetrust.v1.DevicesUsage);
     */
    getDevicesUsage(input: GetDevicesUsageRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DevicesUsage) => void): grpc.ClientUnaryCall;
    getDevicesUsage(input: GetDevicesUsageRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: DevicesUsage) => void): grpc.ClientUnaryCall;
    getDevicesUsage(input: GetDevicesUsageRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DevicesUsage) => void): grpc.ClientUnaryCall;
    getDevicesUsage(input: GetDevicesUsageRequest, callback: (err: grpc.ServiceError | null, value?: DevicesUsage) => void): grpc.ClientUnaryCall;
}
/**
 * DeviceTrustService provides methods to manage, enroll and authenticate
 * trusted devices.
 *
 * A trusted device is a device that is registered and enrolled with Teleport,
 * thus allowing the system to provide some guarantees about its provenance and
 * state.
 *
 * Managing devices requires the corresponding CRUD "device" permission.
 * Additionally, creating enrollment tokens requires the "create_enroll_token"
 * permission and enrolling devices requires the "enroll" permission. See
 * CreateDevice, CreateDeviceEnrollToken and EnrollDevice for reference.
 *
 * An authenticated, trusted device allows its user to perform device-aware
 * actions. Such actions include accessing an SSH node, managing sensitive
 * resources via `tctl`, etc. The enforcement mode is defined via cluster-wide
 * and/or per-role toggles. Device authentication is automatic for enrolled
 * devices communicating with Enterprise clusters. See AuthenticateDevice for
 * reference.
 *
 * Device Trust is a Teleport Enterprise feature. Open Source Teleport clusters
 * treat all Device RPCs as unimplemented (which, in fact, they are for OSS.)
 *
 * @generated from protobuf service teleport.devicetrust.v1.DeviceTrustService
 */
export class DeviceTrustServiceClient extends grpc.Client implements IDeviceTrustServiceClient {
    private readonly _binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions>;
    constructor(address: string, credentials: grpc.ChannelCredentials, options: grpc.ClientOptions = {}, binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions> = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     * CreateDevice creates a device, effectively registering it on Teleport.
     * Devices need to be registered before they can be enrolled.
     *
     * It is possible to create both a Device and a DeviceEnrollToken in a
     * single invocation, see CreateDeviceRequest.create_enroll_token.
     *
     * @generated from protobuf rpc: CreateDevice(teleport.devicetrust.v1.CreateDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    createDevice(input: CreateDeviceRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Device) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Device) => void), callback?: ((err: grpc.ServiceError | null, value?: Device) => void)): grpc.ClientUnaryCall {
        const method = DeviceTrustService.methods[0];
        return this.makeUnaryRequest<CreateDeviceRequest, Device>(`/${DeviceTrustService.typeName}/${method.name}`, (value: CreateDeviceRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): Device => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * UpdateDevice is a masked device update.
     *
     * Only certain fields may be updated, see Device for details.
     *
     * @generated from protobuf rpc: UpdateDevice(teleport.devicetrust.v1.UpdateDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    updateDevice(input: UpdateDeviceRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Device) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Device) => void), callback?: ((err: grpc.ServiceError | null, value?: Device) => void)): grpc.ClientUnaryCall {
        const method = DeviceTrustService.methods[1];
        return this.makeUnaryRequest<UpdateDeviceRequest, Device>(`/${DeviceTrustService.typeName}/${method.name}`, (value: UpdateDeviceRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): Device => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * UpsertDevice creates or updates a device.
     *
     * UpsertDevice attempts a write of all mutable fields on updates, therefore
     * reading a fresh copy of the device is recommended. Update semantics still
     * apply.
     *
     * @generated from protobuf rpc: UpsertDevice(teleport.devicetrust.v1.UpsertDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    upsertDevice(input: UpsertDeviceRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Device) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Device) => void), callback?: ((err: grpc.ServiceError | null, value?: Device) => void)): grpc.ClientUnaryCall {
        const method = DeviceTrustService.methods[2];
        return this.makeUnaryRequest<UpsertDeviceRequest, Device>(`/${DeviceTrustService.typeName}/${method.name}`, (value: UpsertDeviceRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): Device => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * DeleteDevice hard-deletes a device, removing it and all collected data
     * history from the system.
     *
     * Prefer locking the device instead (see the `tctl lock` command). Deleting a
     * device doesn't invalidate existing device certificates, but does prevent
     * new device authentication ceremonies from occurring.
     *
     * Use with caution.
     *
     * @generated from protobuf rpc: DeleteDevice(teleport.devicetrust.v1.DeleteDeviceRequest) returns (google.protobuf.Empty);
     */
    deleteDevice(input: DeleteDeviceRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Empty) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Empty) => void), callback?: ((err: grpc.ServiceError | null, value?: Empty) => void)): grpc.ClientUnaryCall {
        const method = DeviceTrustService.methods[3];
        return this.makeUnaryRequest<DeleteDeviceRequest, Empty>(`/${DeviceTrustService.typeName}/${method.name}`, (value: DeleteDeviceRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): Empty => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * FindDevices retrieves devices by device ID and/or asset tag.
     *
     * It provides an in-between search between fetching a device by ID and
     * listing all devices.
     *
     * ID matches are guaranteed to be present in the response.
     *
     * @generated from protobuf rpc: FindDevices(teleport.devicetrust.v1.FindDevicesRequest) returns (teleport.devicetrust.v1.FindDevicesResponse);
     */
    findDevices(input: FindDevicesRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: FindDevicesResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: FindDevicesResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: FindDevicesResponse) => void)): grpc.ClientUnaryCall {
        const method = DeviceTrustService.methods[4];
        return this.makeUnaryRequest<FindDevicesRequest, FindDevicesResponse>(`/${DeviceTrustService.typeName}/${method.name}`, (value: FindDevicesRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): FindDevicesResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetDevice retrieves a device by ID.
     *
     * @generated from protobuf rpc: GetDevice(teleport.devicetrust.v1.GetDeviceRequest) returns (teleport.devicetrust.v1.Device);
     */
    getDevice(input: GetDeviceRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Device) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Device) => void), callback?: ((err: grpc.ServiceError | null, value?: Device) => void)): grpc.ClientUnaryCall {
        const method = DeviceTrustService.methods[5];
        return this.makeUnaryRequest<GetDeviceRequest, Device>(`/${DeviceTrustService.typeName}/${method.name}`, (value: GetDeviceRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): Device => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ListDevices lists all registered devices.
     *
     * @generated from protobuf rpc: ListDevices(teleport.devicetrust.v1.ListDevicesRequest) returns (teleport.devicetrust.v1.ListDevicesResponse);
     */
    listDevices(input: ListDevicesRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListDevicesResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListDevicesResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ListDevicesResponse) => void)): grpc.ClientUnaryCall {
        const method = DeviceTrustService.methods[6];
        return this.makeUnaryRequest<ListDevicesRequest, ListDevicesResponse>(`/${DeviceTrustService.typeName}/${method.name}`, (value: ListDevicesRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ListDevicesResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * BulkCreateDevices is a bulk variant of CreateDevice.
     *
     * Unlike CreateDevice, it does not support creation of enrollment tokens, as
     * it is meant for bulk inventory registration.
     *
     * @generated from protobuf rpc: BulkCreateDevices(teleport.devicetrust.v1.BulkCreateDevicesRequest) returns (teleport.devicetrust.v1.BulkCreateDevicesResponse);
     */
    bulkCreateDevices(input: BulkCreateDevicesRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: BulkCreateDevicesResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: BulkCreateDevicesResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: BulkCreateDevicesResponse) => void)): grpc.ClientUnaryCall {
        const method = DeviceTrustService.methods[7];
        return this.makeUnaryRequest<BulkCreateDevicesRequest, BulkCreateDevicesResponse>(`/${DeviceTrustService.typeName}/${method.name}`, (value: BulkCreateDevicesRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): BulkCreateDevicesResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CreateDeviceEnrollToken creates a DeviceEnrollToken for a Device.
     * An enrollment token is required for the enrollment ceremony. See
     * EnrollDevice.
     *
     * @generated from protobuf rpc: CreateDeviceEnrollToken(teleport.devicetrust.v1.CreateDeviceEnrollTokenRequest) returns (teleport.devicetrust.v1.DeviceEnrollToken);
     */
    createDeviceEnrollToken(input: CreateDeviceEnrollTokenRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DeviceEnrollToken) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DeviceEnrollToken) => void), callback?: ((err: grpc.ServiceError | null, value?: DeviceEnrollToken) => void)): grpc.ClientUnaryCall {
        const method = DeviceTrustService.methods[8];
        return this.makeUnaryRequest<CreateDeviceEnrollTokenRequest, DeviceEnrollToken>(`/${DeviceTrustService.typeName}/${method.name}`, (value: CreateDeviceEnrollTokenRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): DeviceEnrollToken => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * EnrollDevice performs the device enrollment ceremony.
     *
     * Enrollment requires a previously-registered Device and a DeviceEnrollToken,
     * see CreateDevice and CreateDeviceEnrollToken.
     *
     * An enrolled device is allowed, via AuthenticateDevice, to acquire
     * certificates containing device extensions, thus gaining access to
     * device-aware actions.
     *
     * macOS enrollment flow:
     * -> EnrollDeviceInit (client)
     * <- MacOSEnrollChallenge (server)
     * -> MacOSEnrollChallengeResponse
     * <- EnrollDeviceSuccess
     *
     * TPM enrollment flow:
     * -> EnrollDeviceInit (client)
     * <- TPMEnrollChallenge (server)
     * -> TPMEnrollChallengeResponse
     * <- EnrollDeviceSuccess
     *
     * @generated from protobuf rpc: EnrollDevice(stream teleport.devicetrust.v1.EnrollDeviceRequest) returns (stream teleport.devicetrust.v1.EnrollDeviceResponse);
     */
    enrollDevice(metadata?: grpc.Metadata | grpc.CallOptions, options?: grpc.CallOptions): grpc.ClientDuplexStream<EnrollDeviceRequest, EnrollDeviceResponse> {
        const method = DeviceTrustService.methods[9];
        return this.makeBidiStreamRequest<EnrollDeviceRequest, EnrollDeviceResponse>(`/${DeviceTrustService.typeName}/${method.name}`, (value: EnrollDeviceRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): EnrollDeviceResponse => method.O.fromBinary(value, this._binaryOptions), (metadata as any), options);
    }
    /**
     * AuthenticateDevice performs the device authentication ceremony.
     *
     * Device authentication exchanges existing user certificates without device
     * extensions for certificates augmented with device extensions. The new
     * certificates allow the user to perform device-aware actions.
     *
     * Only registered and enrolled devices may perform device authentication.
     *
     * @generated from protobuf rpc: AuthenticateDevice(stream teleport.devicetrust.v1.AuthenticateDeviceRequest) returns (stream teleport.devicetrust.v1.AuthenticateDeviceResponse);
     */
    authenticateDevice(metadata?: grpc.Metadata | grpc.CallOptions, options?: grpc.CallOptions): grpc.ClientDuplexStream<AuthenticateDeviceRequest, AuthenticateDeviceResponse> {
        const method = DeviceTrustService.methods[10];
        return this.makeBidiStreamRequest<AuthenticateDeviceRequest, AuthenticateDeviceResponse>(`/${DeviceTrustService.typeName}/${method.name}`, (value: AuthenticateDeviceRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): AuthenticateDeviceResponse => method.O.fromBinary(value, this._binaryOptions), (metadata as any), options);
    }
    /**
     * Syncs device inventory from a source exterior to Teleport, for example an
     * MDM.
     * Allows both partial and full syncs; for the latter, devices missing from
     * the external inventory are handled as specified.
     * Authorized either by a valid MDM service certificate or the appropriate
     * "device" permissions (create/update/delete).
     *
     * @generated from protobuf rpc: SyncInventory(stream teleport.devicetrust.v1.SyncInventoryRequest) returns (stream teleport.devicetrust.v1.SyncInventoryResponse);
     */
    syncInventory(metadata?: grpc.Metadata | grpc.CallOptions, options?: grpc.CallOptions): grpc.ClientDuplexStream<SyncInventoryRequest, SyncInventoryResponse> {
        const method = DeviceTrustService.methods[11];
        return this.makeBidiStreamRequest<SyncInventoryRequest, SyncInventoryResponse>(`/${DeviceTrustService.typeName}/${method.name}`, (value: SyncInventoryRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): SyncInventoryResponse => method.O.fromBinary(value, this._binaryOptions), (metadata as any), options);
    }
    /**
     * Superseded by ResourceUsageService.GetUsage.
     *
     * @deprecated
     * @generated from protobuf rpc: GetDevicesUsage(teleport.devicetrust.v1.GetDevicesUsageRequest) returns (teleport.devicetrust.v1.DevicesUsage);
     */
    getDevicesUsage(input: GetDevicesUsageRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DevicesUsage) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DevicesUsage) => void), callback?: ((err: grpc.ServiceError | null, value?: DevicesUsage) => void)): grpc.ClientUnaryCall {
        const method = DeviceTrustService.methods[12];
        return this.makeUnaryRequest<GetDevicesUsageRequest, DevicesUsage>(`/${DeviceTrustService.typeName}/${method.name}`, (value: GetDevicesUsageRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): DevicesUsage => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
}
