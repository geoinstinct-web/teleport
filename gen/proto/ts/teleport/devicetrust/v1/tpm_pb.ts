/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter long_type_number,eslint_disable,add_pb_suffix,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/devicetrust/v1/tpm.proto" (package "teleport.devicetrust.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Encapsulates the value of a PCR at a point at time.
 * See https://pkg.go.dev/github.com/google/go-attestation/attest#PCR
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMPCR
 */
export interface TPMPCR {
    /**
     * the PCR index in the PCR bank
     *
     * @generated from protobuf field: int32 index = 1;
     */
    index: number;
    /**
     * the digest currently held in the PCR
     *
     * @generated from protobuf field: bytes digest = 2;
     */
    digest: Uint8Array;
    /**
     * the hash algorithm used to produce the digest in this PCR bank. This value
     * is the underlying value of the Go crypto.Hash type.
     *
     * @generated from protobuf field: uint64 digest_alg = 3;
     */
    digestAlg: number;
}
/**
 * Encapsulates the result of a quote operation against the TPM over a PCR
 * using an attestation key.
 * See https://pkg.go.dev/github.com/google/go-attestation/attest#Quote
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMQuote
 */
export interface TPMQuote {
    /**
     * @generated from protobuf field: bytes quote = 1;
     */
    quote: Uint8Array;
    /**
     * @generated from protobuf field: bytes signature = 2;
     */
    signature: Uint8Array;
}
/**
 * The quotes, PCRs and event log from a TPM that attest to the booted state
 * of the machine.
 * See https://pkg.go.dev/github.com/google/go-attestation/attest#PlatformParameters
 * Excludes TPMVersion and Public since these are already known values.
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMPlatformParameters
 */
export interface TPMPlatformParameters {
    /**
     * @generated from protobuf field: repeated teleport.devicetrust.v1.TPMQuote quotes = 1;
     */
    quotes: TPMQuote[];
    /**
     * @generated from protobuf field: repeated teleport.devicetrust.v1.TPMPCR pcrs = 2;
     */
    pcrs: TPMPCR[];
    /**
     * @generated from protobuf field: bytes event_log = 3;
     */
    eventLog: Uint8Array;
}
/**
 * Holds the record of a TPM platform attestation, including the platform
 * parameters sent by the device and the nonce the server generated. This allows
 * a historical platform attestation to be revalidated and allows us to compare
 * the incoming state of a device (e.g during authentication) against the
 * historical state in order to detect potentially malicious actions.
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMPlatformAttestation
 */
export interface TPMPlatformAttestation {
    /**
     * @generated from protobuf field: bytes nonce = 1;
     */
    nonce: Uint8Array;
    /**
     * @generated from protobuf field: teleport.devicetrust.v1.TPMPlatformParameters platform_parameters = 2;
     */
    platformParameters?: TPMPlatformParameters;
}
/**
 * The attestation key and the parameters necessary to remotely verify it as
 * related to the endorsement key.
 * See https://pkg.go.dev/github.com/google/go-attestation/attest#AttestationParameters.
 * This message excludes the `UseTCSDActivationFormat` field from the link above
 * as it is TMP 1.x specific and always false.
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMAttestationParameters
 */
export interface TPMAttestationParameters {
    /**
     * The encoded TPMT_PUBLIC structure containing the attestation public key
     * and signing parameters.
     *
     * @generated from protobuf field: bytes public = 1;
     */
    public: Uint8Array;
    /**
     * The properties of the attestation key, encoded as a TPMS_CREATION_DATA
     * structure.
     *
     * @generated from protobuf field: bytes create_data = 2;
     */
    createData: Uint8Array;
    /**
     * An assertion as to the details of the key, encoded as a TPMS_ATTEST
     * structure.
     *
     * @generated from protobuf field: bytes create_attestation = 3;
     */
    createAttestation: Uint8Array;
    /**
     * A signature of create_attestation, encoded as a TPMT_SIGNATURE structure.
     *
     * @generated from protobuf field: bytes create_signature = 4;
     */
    createSignature: Uint8Array;
}
/**
 * These values are used by the TPM2.0 `ActivateCredential` command to produce
 * the solution which proves possession of the EK and AK.
 *
 * For a more in-depth description see:
 * - https://pkg.go.dev/github.com/google/go-attestation/attest#EncryptedCredential
 * - https://trustedcomputinggroup.org/wp-content/uploads/TCG_TPM2_r1p59_Part3_Commands_code_pub.pdf (Heading 12.5.1 "TPM2_ActivateCredential" "General Description")
 * - https://github.com/google/go-attestation/blob/v0.4.3/attest/activation.go#L199
 * - https://github.com/google/go-tpm/blob/v0.3.3/tpm2/credactivation/credential_activation.go#L61
 *
 * @generated from protobuf message teleport.devicetrust.v1.TPMEncryptedCredential
 */
export interface TPMEncryptedCredential {
    /**
     * The `credential_blob` parameter to be used with the `ActivateCredential`
     * command. This is used with the decrypted value of `secret` in a
     * cryptographic process to decrypt the solution.
     *
     * @generated from protobuf field: bytes credential_blob = 1;
     */
    credentialBlob: Uint8Array;
    /**
     * The `secret` parameter to be used with `ActivateCredential`. This is a
     * seed which can be decrypted with the EK. The decrypted seed is then used
     * when decrypting `credential_blob`.
     *
     * @generated from protobuf field: bytes secret = 2;
     */
    secret: Uint8Array;
}
// @generated message type with reflection information, may provide speed optimized methods
class TPMPCR$Type extends MessageType<TPMPCR> {
    constructor() {
        super("teleport.devicetrust.v1.TPMPCR", [
            { no: 1, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "digest_alg", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<TPMPCR>): TPMPCR {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.index = 0;
        message.digest = new Uint8Array(0);
        message.digestAlg = 0;
        if (value !== undefined)
            reflectionMergePartial<TPMPCR>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMPCR): TPMPCR {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 index */ 1:
                    message.index = reader.int32();
                    break;
                case /* bytes digest */ 2:
                    message.digest = reader.bytes();
                    break;
                case /* uint64 digest_alg */ 3:
                    message.digestAlg = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMPCR, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).int32(message.index);
        /* bytes digest = 2; */
        if (message.digest.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.digest);
        /* uint64 digest_alg = 3; */
        if (message.digestAlg !== 0)
            writer.tag(3, WireType.Varint).uint64(message.digestAlg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMPCR
 */
export const TPMPCR = new TPMPCR$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMQuote$Type extends MessageType<TPMQuote> {
    constructor() {
        super("teleport.devicetrust.v1.TPMQuote", [
            { no: 1, name: "quote", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TPMQuote>): TPMQuote {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quote = new Uint8Array(0);
        message.signature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TPMQuote>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMQuote): TPMQuote {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes quote */ 1:
                    message.quote = reader.bytes();
                    break;
                case /* bytes signature */ 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMQuote, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes quote = 1; */
        if (message.quote.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.quote);
        /* bytes signature = 2; */
        if (message.signature.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMQuote
 */
export const TPMQuote = new TPMQuote$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMPlatformParameters$Type extends MessageType<TPMPlatformParameters> {
    constructor() {
        super("teleport.devicetrust.v1.TPMPlatformParameters", [
            { no: 1, name: "quotes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TPMQuote },
            { no: 2, name: "pcrs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TPMPCR },
            { no: 3, name: "event_log", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TPMPlatformParameters>): TPMPlatformParameters {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quotes = [];
        message.pcrs = [];
        message.eventLog = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TPMPlatformParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMPlatformParameters): TPMPlatformParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated teleport.devicetrust.v1.TPMQuote quotes */ 1:
                    message.quotes.push(TPMQuote.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated teleport.devicetrust.v1.TPMPCR pcrs */ 2:
                    message.pcrs.push(TPMPCR.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes event_log */ 3:
                    message.eventLog = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMPlatformParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated teleport.devicetrust.v1.TPMQuote quotes = 1; */
        for (let i = 0; i < message.quotes.length; i++)
            TPMQuote.internalBinaryWrite(message.quotes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated teleport.devicetrust.v1.TPMPCR pcrs = 2; */
        for (let i = 0; i < message.pcrs.length; i++)
            TPMPCR.internalBinaryWrite(message.pcrs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bytes event_log = 3; */
        if (message.eventLog.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.eventLog);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMPlatformParameters
 */
export const TPMPlatformParameters = new TPMPlatformParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMPlatformAttestation$Type extends MessageType<TPMPlatformAttestation> {
    constructor() {
        super("teleport.devicetrust.v1.TPMPlatformAttestation", [
            { no: 1, name: "nonce", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "platform_parameters", kind: "message", T: () => TPMPlatformParameters }
        ]);
    }
    create(value?: PartialMessage<TPMPlatformAttestation>): TPMPlatformAttestation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nonce = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TPMPlatformAttestation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMPlatformAttestation): TPMPlatformAttestation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes nonce */ 1:
                    message.nonce = reader.bytes();
                    break;
                case /* teleport.devicetrust.v1.TPMPlatformParameters platform_parameters */ 2:
                    message.platformParameters = TPMPlatformParameters.internalBinaryRead(reader, reader.uint32(), options, message.platformParameters);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMPlatformAttestation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes nonce = 1; */
        if (message.nonce.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.nonce);
        /* teleport.devicetrust.v1.TPMPlatformParameters platform_parameters = 2; */
        if (message.platformParameters)
            TPMPlatformParameters.internalBinaryWrite(message.platformParameters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMPlatformAttestation
 */
export const TPMPlatformAttestation = new TPMPlatformAttestation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMAttestationParameters$Type extends MessageType<TPMAttestationParameters> {
    constructor() {
        super("teleport.devicetrust.v1.TPMAttestationParameters", [
            { no: 1, name: "public", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "create_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "create_attestation", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "create_signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TPMAttestationParameters>): TPMAttestationParameters {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.public = new Uint8Array(0);
        message.createData = new Uint8Array(0);
        message.createAttestation = new Uint8Array(0);
        message.createSignature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TPMAttestationParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMAttestationParameters): TPMAttestationParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes public */ 1:
                    message.public = reader.bytes();
                    break;
                case /* bytes create_data */ 2:
                    message.createData = reader.bytes();
                    break;
                case /* bytes create_attestation */ 3:
                    message.createAttestation = reader.bytes();
                    break;
                case /* bytes create_signature */ 4:
                    message.createSignature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMAttestationParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes public = 1; */
        if (message.public.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.public);
        /* bytes create_data = 2; */
        if (message.createData.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.createData);
        /* bytes create_attestation = 3; */
        if (message.createAttestation.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.createAttestation);
        /* bytes create_signature = 4; */
        if (message.createSignature.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.createSignature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMAttestationParameters
 */
export const TPMAttestationParameters = new TPMAttestationParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TPMEncryptedCredential$Type extends MessageType<TPMEncryptedCredential> {
    constructor() {
        super("teleport.devicetrust.v1.TPMEncryptedCredential", [
            { no: 1, name: "credential_blob", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "secret", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TPMEncryptedCredential>): TPMEncryptedCredential {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.credentialBlob = new Uint8Array(0);
        message.secret = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TPMEncryptedCredential>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TPMEncryptedCredential): TPMEncryptedCredential {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes credential_blob */ 1:
                    message.credentialBlob = reader.bytes();
                    break;
                case /* bytes secret */ 2:
                    message.secret = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TPMEncryptedCredential, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes credential_blob = 1; */
        if (message.credentialBlob.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.credentialBlob);
        /* bytes secret = 2; */
        if (message.secret.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.secret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message teleport.devicetrust.v1.TPMEncryptedCredential
 */
export const TPMEncryptedCredential = new TPMEncryptedCredential$Type();
