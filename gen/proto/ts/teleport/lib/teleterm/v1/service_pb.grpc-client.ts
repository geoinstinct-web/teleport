/* eslint-disable */
// @generated by protobuf-ts 2.9.3 with parameter long_type_number,eslint_disable,add_pb_suffix,client_grpc1,server_grpc1,ts_nocheck
// @generated from protobuf file "teleport/lib/teleterm/v1/service.proto" (package "teleport.lib.teleterm.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
//
//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
import { TerminalService } from "./service_pb";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { UpdateUserPreferencesResponse } from "./service_pb";
import type { UpdateUserPreferencesRequest } from "./service_pb";
import type { GetUserPreferencesResponse } from "./service_pb";
import type { GetUserPreferencesRequest } from "./service_pb";
import type { ListUnifiedResourcesResponse } from "./service_pb";
import type { ListUnifiedResourcesRequest } from "./service_pb";
import type { GetConnectMyComputerNodeNameResponse } from "./service_pb";
import type { GetConnectMyComputerNodeNameRequest } from "./service_pb";
import type { DeleteConnectMyComputerNodeResponse } from "./service_pb";
import type { DeleteConnectMyComputerNodeRequest } from "./service_pb";
import type { WaitForConnectMyComputerNodeJoinResponse } from "./service_pb";
import type { WaitForConnectMyComputerNodeJoinRequest } from "./service_pb";
import type { DeleteConnectMyComputerTokenResponse } from "./service_pb";
import type { DeleteConnectMyComputerTokenRequest } from "./service_pb";
import type { CreateConnectMyComputerNodeTokenResponse } from "./service_pb";
import type { CreateConnectMyComputerNodeTokenRequest } from "./service_pb";
import type { CreateConnectMyComputerRoleResponse } from "./service_pb";
import type { CreateConnectMyComputerRoleRequest } from "./service_pb";
import type { UpdateHeadlessAuthenticationStateResponse } from "./service_pb";
import type { UpdateHeadlessAuthenticationStateRequest } from "./service_pb";
import type { ReportUsageEventRequest } from "./usage_events_pb";
import type { FileTransferProgress } from "./service_pb";
import type { FileTransferRequest } from "./service_pb";
import type { LogoutRequest } from "./service_pb";
import type { LoginPasswordlessResponse } from "./service_pb";
import type { LoginPasswordlessRequest } from "./service_pb";
import type { LoginRequest } from "./service_pb";
import type { GetClusterRequest } from "./service_pb";
import type { AuthSettings } from "./auth_settings_pb";
import type { GetAuthSettingsRequest } from "./service_pb";
import type { SetGatewayLocalPortRequest } from "./service_pb";
import type { SetGatewayTargetSubresourceNameRequest } from "./service_pb";
import type { RemoveGatewayRequest } from "./service_pb";
import type { Gateway } from "./gateway_pb";
import type { CreateGatewayRequest } from "./service_pb";
import type { ListGatewaysResponse } from "./service_pb";
import type { ListGatewaysRequest } from "./service_pb";
import type { RemoveClusterRequest } from "./service_pb";
import type { Cluster } from "./cluster_pb";
import type { AddClusterRequest } from "./service_pb";
import type { GetAppsResponse } from "./service_pb";
import type { GetAppsRequest } from "./service_pb";
import type { GetKubesResponse } from "./service_pb";
import type { GetKubesRequest } from "./service_pb";
import type { GetSuggestedAccessListsResponse } from "./service_pb";
import type { GetSuggestedAccessListsRequest } from "./service_pb";
import type { PromoteAccessRequestResponse } from "./service_pb";
import type { PromoteAccessRequestRequest } from "./service_pb";
import type { AssumeRoleRequest } from "./service_pb";
import type { GetRequestableRolesResponse } from "./service_pb";
import type { GetRequestableRolesRequest } from "./service_pb";
import type { ReviewAccessRequestResponse } from "./service_pb";
import type { ReviewAccessRequestRequest } from "./service_pb";
import type { CreateAccessRequestResponse } from "./service_pb";
import type { CreateAccessRequestRequest } from "./service_pb";
import type { EmptyResponse } from "./service_pb";
import type { DeleteAccessRequestRequest } from "./service_pb";
import type { GetAccessRequestResponse } from "./service_pb";
import type { GetAccessRequestRequest } from "./service_pb";
import type { GetAccessRequestsResponse } from "./service_pb";
import type { GetAccessRequestsRequest } from "./service_pb";
import type { GetServersResponse } from "./service_pb";
import type { GetServersRequest } from "./service_pb";
import type { ListDatabaseUsersResponse } from "./service_pb";
import type { ListDatabaseUsersRequest } from "./service_pb";
import type { GetDatabasesResponse } from "./service_pb";
import type { GetDatabasesRequest } from "./service_pb";
import type { ListLeafClustersRequest } from "./service_pb";
import type { ListClustersResponse } from "./service_pb";
import type { ListClustersRequest } from "./service_pb";
import type { UpdateTshdEventsServerAddressResponse } from "./service_pb";
import type { UpdateTshdEventsServerAddressRequest } from "./service_pb";
import * as grpc from "@grpc/grpc-js";
/**
 * TerminalService is used by the Electron app to communicate with the tsh daemon.
 *
 * While we aim to preserve backwards compatibility in order to satisfy CI checks and follow the
 * proto practices used within the company, this service is not guaranteed to be stable across
 * versions. The packaging process of Teleport Connect ensures that the server and the client use
 * the same version of the service.
 *
 * @generated from protobuf service teleport.lib.teleterm.v1.TerminalService
 */
export interface ITerminalServiceClient {
    /**
     * UpdateTshdEventsServerAddress lets the Electron app update the address the tsh daemon is
     * supposed to use when connecting to the tshd events gRPC service. This RPC needs to be made
     * before any other from this service.
     *
     * The service is supposed to return a response from this call only after the client is ready.
     *
     * @generated from protobuf rpc: UpdateTshdEventsServerAddress(teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressRequest) returns (teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressResponse);
     */
    updateTshdEventsServerAddress(input: UpdateTshdEventsServerAddressRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: UpdateTshdEventsServerAddressResponse) => void): grpc.ClientUnaryCall;
    updateTshdEventsServerAddress(input: UpdateTshdEventsServerAddressRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: UpdateTshdEventsServerAddressResponse) => void): grpc.ClientUnaryCall;
    updateTshdEventsServerAddress(input: UpdateTshdEventsServerAddressRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: UpdateTshdEventsServerAddressResponse) => void): grpc.ClientUnaryCall;
    updateTshdEventsServerAddress(input: UpdateTshdEventsServerAddressRequest, callback: (err: grpc.ServiceError | null, value?: UpdateTshdEventsServerAddressResponse) => void): grpc.ClientUnaryCall;
    /**
     * ListRootClusters lists root clusters
     * Does not include detailed cluster information that would require a network request.
     *
     * @generated from protobuf rpc: ListRootClusters(teleport.lib.teleterm.v1.ListClustersRequest) returns (teleport.lib.teleterm.v1.ListClustersResponse);
     */
    listRootClusters(input: ListClustersRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListClustersResponse) => void): grpc.ClientUnaryCall;
    listRootClusters(input: ListClustersRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ListClustersResponse) => void): grpc.ClientUnaryCall;
    listRootClusters(input: ListClustersRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListClustersResponse) => void): grpc.ClientUnaryCall;
    listRootClusters(input: ListClustersRequest, callback: (err: grpc.ServiceError | null, value?: ListClustersResponse) => void): grpc.ClientUnaryCall;
    /**
     * ListLeafClusters lists leaf clusters
     * Does not include detailed cluster information that would require a network request.
     *
     * @generated from protobuf rpc: ListLeafClusters(teleport.lib.teleterm.v1.ListLeafClustersRequest) returns (teleport.lib.teleterm.v1.ListClustersResponse);
     */
    listLeafClusters(input: ListLeafClustersRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListClustersResponse) => void): grpc.ClientUnaryCall;
    listLeafClusters(input: ListLeafClustersRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ListClustersResponse) => void): grpc.ClientUnaryCall;
    listLeafClusters(input: ListLeafClustersRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListClustersResponse) => void): grpc.ClientUnaryCall;
    listLeafClusters(input: ListLeafClustersRequest, callback: (err: grpc.ServiceError | null, value?: ListClustersResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetDatabases returns a filtered and paginated list of databases
     *
     * @generated from protobuf rpc: GetDatabases(teleport.lib.teleterm.v1.GetDatabasesRequest) returns (teleport.lib.teleterm.v1.GetDatabasesResponse);
     */
    getDatabases(input: GetDatabasesRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetDatabasesResponse) => void): grpc.ClientUnaryCall;
    getDatabases(input: GetDatabasesRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetDatabasesResponse) => void): grpc.ClientUnaryCall;
    getDatabases(input: GetDatabasesRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetDatabasesResponse) => void): grpc.ClientUnaryCall;
    getDatabases(input: GetDatabasesRequest, callback: (err: grpc.ServiceError | null, value?: GetDatabasesResponse) => void): grpc.ClientUnaryCall;
    /**
     * ListDatabaseUsers lists allowed users for the given database based on the role set.
     *
     * @generated from protobuf rpc: ListDatabaseUsers(teleport.lib.teleterm.v1.ListDatabaseUsersRequest) returns (teleport.lib.teleterm.v1.ListDatabaseUsersResponse);
     */
    listDatabaseUsers(input: ListDatabaseUsersRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListDatabaseUsersResponse) => void): grpc.ClientUnaryCall;
    listDatabaseUsers(input: ListDatabaseUsersRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ListDatabaseUsersResponse) => void): grpc.ClientUnaryCall;
    listDatabaseUsers(input: ListDatabaseUsersRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListDatabaseUsersResponse) => void): grpc.ClientUnaryCall;
    listDatabaseUsers(input: ListDatabaseUsersRequest, callback: (err: grpc.ServiceError | null, value?: ListDatabaseUsersResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetServers returns filtered, sorted, and paginated servers
     *
     * @generated from protobuf rpc: GetServers(teleport.lib.teleterm.v1.GetServersRequest) returns (teleport.lib.teleterm.v1.GetServersResponse);
     */
    getServers(input: GetServersRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetServersResponse) => void): grpc.ClientUnaryCall;
    getServers(input: GetServersRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetServersResponse) => void): grpc.ClientUnaryCall;
    getServers(input: GetServersRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetServersResponse) => void): grpc.ClientUnaryCall;
    getServers(input: GetServersRequest, callback: (err: grpc.ServiceError | null, value?: GetServersResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetAccessRequests lists filtered AccessRequests
     *
     * @generated from protobuf rpc: GetAccessRequests(teleport.lib.teleterm.v1.GetAccessRequestsRequest) returns (teleport.lib.teleterm.v1.GetAccessRequestsResponse);
     */
    getAccessRequests(input: GetAccessRequestsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetAccessRequestsResponse) => void): grpc.ClientUnaryCall;
    getAccessRequests(input: GetAccessRequestsRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetAccessRequestsResponse) => void): grpc.ClientUnaryCall;
    getAccessRequests(input: GetAccessRequestsRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetAccessRequestsResponse) => void): grpc.ClientUnaryCall;
    getAccessRequests(input: GetAccessRequestsRequest, callback: (err: grpc.ServiceError | null, value?: GetAccessRequestsResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetAccessRequest retreives a single Access Request
     *
     * @generated from protobuf rpc: GetAccessRequest(teleport.lib.teleterm.v1.GetAccessRequestRequest) returns (teleport.lib.teleterm.v1.GetAccessRequestResponse);
     */
    getAccessRequest(input: GetAccessRequestRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetAccessRequestResponse) => void): grpc.ClientUnaryCall;
    getAccessRequest(input: GetAccessRequestRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetAccessRequestResponse) => void): grpc.ClientUnaryCall;
    getAccessRequest(input: GetAccessRequestRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetAccessRequestResponse) => void): grpc.ClientUnaryCall;
    getAccessRequest(input: GetAccessRequestRequest, callback: (err: grpc.ServiceError | null, value?: GetAccessRequestResponse) => void): grpc.ClientUnaryCall;
    /**
     * DeleteAccessRequest deletes the access request by id
     *
     * @generated from protobuf rpc: DeleteAccessRequest(teleport.lib.teleterm.v1.DeleteAccessRequestRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    deleteAccessRequest(input: DeleteAccessRequestRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    deleteAccessRequest(input: DeleteAccessRequestRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    deleteAccessRequest(input: DeleteAccessRequestRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    deleteAccessRequest(input: DeleteAccessRequestRequest, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    /**
     * CreateAccessRequest creates an access request
     *
     * @generated from protobuf rpc: CreateAccessRequest(teleport.lib.teleterm.v1.CreateAccessRequestRequest) returns (teleport.lib.teleterm.v1.CreateAccessRequestResponse);
     */
    createAccessRequest(input: CreateAccessRequestRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateAccessRequestResponse) => void): grpc.ClientUnaryCall;
    createAccessRequest(input: CreateAccessRequestRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: CreateAccessRequestResponse) => void): grpc.ClientUnaryCall;
    createAccessRequest(input: CreateAccessRequestRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateAccessRequestResponse) => void): grpc.ClientUnaryCall;
    createAccessRequest(input: CreateAccessRequestRequest, callback: (err: grpc.ServiceError | null, value?: CreateAccessRequestResponse) => void): grpc.ClientUnaryCall;
    /**
     * ReviewAccessRequest submits a review for an Access Request
     *
     * @generated from protobuf rpc: ReviewAccessRequest(teleport.lib.teleterm.v1.ReviewAccessRequestRequest) returns (teleport.lib.teleterm.v1.ReviewAccessRequestResponse);
     */
    reviewAccessRequest(input: ReviewAccessRequestRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ReviewAccessRequestResponse) => void): grpc.ClientUnaryCall;
    reviewAccessRequest(input: ReviewAccessRequestRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ReviewAccessRequestResponse) => void): grpc.ClientUnaryCall;
    reviewAccessRequest(input: ReviewAccessRequestRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ReviewAccessRequestResponse) => void): grpc.ClientUnaryCall;
    reviewAccessRequest(input: ReviewAccessRequestRequest, callback: (err: grpc.ServiceError | null, value?: ReviewAccessRequestResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetRequestableRoles gets all requestable roles
     *
     * @generated from protobuf rpc: GetRequestableRoles(teleport.lib.teleterm.v1.GetRequestableRolesRequest) returns (teleport.lib.teleterm.v1.GetRequestableRolesResponse);
     */
    getRequestableRoles(input: GetRequestableRolesRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetRequestableRolesResponse) => void): grpc.ClientUnaryCall;
    getRequestableRoles(input: GetRequestableRolesRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetRequestableRolesResponse) => void): grpc.ClientUnaryCall;
    getRequestableRoles(input: GetRequestableRolesRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetRequestableRolesResponse) => void): grpc.ClientUnaryCall;
    getRequestableRoles(input: GetRequestableRolesRequest, callback: (err: grpc.ServiceError | null, value?: GetRequestableRolesResponse) => void): grpc.ClientUnaryCall;
    /**
     * AssumeRole assumes the role of the given access request
     *
     * @generated from protobuf rpc: AssumeRole(teleport.lib.teleterm.v1.AssumeRoleRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    assumeRole(input: AssumeRoleRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    assumeRole(input: AssumeRoleRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    assumeRole(input: AssumeRoleRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    assumeRole(input: AssumeRoleRequest, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    /**
     * PromoteAccessRequest promotes an access request to an access list.
     *
     * @generated from protobuf rpc: PromoteAccessRequest(teleport.lib.teleterm.v1.PromoteAccessRequestRequest) returns (teleport.lib.teleterm.v1.PromoteAccessRequestResponse);
     */
    promoteAccessRequest(input: PromoteAccessRequestRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PromoteAccessRequestResponse) => void): grpc.ClientUnaryCall;
    promoteAccessRequest(input: PromoteAccessRequestRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: PromoteAccessRequestResponse) => void): grpc.ClientUnaryCall;
    promoteAccessRequest(input: PromoteAccessRequestRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PromoteAccessRequestResponse) => void): grpc.ClientUnaryCall;
    promoteAccessRequest(input: PromoteAccessRequestRequest, callback: (err: grpc.ServiceError | null, value?: PromoteAccessRequestResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetSuggestedAccessLists returns suggested access lists for an access request.
     *
     * @generated from protobuf rpc: GetSuggestedAccessLists(teleport.lib.teleterm.v1.GetSuggestedAccessListsRequest) returns (teleport.lib.teleterm.v1.GetSuggestedAccessListsResponse);
     */
    getSuggestedAccessLists(input: GetSuggestedAccessListsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetSuggestedAccessListsResponse) => void): grpc.ClientUnaryCall;
    getSuggestedAccessLists(input: GetSuggestedAccessListsRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetSuggestedAccessListsResponse) => void): grpc.ClientUnaryCall;
    getSuggestedAccessLists(input: GetSuggestedAccessListsRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetSuggestedAccessListsResponse) => void): grpc.ClientUnaryCall;
    getSuggestedAccessLists(input: GetSuggestedAccessListsRequest, callback: (err: grpc.ServiceError | null, value?: GetSuggestedAccessListsResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetKubes returns filtered, sorted, and paginated kubes
     *
     * @generated from protobuf rpc: GetKubes(teleport.lib.teleterm.v1.GetKubesRequest) returns (teleport.lib.teleterm.v1.GetKubesResponse);
     */
    getKubes(input: GetKubesRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetKubesResponse) => void): grpc.ClientUnaryCall;
    getKubes(input: GetKubesRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetKubesResponse) => void): grpc.ClientUnaryCall;
    getKubes(input: GetKubesRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetKubesResponse) => void): grpc.ClientUnaryCall;
    getKubes(input: GetKubesRequest, callback: (err: grpc.ServiceError | null, value?: GetKubesResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetApps returns a filtered and paginated list of apps.
     *
     * @generated from protobuf rpc: GetApps(teleport.lib.teleterm.v1.GetAppsRequest) returns (teleport.lib.teleterm.v1.GetAppsResponse);
     */
    getApps(input: GetAppsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetAppsResponse) => void): grpc.ClientUnaryCall;
    getApps(input: GetAppsRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetAppsResponse) => void): grpc.ClientUnaryCall;
    getApps(input: GetAppsRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetAppsResponse) => void): grpc.ClientUnaryCall;
    getApps(input: GetAppsRequest, callback: (err: grpc.ServiceError | null, value?: GetAppsResponse) => void): grpc.ClientUnaryCall;
    /**
     * AddCluster adds a cluster to profile
     *
     * @generated from protobuf rpc: AddCluster(teleport.lib.teleterm.v1.AddClusterRequest) returns (teleport.lib.teleterm.v1.Cluster);
     */
    addCluster(input: AddClusterRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Cluster) => void): grpc.ClientUnaryCall;
    addCluster(input: AddClusterRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: Cluster) => void): grpc.ClientUnaryCall;
    addCluster(input: AddClusterRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Cluster) => void): grpc.ClientUnaryCall;
    addCluster(input: AddClusterRequest, callback: (err: grpc.ServiceError | null, value?: Cluster) => void): grpc.ClientUnaryCall;
    /**
     * RemoveCluster removes a cluster from profile
     *
     * @generated from protobuf rpc: RemoveCluster(teleport.lib.teleterm.v1.RemoveClusterRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    removeCluster(input: RemoveClusterRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    removeCluster(input: RemoveClusterRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    removeCluster(input: RemoveClusterRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    removeCluster(input: RemoveClusterRequest, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    /**
     * ListGateways lists gateways
     *
     * @generated from protobuf rpc: ListGateways(teleport.lib.teleterm.v1.ListGatewaysRequest) returns (teleport.lib.teleterm.v1.ListGatewaysResponse);
     */
    listGateways(input: ListGatewaysRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListGatewaysResponse) => void): grpc.ClientUnaryCall;
    listGateways(input: ListGatewaysRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ListGatewaysResponse) => void): grpc.ClientUnaryCall;
    listGateways(input: ListGatewaysRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListGatewaysResponse) => void): grpc.ClientUnaryCall;
    listGateways(input: ListGatewaysRequest, callback: (err: grpc.ServiceError | null, value?: ListGatewaysResponse) => void): grpc.ClientUnaryCall;
    /**
     * CreateGateway creates a gateway
     *
     * @generated from protobuf rpc: CreateGateway(teleport.lib.teleterm.v1.CreateGatewayRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    createGateway(input: CreateGatewayRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    createGateway(input: CreateGatewayRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    createGateway(input: CreateGatewayRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    createGateway(input: CreateGatewayRequest, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    /**
     * RemoveGateway removes a gateway
     *
     * @generated from protobuf rpc: RemoveGateway(teleport.lib.teleterm.v1.RemoveGatewayRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    removeGateway(input: RemoveGatewayRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    removeGateway(input: RemoveGatewayRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    removeGateway(input: RemoveGatewayRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    removeGateway(input: RemoveGatewayRequest, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    /**
     * SetGatewayTargetSubresourceName changes the TargetSubresourceName field of gateway.Gateway
     * and returns the updated version of gateway.Gateway.
     *
     * In Connect this is used to update the db name of a db connection along with the CLI command.
     *
     * @generated from protobuf rpc: SetGatewayTargetSubresourceName(teleport.lib.teleterm.v1.SetGatewayTargetSubresourceNameRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    setGatewayTargetSubresourceName(input: SetGatewayTargetSubresourceNameRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    setGatewayTargetSubresourceName(input: SetGatewayTargetSubresourceNameRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    setGatewayTargetSubresourceName(input: SetGatewayTargetSubresourceNameRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    setGatewayTargetSubresourceName(input: SetGatewayTargetSubresourceNameRequest, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    /**
     * SetGatewayLocalPort starts a new gateway on the new port, stops the old gateway and then
     * assigns the URI of the old gateway to the new one. It does so without fetching a new db cert.
     *
     * @generated from protobuf rpc: SetGatewayLocalPort(teleport.lib.teleterm.v1.SetGatewayLocalPortRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    setGatewayLocalPort(input: SetGatewayLocalPortRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    setGatewayLocalPort(input: SetGatewayLocalPortRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    setGatewayLocalPort(input: SetGatewayLocalPortRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    setGatewayLocalPort(input: SetGatewayLocalPortRequest, callback: (err: grpc.ServiceError | null, value?: Gateway) => void): grpc.ClientUnaryCall;
    /**
     * GetAuthSettings returns cluster auth settigns
     *
     * @generated from protobuf rpc: GetAuthSettings(teleport.lib.teleterm.v1.GetAuthSettingsRequest) returns (teleport.lib.teleterm.v1.AuthSettings);
     */
    getAuthSettings(input: GetAuthSettingsRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: AuthSettings) => void): grpc.ClientUnaryCall;
    getAuthSettings(input: GetAuthSettingsRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: AuthSettings) => void): grpc.ClientUnaryCall;
    getAuthSettings(input: GetAuthSettingsRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: AuthSettings) => void): grpc.ClientUnaryCall;
    getAuthSettings(input: GetAuthSettingsRequest, callback: (err: grpc.ServiceError | null, value?: AuthSettings) => void): grpc.ClientUnaryCall;
    /**
     * GetCluster returns cluster. Makes a network request and includes detailed
     * information about enterprise features availabed on the connected auth server
     *
     * @generated from protobuf rpc: GetCluster(teleport.lib.teleterm.v1.GetClusterRequest) returns (teleport.lib.teleterm.v1.Cluster);
     */
    getCluster(input: GetClusterRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Cluster) => void): grpc.ClientUnaryCall;
    getCluster(input: GetClusterRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: Cluster) => void): grpc.ClientUnaryCall;
    getCluster(input: GetClusterRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: Cluster) => void): grpc.ClientUnaryCall;
    getCluster(input: GetClusterRequest, callback: (err: grpc.ServiceError | null, value?: Cluster) => void): grpc.ClientUnaryCall;
    /**
     * Login logs in a user to a cluster
     *
     * @generated from protobuf rpc: Login(teleport.lib.teleterm.v1.LoginRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    login(input: LoginRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    login(input: LoginRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    login(input: LoginRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    login(input: LoginRequest, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    /**
     * LoginPasswordless logs in a user to a cluster passwordlessly.
     *
     * The RPC is streaming both ways and the message sequence example for hardware keys are:
     * (-> means client-to-server, <- means server-to-client)
     *
     * Hardware keys:
     * -> Init
     * <- Send PasswordlessPrompt enum TAP to choose a device
     * -> Receive TAP device response
     * <- Send PasswordlessPrompt enum PIN
     * -> Receive PIN response
     * <- Send PasswordlessPrompt enum RETAP to confirm
     * -> Receive RETAP device response
     * <- Send list of credentials (e.g. usernames) associated with device
     * -> Receive the index number associated with the selected credential in list
     * <- End
     *
     * @generated from protobuf rpc: LoginPasswordless(stream teleport.lib.teleterm.v1.LoginPasswordlessRequest) returns (stream teleport.lib.teleterm.v1.LoginPasswordlessResponse);
     */
    loginPasswordless(metadata: grpc.Metadata, options?: grpc.CallOptions): grpc.ClientDuplexStream<LoginPasswordlessRequest, LoginPasswordlessResponse>;
    loginPasswordless(options?: grpc.CallOptions): grpc.ClientDuplexStream<LoginPasswordlessRequest, LoginPasswordlessResponse>;
    /**
     * ClusterLogin logs out a user from cluster
     *
     * @generated from protobuf rpc: Logout(teleport.lib.teleterm.v1.LogoutRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    logout(input: LogoutRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    logout(input: LogoutRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    logout(input: LogoutRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    logout(input: LogoutRequest, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    /**
     * TransferFile sends a request to download/upload a file
     *
     * @generated from protobuf rpc: TransferFile(teleport.lib.teleterm.v1.FileTransferRequest) returns (stream teleport.lib.teleterm.v1.FileTransferProgress);
     */
    transferFile(input: FileTransferRequest, metadata?: grpc.Metadata, options?: grpc.CallOptions): grpc.ClientReadableStream<FileTransferProgress>;
    transferFile(input: FileTransferRequest, options?: grpc.CallOptions): grpc.ClientReadableStream<FileTransferProgress>;
    /**
     * ReportUsageEvent allows to send usage events that are then anonymized and forwarded to prehog
     *
     * @generated from protobuf rpc: ReportUsageEvent(teleport.lib.teleterm.v1.ReportUsageEventRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    reportUsageEvent(input: ReportUsageEventRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    reportUsageEvent(input: ReportUsageEventRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    reportUsageEvent(input: ReportUsageEventRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    reportUsageEvent(input: ReportUsageEventRequest, callback: (err: grpc.ServiceError | null, value?: EmptyResponse) => void): grpc.ClientUnaryCall;
    /**
     * UpdateHeadlessAuthenticationState updates a headless authentication resource's state.
     * An MFA challenge will be prompted when approving a headless authentication.
     *
     * @generated from protobuf rpc: UpdateHeadlessAuthenticationState(teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateRequest) returns (teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateResponse);
     */
    updateHeadlessAuthenticationState(input: UpdateHeadlessAuthenticationStateRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: UpdateHeadlessAuthenticationStateResponse) => void): grpc.ClientUnaryCall;
    updateHeadlessAuthenticationState(input: UpdateHeadlessAuthenticationStateRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: UpdateHeadlessAuthenticationStateResponse) => void): grpc.ClientUnaryCall;
    updateHeadlessAuthenticationState(input: UpdateHeadlessAuthenticationStateRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: UpdateHeadlessAuthenticationStateResponse) => void): grpc.ClientUnaryCall;
    updateHeadlessAuthenticationState(input: UpdateHeadlessAuthenticationStateRequest, callback: (err: grpc.ServiceError | null, value?: UpdateHeadlessAuthenticationStateResponse) => void): grpc.ClientUnaryCall;
    /**
     * CreateConnectMyComputerRole creates a role which allows access to nodes with the label
     * teleport.dev/connect-my-computer/owner: <cluster user> and allows logging in to those nodes as
     * the current system user.
     *
     * @generated from protobuf rpc: CreateConnectMyComputerRole(teleport.lib.teleterm.v1.CreateConnectMyComputerRoleRequest) returns (teleport.lib.teleterm.v1.CreateConnectMyComputerRoleResponse);
     */
    createConnectMyComputerRole(input: CreateConnectMyComputerRoleRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateConnectMyComputerRoleResponse) => void): grpc.ClientUnaryCall;
    createConnectMyComputerRole(input: CreateConnectMyComputerRoleRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: CreateConnectMyComputerRoleResponse) => void): grpc.ClientUnaryCall;
    createConnectMyComputerRole(input: CreateConnectMyComputerRoleRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateConnectMyComputerRoleResponse) => void): grpc.ClientUnaryCall;
    createConnectMyComputerRole(input: CreateConnectMyComputerRoleRequest, callback: (err: grpc.ServiceError | null, value?: CreateConnectMyComputerRoleResponse) => void): grpc.ClientUnaryCall;
    /**
     * CreateConnectMyComputerNodeToken creates a node join token that is valid for 5 minutes
     *
     * @generated from protobuf rpc: CreateConnectMyComputerNodeToken(teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenRequest) returns (teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenResponse);
     */
    createConnectMyComputerNodeToken(input: CreateConnectMyComputerNodeTokenRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateConnectMyComputerNodeTokenResponse) => void): grpc.ClientUnaryCall;
    createConnectMyComputerNodeToken(input: CreateConnectMyComputerNodeTokenRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: CreateConnectMyComputerNodeTokenResponse) => void): grpc.ClientUnaryCall;
    createConnectMyComputerNodeToken(input: CreateConnectMyComputerNodeTokenRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: CreateConnectMyComputerNodeTokenResponse) => void): grpc.ClientUnaryCall;
    createConnectMyComputerNodeToken(input: CreateConnectMyComputerNodeTokenRequest, callback: (err: grpc.ServiceError | null, value?: CreateConnectMyComputerNodeTokenResponse) => void): grpc.ClientUnaryCall;
    /**
     * DeleteConnectMyComputerToken deletes a join token
     *
     * @generated from protobuf rpc: DeleteConnectMyComputerToken(teleport.lib.teleterm.v1.DeleteConnectMyComputerTokenRequest) returns (teleport.lib.teleterm.v1.DeleteConnectMyComputerTokenResponse);
     */
    deleteConnectMyComputerToken(input: DeleteConnectMyComputerTokenRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DeleteConnectMyComputerTokenResponse) => void): grpc.ClientUnaryCall;
    deleteConnectMyComputerToken(input: DeleteConnectMyComputerTokenRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: DeleteConnectMyComputerTokenResponse) => void): grpc.ClientUnaryCall;
    deleteConnectMyComputerToken(input: DeleteConnectMyComputerTokenRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DeleteConnectMyComputerTokenResponse) => void): grpc.ClientUnaryCall;
    deleteConnectMyComputerToken(input: DeleteConnectMyComputerTokenRequest, callback: (err: grpc.ServiceError | null, value?: DeleteConnectMyComputerTokenResponse) => void): grpc.ClientUnaryCall;
    /**
     * WaitForConnectMyComputerNodeJoin sets up a watcher and returns a response only after detecting
     * that the Connect My Computer node for the particular cluster has joined the cluster (the
     * OpPut event).
     *
     * This RPC times out by itself after a minute to prevent the request from hanging forever, in
     * case the client didn't set a deadline or doesn't abort the request.
     *
     * @generated from protobuf rpc: WaitForConnectMyComputerNodeJoin(teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinRequest) returns (teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinResponse);
     */
    waitForConnectMyComputerNodeJoin(input: WaitForConnectMyComputerNodeJoinRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: WaitForConnectMyComputerNodeJoinResponse) => void): grpc.ClientUnaryCall;
    waitForConnectMyComputerNodeJoin(input: WaitForConnectMyComputerNodeJoinRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: WaitForConnectMyComputerNodeJoinResponse) => void): grpc.ClientUnaryCall;
    waitForConnectMyComputerNodeJoin(input: WaitForConnectMyComputerNodeJoinRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: WaitForConnectMyComputerNodeJoinResponse) => void): grpc.ClientUnaryCall;
    waitForConnectMyComputerNodeJoin(input: WaitForConnectMyComputerNodeJoinRequest, callback: (err: grpc.ServiceError | null, value?: WaitForConnectMyComputerNodeJoinResponse) => void): grpc.ClientUnaryCall;
    /**
     * DeleteConnectMyComputerNode deletes the Connect My Computer node.
     *
     * @generated from protobuf rpc: DeleteConnectMyComputerNode(teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeRequest) returns (teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeResponse);
     */
    deleteConnectMyComputerNode(input: DeleteConnectMyComputerNodeRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DeleteConnectMyComputerNodeResponse) => void): grpc.ClientUnaryCall;
    deleteConnectMyComputerNode(input: DeleteConnectMyComputerNodeRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: DeleteConnectMyComputerNodeResponse) => void): grpc.ClientUnaryCall;
    deleteConnectMyComputerNode(input: DeleteConnectMyComputerNodeRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DeleteConnectMyComputerNodeResponse) => void): grpc.ClientUnaryCall;
    deleteConnectMyComputerNode(input: DeleteConnectMyComputerNodeRequest, callback: (err: grpc.ServiceError | null, value?: DeleteConnectMyComputerNodeResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetConnectMyComputerNodeName reads the Connect My Computer node name (UUID) from a disk.
     *
     * @generated from protobuf rpc: GetConnectMyComputerNodeName(teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameRequest) returns (teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameResponse);
     */
    getConnectMyComputerNodeName(input: GetConnectMyComputerNodeNameRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetConnectMyComputerNodeNameResponse) => void): grpc.ClientUnaryCall;
    getConnectMyComputerNodeName(input: GetConnectMyComputerNodeNameRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetConnectMyComputerNodeNameResponse) => void): grpc.ClientUnaryCall;
    getConnectMyComputerNodeName(input: GetConnectMyComputerNodeNameRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetConnectMyComputerNodeNameResponse) => void): grpc.ClientUnaryCall;
    getConnectMyComputerNodeName(input: GetConnectMyComputerNodeNameRequest, callback: (err: grpc.ServiceError | null, value?: GetConnectMyComputerNodeNameResponse) => void): grpc.ClientUnaryCall;
    /**
     * ListUnifiedResources retrieves a paginated list of all resource types displayable in the UI.
     *
     * @generated from protobuf rpc: ListUnifiedResources(teleport.lib.teleterm.v1.ListUnifiedResourcesRequest) returns (teleport.lib.teleterm.v1.ListUnifiedResourcesResponse);
     */
    listUnifiedResources(input: ListUnifiedResourcesRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListUnifiedResourcesResponse) => void): grpc.ClientUnaryCall;
    listUnifiedResources(input: ListUnifiedResourcesRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ListUnifiedResourcesResponse) => void): grpc.ClientUnaryCall;
    listUnifiedResources(input: ListUnifiedResourcesRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListUnifiedResourcesResponse) => void): grpc.ClientUnaryCall;
    listUnifiedResources(input: ListUnifiedResourcesRequest, callback: (err: grpc.ServiceError | null, value?: ListUnifiedResourcesResponse) => void): grpc.ClientUnaryCall;
    /**
     * GetUserPreferences returns the combined (root + leaf cluster) preferences for a given user.
     *
     * @generated from protobuf rpc: GetUserPreferences(teleport.lib.teleterm.v1.GetUserPreferencesRequest) returns (teleport.lib.teleterm.v1.GetUserPreferencesResponse);
     */
    getUserPreferences(input: GetUserPreferencesRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetUserPreferencesResponse) => void): grpc.ClientUnaryCall;
    getUserPreferences(input: GetUserPreferencesRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: GetUserPreferencesResponse) => void): grpc.ClientUnaryCall;
    getUserPreferences(input: GetUserPreferencesRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: GetUserPreferencesResponse) => void): grpc.ClientUnaryCall;
    getUserPreferences(input: GetUserPreferencesRequest, callback: (err: grpc.ServiceError | null, value?: GetUserPreferencesResponse) => void): grpc.ClientUnaryCall;
    /**
     * UpdateUserPreferences updates the preferences for a given user in appropriate root and leaf clusters.
     * Only the properties that are set (cluster_preferences, unified_resource_preferences) will be updated.
     *
     * @generated from protobuf rpc: UpdateUserPreferences(teleport.lib.teleterm.v1.UpdateUserPreferencesRequest) returns (teleport.lib.teleterm.v1.UpdateUserPreferencesResponse);
     */
    updateUserPreferences(input: UpdateUserPreferencesRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: UpdateUserPreferencesResponse) => void): grpc.ClientUnaryCall;
    updateUserPreferences(input: UpdateUserPreferencesRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: UpdateUserPreferencesResponse) => void): grpc.ClientUnaryCall;
    updateUserPreferences(input: UpdateUserPreferencesRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: UpdateUserPreferencesResponse) => void): grpc.ClientUnaryCall;
    updateUserPreferences(input: UpdateUserPreferencesRequest, callback: (err: grpc.ServiceError | null, value?: UpdateUserPreferencesResponse) => void): grpc.ClientUnaryCall;
}
/**
 * TerminalService is used by the Electron app to communicate with the tsh daemon.
 *
 * While we aim to preserve backwards compatibility in order to satisfy CI checks and follow the
 * proto practices used within the company, this service is not guaranteed to be stable across
 * versions. The packaging process of Teleport Connect ensures that the server and the client use
 * the same version of the service.
 *
 * @generated from protobuf service teleport.lib.teleterm.v1.TerminalService
 */
export class TerminalServiceClient extends grpc.Client implements ITerminalServiceClient {
    private readonly _binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions>;
    constructor(address: string, credentials: grpc.ChannelCredentials, options: grpc.ClientOptions = {}, binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions> = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     * UpdateTshdEventsServerAddress lets the Electron app update the address the tsh daemon is
     * supposed to use when connecting to the tshd events gRPC service. This RPC needs to be made
     * before any other from this service.
     *
     * The service is supposed to return a response from this call only after the client is ready.
     *
     * @generated from protobuf rpc: UpdateTshdEventsServerAddress(teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressRequest) returns (teleport.lib.teleterm.v1.UpdateTshdEventsServerAddressResponse);
     */
    updateTshdEventsServerAddress(input: UpdateTshdEventsServerAddressRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: UpdateTshdEventsServerAddressResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: UpdateTshdEventsServerAddressResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: UpdateTshdEventsServerAddressResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[0];
        return this.makeUnaryRequest<UpdateTshdEventsServerAddressRequest, UpdateTshdEventsServerAddressResponse>(`/${TerminalService.typeName}/${method.name}`, (value: UpdateTshdEventsServerAddressRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): UpdateTshdEventsServerAddressResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ListRootClusters lists root clusters
     * Does not include detailed cluster information that would require a network request.
     *
     * @generated from protobuf rpc: ListRootClusters(teleport.lib.teleterm.v1.ListClustersRequest) returns (teleport.lib.teleterm.v1.ListClustersResponse);
     */
    listRootClusters(input: ListClustersRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListClustersResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListClustersResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ListClustersResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[1];
        return this.makeUnaryRequest<ListClustersRequest, ListClustersResponse>(`/${TerminalService.typeName}/${method.name}`, (value: ListClustersRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ListClustersResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ListLeafClusters lists leaf clusters
     * Does not include detailed cluster information that would require a network request.
     *
     * @generated from protobuf rpc: ListLeafClusters(teleport.lib.teleterm.v1.ListLeafClustersRequest) returns (teleport.lib.teleterm.v1.ListClustersResponse);
     */
    listLeafClusters(input: ListLeafClustersRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListClustersResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListClustersResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ListClustersResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[2];
        return this.makeUnaryRequest<ListLeafClustersRequest, ListClustersResponse>(`/${TerminalService.typeName}/${method.name}`, (value: ListLeafClustersRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ListClustersResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetDatabases returns a filtered and paginated list of databases
     *
     * @generated from protobuf rpc: GetDatabases(teleport.lib.teleterm.v1.GetDatabasesRequest) returns (teleport.lib.teleterm.v1.GetDatabasesResponse);
     */
    getDatabases(input: GetDatabasesRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetDatabasesResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetDatabasesResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetDatabasesResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[3];
        return this.makeUnaryRequest<GetDatabasesRequest, GetDatabasesResponse>(`/${TerminalService.typeName}/${method.name}`, (value: GetDatabasesRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetDatabasesResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ListDatabaseUsers lists allowed users for the given database based on the role set.
     *
     * @generated from protobuf rpc: ListDatabaseUsers(teleport.lib.teleterm.v1.ListDatabaseUsersRequest) returns (teleport.lib.teleterm.v1.ListDatabaseUsersResponse);
     */
    listDatabaseUsers(input: ListDatabaseUsersRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListDatabaseUsersResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListDatabaseUsersResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ListDatabaseUsersResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[4];
        return this.makeUnaryRequest<ListDatabaseUsersRequest, ListDatabaseUsersResponse>(`/${TerminalService.typeName}/${method.name}`, (value: ListDatabaseUsersRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ListDatabaseUsersResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetServers returns filtered, sorted, and paginated servers
     *
     * @generated from protobuf rpc: GetServers(teleport.lib.teleterm.v1.GetServersRequest) returns (teleport.lib.teleterm.v1.GetServersResponse);
     */
    getServers(input: GetServersRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetServersResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetServersResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetServersResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[5];
        return this.makeUnaryRequest<GetServersRequest, GetServersResponse>(`/${TerminalService.typeName}/${method.name}`, (value: GetServersRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetServersResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetAccessRequests lists filtered AccessRequests
     *
     * @generated from protobuf rpc: GetAccessRequests(teleport.lib.teleterm.v1.GetAccessRequestsRequest) returns (teleport.lib.teleterm.v1.GetAccessRequestsResponse);
     */
    getAccessRequests(input: GetAccessRequestsRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetAccessRequestsResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetAccessRequestsResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetAccessRequestsResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[6];
        return this.makeUnaryRequest<GetAccessRequestsRequest, GetAccessRequestsResponse>(`/${TerminalService.typeName}/${method.name}`, (value: GetAccessRequestsRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetAccessRequestsResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetAccessRequest retreives a single Access Request
     *
     * @generated from protobuf rpc: GetAccessRequest(teleport.lib.teleterm.v1.GetAccessRequestRequest) returns (teleport.lib.teleterm.v1.GetAccessRequestResponse);
     */
    getAccessRequest(input: GetAccessRequestRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetAccessRequestResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetAccessRequestResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetAccessRequestResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[7];
        return this.makeUnaryRequest<GetAccessRequestRequest, GetAccessRequestResponse>(`/${TerminalService.typeName}/${method.name}`, (value: GetAccessRequestRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetAccessRequestResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * DeleteAccessRequest deletes the access request by id
     *
     * @generated from protobuf rpc: DeleteAccessRequest(teleport.lib.teleterm.v1.DeleteAccessRequestRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    deleteAccessRequest(input: DeleteAccessRequestRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: EmptyResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[8];
        return this.makeUnaryRequest<DeleteAccessRequestRequest, EmptyResponse>(`/${TerminalService.typeName}/${method.name}`, (value: DeleteAccessRequestRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): EmptyResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CreateAccessRequest creates an access request
     *
     * @generated from protobuf rpc: CreateAccessRequest(teleport.lib.teleterm.v1.CreateAccessRequestRequest) returns (teleport.lib.teleterm.v1.CreateAccessRequestResponse);
     */
    createAccessRequest(input: CreateAccessRequestRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateAccessRequestResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateAccessRequestResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: CreateAccessRequestResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[9];
        return this.makeUnaryRequest<CreateAccessRequestRequest, CreateAccessRequestResponse>(`/${TerminalService.typeName}/${method.name}`, (value: CreateAccessRequestRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): CreateAccessRequestResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ReviewAccessRequest submits a review for an Access Request
     *
     * @generated from protobuf rpc: ReviewAccessRequest(teleport.lib.teleterm.v1.ReviewAccessRequestRequest) returns (teleport.lib.teleterm.v1.ReviewAccessRequestResponse);
     */
    reviewAccessRequest(input: ReviewAccessRequestRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ReviewAccessRequestResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ReviewAccessRequestResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ReviewAccessRequestResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[10];
        return this.makeUnaryRequest<ReviewAccessRequestRequest, ReviewAccessRequestResponse>(`/${TerminalService.typeName}/${method.name}`, (value: ReviewAccessRequestRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ReviewAccessRequestResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetRequestableRoles gets all requestable roles
     *
     * @generated from protobuf rpc: GetRequestableRoles(teleport.lib.teleterm.v1.GetRequestableRolesRequest) returns (teleport.lib.teleterm.v1.GetRequestableRolesResponse);
     */
    getRequestableRoles(input: GetRequestableRolesRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetRequestableRolesResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetRequestableRolesResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetRequestableRolesResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[11];
        return this.makeUnaryRequest<GetRequestableRolesRequest, GetRequestableRolesResponse>(`/${TerminalService.typeName}/${method.name}`, (value: GetRequestableRolesRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetRequestableRolesResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * AssumeRole assumes the role of the given access request
     *
     * @generated from protobuf rpc: AssumeRole(teleport.lib.teleterm.v1.AssumeRoleRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    assumeRole(input: AssumeRoleRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: EmptyResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[12];
        return this.makeUnaryRequest<AssumeRoleRequest, EmptyResponse>(`/${TerminalService.typeName}/${method.name}`, (value: AssumeRoleRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): EmptyResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * PromoteAccessRequest promotes an access request to an access list.
     *
     * @generated from protobuf rpc: PromoteAccessRequest(teleport.lib.teleterm.v1.PromoteAccessRequestRequest) returns (teleport.lib.teleterm.v1.PromoteAccessRequestResponse);
     */
    promoteAccessRequest(input: PromoteAccessRequestRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PromoteAccessRequestResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PromoteAccessRequestResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: PromoteAccessRequestResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[13];
        return this.makeUnaryRequest<PromoteAccessRequestRequest, PromoteAccessRequestResponse>(`/${TerminalService.typeName}/${method.name}`, (value: PromoteAccessRequestRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): PromoteAccessRequestResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetSuggestedAccessLists returns suggested access lists for an access request.
     *
     * @generated from protobuf rpc: GetSuggestedAccessLists(teleport.lib.teleterm.v1.GetSuggestedAccessListsRequest) returns (teleport.lib.teleterm.v1.GetSuggestedAccessListsResponse);
     */
    getSuggestedAccessLists(input: GetSuggestedAccessListsRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetSuggestedAccessListsResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetSuggestedAccessListsResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetSuggestedAccessListsResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[14];
        return this.makeUnaryRequest<GetSuggestedAccessListsRequest, GetSuggestedAccessListsResponse>(`/${TerminalService.typeName}/${method.name}`, (value: GetSuggestedAccessListsRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetSuggestedAccessListsResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetKubes returns filtered, sorted, and paginated kubes
     *
     * @generated from protobuf rpc: GetKubes(teleport.lib.teleterm.v1.GetKubesRequest) returns (teleport.lib.teleterm.v1.GetKubesResponse);
     */
    getKubes(input: GetKubesRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetKubesResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetKubesResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetKubesResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[15];
        return this.makeUnaryRequest<GetKubesRequest, GetKubesResponse>(`/${TerminalService.typeName}/${method.name}`, (value: GetKubesRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetKubesResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetApps returns a filtered and paginated list of apps.
     *
     * @generated from protobuf rpc: GetApps(teleport.lib.teleterm.v1.GetAppsRequest) returns (teleport.lib.teleterm.v1.GetAppsResponse);
     */
    getApps(input: GetAppsRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetAppsResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetAppsResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetAppsResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[16];
        return this.makeUnaryRequest<GetAppsRequest, GetAppsResponse>(`/${TerminalService.typeName}/${method.name}`, (value: GetAppsRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetAppsResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * AddCluster adds a cluster to profile
     *
     * @generated from protobuf rpc: AddCluster(teleport.lib.teleterm.v1.AddClusterRequest) returns (teleport.lib.teleterm.v1.Cluster);
     */
    addCluster(input: AddClusterRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Cluster) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Cluster) => void), callback?: ((err: grpc.ServiceError | null, value?: Cluster) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[17];
        return this.makeUnaryRequest<AddClusterRequest, Cluster>(`/${TerminalService.typeName}/${method.name}`, (value: AddClusterRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): Cluster => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * RemoveCluster removes a cluster from profile
     *
     * @generated from protobuf rpc: RemoveCluster(teleport.lib.teleterm.v1.RemoveClusterRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    removeCluster(input: RemoveClusterRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: EmptyResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[18];
        return this.makeUnaryRequest<RemoveClusterRequest, EmptyResponse>(`/${TerminalService.typeName}/${method.name}`, (value: RemoveClusterRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): EmptyResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ListGateways lists gateways
     *
     * @generated from protobuf rpc: ListGateways(teleport.lib.teleterm.v1.ListGatewaysRequest) returns (teleport.lib.teleterm.v1.ListGatewaysResponse);
     */
    listGateways(input: ListGatewaysRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListGatewaysResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListGatewaysResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ListGatewaysResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[19];
        return this.makeUnaryRequest<ListGatewaysRequest, ListGatewaysResponse>(`/${TerminalService.typeName}/${method.name}`, (value: ListGatewaysRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ListGatewaysResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CreateGateway creates a gateway
     *
     * @generated from protobuf rpc: CreateGateway(teleport.lib.teleterm.v1.CreateGatewayRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    createGateway(input: CreateGatewayRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Gateway) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Gateway) => void), callback?: ((err: grpc.ServiceError | null, value?: Gateway) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[20];
        return this.makeUnaryRequest<CreateGatewayRequest, Gateway>(`/${TerminalService.typeName}/${method.name}`, (value: CreateGatewayRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): Gateway => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * RemoveGateway removes a gateway
     *
     * @generated from protobuf rpc: RemoveGateway(teleport.lib.teleterm.v1.RemoveGatewayRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    removeGateway(input: RemoveGatewayRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: EmptyResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[21];
        return this.makeUnaryRequest<RemoveGatewayRequest, EmptyResponse>(`/${TerminalService.typeName}/${method.name}`, (value: RemoveGatewayRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): EmptyResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * SetGatewayTargetSubresourceName changes the TargetSubresourceName field of gateway.Gateway
     * and returns the updated version of gateway.Gateway.
     *
     * In Connect this is used to update the db name of a db connection along with the CLI command.
     *
     * @generated from protobuf rpc: SetGatewayTargetSubresourceName(teleport.lib.teleterm.v1.SetGatewayTargetSubresourceNameRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    setGatewayTargetSubresourceName(input: SetGatewayTargetSubresourceNameRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Gateway) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Gateway) => void), callback?: ((err: grpc.ServiceError | null, value?: Gateway) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[22];
        return this.makeUnaryRequest<SetGatewayTargetSubresourceNameRequest, Gateway>(`/${TerminalService.typeName}/${method.name}`, (value: SetGatewayTargetSubresourceNameRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): Gateway => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * SetGatewayLocalPort starts a new gateway on the new port, stops the old gateway and then
     * assigns the URI of the old gateway to the new one. It does so without fetching a new db cert.
     *
     * @generated from protobuf rpc: SetGatewayLocalPort(teleport.lib.teleterm.v1.SetGatewayLocalPortRequest) returns (teleport.lib.teleterm.v1.Gateway);
     */
    setGatewayLocalPort(input: SetGatewayLocalPortRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Gateway) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Gateway) => void), callback?: ((err: grpc.ServiceError | null, value?: Gateway) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[23];
        return this.makeUnaryRequest<SetGatewayLocalPortRequest, Gateway>(`/${TerminalService.typeName}/${method.name}`, (value: SetGatewayLocalPortRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): Gateway => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetAuthSettings returns cluster auth settigns
     *
     * @generated from protobuf rpc: GetAuthSettings(teleport.lib.teleterm.v1.GetAuthSettingsRequest) returns (teleport.lib.teleterm.v1.AuthSettings);
     */
    getAuthSettings(input: GetAuthSettingsRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: AuthSettings) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: AuthSettings) => void), callback?: ((err: grpc.ServiceError | null, value?: AuthSettings) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[24];
        return this.makeUnaryRequest<GetAuthSettingsRequest, AuthSettings>(`/${TerminalService.typeName}/${method.name}`, (value: GetAuthSettingsRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): AuthSettings => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetCluster returns cluster. Makes a network request and includes detailed
     * information about enterprise features availabed on the connected auth server
     *
     * @generated from protobuf rpc: GetCluster(teleport.lib.teleterm.v1.GetClusterRequest) returns (teleport.lib.teleterm.v1.Cluster);
     */
    getCluster(input: GetClusterRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Cluster) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: Cluster) => void), callback?: ((err: grpc.ServiceError | null, value?: Cluster) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[25];
        return this.makeUnaryRequest<GetClusterRequest, Cluster>(`/${TerminalService.typeName}/${method.name}`, (value: GetClusterRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): Cluster => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * Login logs in a user to a cluster
     *
     * @generated from protobuf rpc: Login(teleport.lib.teleterm.v1.LoginRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    login(input: LoginRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: EmptyResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[26];
        return this.makeUnaryRequest<LoginRequest, EmptyResponse>(`/${TerminalService.typeName}/${method.name}`, (value: LoginRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): EmptyResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * LoginPasswordless logs in a user to a cluster passwordlessly.
     *
     * The RPC is streaming both ways and the message sequence example for hardware keys are:
     * (-> means client-to-server, <- means server-to-client)
     *
     * Hardware keys:
     * -> Init
     * <- Send PasswordlessPrompt enum TAP to choose a device
     * -> Receive TAP device response
     * <- Send PasswordlessPrompt enum PIN
     * -> Receive PIN response
     * <- Send PasswordlessPrompt enum RETAP to confirm
     * -> Receive RETAP device response
     * <- Send list of credentials (e.g. usernames) associated with device
     * -> Receive the index number associated with the selected credential in list
     * <- End
     *
     * @generated from protobuf rpc: LoginPasswordless(stream teleport.lib.teleterm.v1.LoginPasswordlessRequest) returns (stream teleport.lib.teleterm.v1.LoginPasswordlessResponse);
     */
    loginPasswordless(metadata?: grpc.Metadata | grpc.CallOptions, options?: grpc.CallOptions): grpc.ClientDuplexStream<LoginPasswordlessRequest, LoginPasswordlessResponse> {
        const method = TerminalService.methods[27];
        return this.makeBidiStreamRequest<LoginPasswordlessRequest, LoginPasswordlessResponse>(`/${TerminalService.typeName}/${method.name}`, (value: LoginPasswordlessRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): LoginPasswordlessResponse => method.O.fromBinary(value, this._binaryOptions), (metadata as any), options);
    }
    /**
     * ClusterLogin logs out a user from cluster
     *
     * @generated from protobuf rpc: Logout(teleport.lib.teleterm.v1.LogoutRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    logout(input: LogoutRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: EmptyResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[28];
        return this.makeUnaryRequest<LogoutRequest, EmptyResponse>(`/${TerminalService.typeName}/${method.name}`, (value: LogoutRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): EmptyResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * TransferFile sends a request to download/upload a file
     *
     * @generated from protobuf rpc: TransferFile(teleport.lib.teleterm.v1.FileTransferRequest) returns (stream teleport.lib.teleterm.v1.FileTransferProgress);
     */
    transferFile(input: FileTransferRequest, metadata?: grpc.Metadata | grpc.CallOptions, options?: grpc.CallOptions): grpc.ClientReadableStream<FileTransferProgress> {
        const method = TerminalService.methods[29];
        return this.makeServerStreamRequest<FileTransferRequest, FileTransferProgress>(`/${TerminalService.typeName}/${method.name}`, (value: FileTransferRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): FileTransferProgress => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), options);
    }
    /**
     * ReportUsageEvent allows to send usage events that are then anonymized and forwarded to prehog
     *
     * @generated from protobuf rpc: ReportUsageEvent(teleport.lib.teleterm.v1.ReportUsageEventRequest) returns (teleport.lib.teleterm.v1.EmptyResponse);
     */
    reportUsageEvent(input: ReportUsageEventRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: EmptyResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: EmptyResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[30];
        return this.makeUnaryRequest<ReportUsageEventRequest, EmptyResponse>(`/${TerminalService.typeName}/${method.name}`, (value: ReportUsageEventRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): EmptyResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * UpdateHeadlessAuthenticationState updates a headless authentication resource's state.
     * An MFA challenge will be prompted when approving a headless authentication.
     *
     * @generated from protobuf rpc: UpdateHeadlessAuthenticationState(teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateRequest) returns (teleport.lib.teleterm.v1.UpdateHeadlessAuthenticationStateResponse);
     */
    updateHeadlessAuthenticationState(input: UpdateHeadlessAuthenticationStateRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: UpdateHeadlessAuthenticationStateResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: UpdateHeadlessAuthenticationStateResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: UpdateHeadlessAuthenticationStateResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[31];
        return this.makeUnaryRequest<UpdateHeadlessAuthenticationStateRequest, UpdateHeadlessAuthenticationStateResponse>(`/${TerminalService.typeName}/${method.name}`, (value: UpdateHeadlessAuthenticationStateRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): UpdateHeadlessAuthenticationStateResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CreateConnectMyComputerRole creates a role which allows access to nodes with the label
     * teleport.dev/connect-my-computer/owner: <cluster user> and allows logging in to those nodes as
     * the current system user.
     *
     * @generated from protobuf rpc: CreateConnectMyComputerRole(teleport.lib.teleterm.v1.CreateConnectMyComputerRoleRequest) returns (teleport.lib.teleterm.v1.CreateConnectMyComputerRoleResponse);
     */
    createConnectMyComputerRole(input: CreateConnectMyComputerRoleRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateConnectMyComputerRoleResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateConnectMyComputerRoleResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: CreateConnectMyComputerRoleResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[32];
        return this.makeUnaryRequest<CreateConnectMyComputerRoleRequest, CreateConnectMyComputerRoleResponse>(`/${TerminalService.typeName}/${method.name}`, (value: CreateConnectMyComputerRoleRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): CreateConnectMyComputerRoleResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * CreateConnectMyComputerNodeToken creates a node join token that is valid for 5 minutes
     *
     * @generated from protobuf rpc: CreateConnectMyComputerNodeToken(teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenRequest) returns (teleport.lib.teleterm.v1.CreateConnectMyComputerNodeTokenResponse);
     */
    createConnectMyComputerNodeToken(input: CreateConnectMyComputerNodeTokenRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateConnectMyComputerNodeTokenResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: CreateConnectMyComputerNodeTokenResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: CreateConnectMyComputerNodeTokenResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[33];
        return this.makeUnaryRequest<CreateConnectMyComputerNodeTokenRequest, CreateConnectMyComputerNodeTokenResponse>(`/${TerminalService.typeName}/${method.name}`, (value: CreateConnectMyComputerNodeTokenRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): CreateConnectMyComputerNodeTokenResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * DeleteConnectMyComputerToken deletes a join token
     *
     * @generated from protobuf rpc: DeleteConnectMyComputerToken(teleport.lib.teleterm.v1.DeleteConnectMyComputerTokenRequest) returns (teleport.lib.teleterm.v1.DeleteConnectMyComputerTokenResponse);
     */
    deleteConnectMyComputerToken(input: DeleteConnectMyComputerTokenRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DeleteConnectMyComputerTokenResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DeleteConnectMyComputerTokenResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: DeleteConnectMyComputerTokenResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[34];
        return this.makeUnaryRequest<DeleteConnectMyComputerTokenRequest, DeleteConnectMyComputerTokenResponse>(`/${TerminalService.typeName}/${method.name}`, (value: DeleteConnectMyComputerTokenRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): DeleteConnectMyComputerTokenResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * WaitForConnectMyComputerNodeJoin sets up a watcher and returns a response only after detecting
     * that the Connect My Computer node for the particular cluster has joined the cluster (the
     * OpPut event).
     *
     * This RPC times out by itself after a minute to prevent the request from hanging forever, in
     * case the client didn't set a deadline or doesn't abort the request.
     *
     * @generated from protobuf rpc: WaitForConnectMyComputerNodeJoin(teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinRequest) returns (teleport.lib.teleterm.v1.WaitForConnectMyComputerNodeJoinResponse);
     */
    waitForConnectMyComputerNodeJoin(input: WaitForConnectMyComputerNodeJoinRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: WaitForConnectMyComputerNodeJoinResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: WaitForConnectMyComputerNodeJoinResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: WaitForConnectMyComputerNodeJoinResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[35];
        return this.makeUnaryRequest<WaitForConnectMyComputerNodeJoinRequest, WaitForConnectMyComputerNodeJoinResponse>(`/${TerminalService.typeName}/${method.name}`, (value: WaitForConnectMyComputerNodeJoinRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): WaitForConnectMyComputerNodeJoinResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * DeleteConnectMyComputerNode deletes the Connect My Computer node.
     *
     * @generated from protobuf rpc: DeleteConnectMyComputerNode(teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeRequest) returns (teleport.lib.teleterm.v1.DeleteConnectMyComputerNodeResponse);
     */
    deleteConnectMyComputerNode(input: DeleteConnectMyComputerNodeRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DeleteConnectMyComputerNodeResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DeleteConnectMyComputerNodeResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: DeleteConnectMyComputerNodeResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[36];
        return this.makeUnaryRequest<DeleteConnectMyComputerNodeRequest, DeleteConnectMyComputerNodeResponse>(`/${TerminalService.typeName}/${method.name}`, (value: DeleteConnectMyComputerNodeRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): DeleteConnectMyComputerNodeResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetConnectMyComputerNodeName reads the Connect My Computer node name (UUID) from a disk.
     *
     * @generated from protobuf rpc: GetConnectMyComputerNodeName(teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameRequest) returns (teleport.lib.teleterm.v1.GetConnectMyComputerNodeNameResponse);
     */
    getConnectMyComputerNodeName(input: GetConnectMyComputerNodeNameRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetConnectMyComputerNodeNameResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetConnectMyComputerNodeNameResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetConnectMyComputerNodeNameResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[37];
        return this.makeUnaryRequest<GetConnectMyComputerNodeNameRequest, GetConnectMyComputerNodeNameResponse>(`/${TerminalService.typeName}/${method.name}`, (value: GetConnectMyComputerNodeNameRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetConnectMyComputerNodeNameResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * ListUnifiedResources retrieves a paginated list of all resource types displayable in the UI.
     *
     * @generated from protobuf rpc: ListUnifiedResources(teleport.lib.teleterm.v1.ListUnifiedResourcesRequest) returns (teleport.lib.teleterm.v1.ListUnifiedResourcesResponse);
     */
    listUnifiedResources(input: ListUnifiedResourcesRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListUnifiedResourcesResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListUnifiedResourcesResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ListUnifiedResourcesResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[38];
        return this.makeUnaryRequest<ListUnifiedResourcesRequest, ListUnifiedResourcesResponse>(`/${TerminalService.typeName}/${method.name}`, (value: ListUnifiedResourcesRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ListUnifiedResourcesResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * GetUserPreferences returns the combined (root + leaf cluster) preferences for a given user.
     *
     * @generated from protobuf rpc: GetUserPreferences(teleport.lib.teleterm.v1.GetUserPreferencesRequest) returns (teleport.lib.teleterm.v1.GetUserPreferencesResponse);
     */
    getUserPreferences(input: GetUserPreferencesRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetUserPreferencesResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: GetUserPreferencesResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: GetUserPreferencesResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[39];
        return this.makeUnaryRequest<GetUserPreferencesRequest, GetUserPreferencesResponse>(`/${TerminalService.typeName}/${method.name}`, (value: GetUserPreferencesRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): GetUserPreferencesResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * UpdateUserPreferences updates the preferences for a given user in appropriate root and leaf clusters.
     * Only the properties that are set (cluster_preferences, unified_resource_preferences) will be updated.
     *
     * @generated from protobuf rpc: UpdateUserPreferences(teleport.lib.teleterm.v1.UpdateUserPreferencesRequest) returns (teleport.lib.teleterm.v1.UpdateUserPreferencesResponse);
     */
    updateUserPreferences(input: UpdateUserPreferencesRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: UpdateUserPreferencesResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: UpdateUserPreferencesResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: UpdateUserPreferencesResponse) => void)): grpc.ClientUnaryCall {
        const method = TerminalService.methods[40];
        return this.makeUnaryRequest<UpdateUserPreferencesRequest, UpdateUserPreferencesResponse>(`/${TerminalService.typeName}/${method.name}`, (value: UpdateUserPreferencesRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): UpdateUserPreferencesResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
}
