// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: teleport/accesslist/v1/accesslist.proto

package accesslistv1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	v1 "github.com/gravitational/teleport/api/gen/wrappers/teleport/header/v1"
	v11 "github.com/gravitational/teleport/api/gen/wrappers/teleport/trait/v1"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AccessList describes the basic building block of access grants, which are
// similar to access requests but for longer lived permissions that need to be
// regularly audited.
type AccessList struct {
	// header is the header for the resource.
	Header *v1.ResourceHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// spec is the specification for the access list.
	Spec                 *AccessListSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AccessList) Reset()         { *m = AccessList{} }
func (m *AccessList) String() string { return proto.CompactTextString(m) }
func (*AccessList) ProtoMessage()    {}
func (*AccessList) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbe449dcb815a15c, []int{0}
}
func (m *AccessList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessList.Merge(m, src)
}
func (m *AccessList) XXX_Size() int {
	return m.Size()
}
func (m *AccessList) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessList.DiscardUnknown(m)
}

var xxx_messageInfo_AccessList proto.InternalMessageInfo

func (m *AccessList) GetHeader() *v1.ResourceHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AccessList) GetSpec() *AccessListSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// AccessListSpec is the specification for an access list.
type AccessListSpec struct {
	// description is a plaintext description of the access list.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// owners is a list of owners of the access list.
	Owners []*AccessListOwner `protobuf:"bytes,2,rep,name=owners,proto3" json:"owners,omitempty"`
	// audit describes the frequency that this access list must be audited.
	Audit *AccessListAudit `protobuf:"bytes,3,opt,name=audit,proto3" json:"audit,omitempty"`
	// membership_requires describes the requirements for a user to be a member of the access list.
	// For a membership to an access list to be effective, the user must meet the requirements of
	// Membership_requires and must be in the members list.
	MembershipRequires *AccessListRequires `protobuf:"bytes,4,opt,name=membership_requires,json=membershipRequires,proto3" json:"membership_requires,omitempty"`
	// ownership_requires describes the requirements for a user to be an owner of the access list.
	// For ownership of an access list to be effective, the user must meet the requirements of
	// ownership_requires and must be in the owners list.
	OwnershipRequires *AccessListRequires `protobuf:"bytes,5,opt,name=ownership_requires,json=ownershipRequires,proto3" json:"ownership_requires,omitempty"`
	// grants describes the access granted by membership to this access list.
	Grants *AccessListGrants `protobuf:"bytes,6,opt,name=grants,proto3" json:"grants,omitempty"`
	// members describes the current members of the access list.
	Members              []*AccessListMember `protobuf:"bytes,7,rep,name=members,proto3" json:"members,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AccessListSpec) Reset()         { *m = AccessListSpec{} }
func (m *AccessListSpec) String() string { return proto.CompactTextString(m) }
func (*AccessListSpec) ProtoMessage()    {}
func (*AccessListSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbe449dcb815a15c, []int{1}
}
func (m *AccessListSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessListSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessListSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessListSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessListSpec.Merge(m, src)
}
func (m *AccessListSpec) XXX_Size() int {
	return m.Size()
}
func (m *AccessListSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessListSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AccessListSpec proto.InternalMessageInfo

func (m *AccessListSpec) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AccessListSpec) GetOwners() []*AccessListOwner {
	if m != nil {
		return m.Owners
	}
	return nil
}

func (m *AccessListSpec) GetAudit() *AccessListAudit {
	if m != nil {
		return m.Audit
	}
	return nil
}

func (m *AccessListSpec) GetMembershipRequires() *AccessListRequires {
	if m != nil {
		return m.MembershipRequires
	}
	return nil
}

func (m *AccessListSpec) GetOwnershipRequires() *AccessListRequires {
	if m != nil {
		return m.OwnershipRequires
	}
	return nil
}

func (m *AccessListSpec) GetGrants() *AccessListGrants {
	if m != nil {
		return m.Grants
	}
	return nil
}

func (m *AccessListSpec) GetMembers() []*AccessListMember {
	if m != nil {
		return m.Members
	}
	return nil
}

// AccessListOwner is an owner of an access list.
type AccessListOwner struct {
	// name is the username of the owner.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description is the plaintext description of the owner and why they are an owner.
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessListOwner) Reset()         { *m = AccessListOwner{} }
func (m *AccessListOwner) String() string { return proto.CompactTextString(m) }
func (*AccessListOwner) ProtoMessage()    {}
func (*AccessListOwner) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbe449dcb815a15c, []int{2}
}
func (m *AccessListOwner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessListOwner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessListOwner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessListOwner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessListOwner.Merge(m, src)
}
func (m *AccessListOwner) XXX_Size() int {
	return m.Size()
}
func (m *AccessListOwner) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessListOwner.DiscardUnknown(m)
}

var xxx_messageInfo_AccessListOwner proto.InternalMessageInfo

func (m *AccessListOwner) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AccessListOwner) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// AccessListAudit describes the audit configuration for an access list.
type AccessListAudit struct {
	// frequency is a duration that describes how often an access list must be audited.
	Frequency            *types.Duration `protobuf:"bytes,1,opt,name=frequency,proto3" json:"frequency,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AccessListAudit) Reset()         { *m = AccessListAudit{} }
func (m *AccessListAudit) String() string { return proto.CompactTextString(m) }
func (*AccessListAudit) ProtoMessage()    {}
func (*AccessListAudit) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbe449dcb815a15c, []int{3}
}
func (m *AccessListAudit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessListAudit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessListAudit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessListAudit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessListAudit.Merge(m, src)
}
func (m *AccessListAudit) XXX_Size() int {
	return m.Size()
}
func (m *AccessListAudit) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessListAudit.DiscardUnknown(m)
}

var xxx_messageInfo_AccessListAudit proto.InternalMessageInfo

func (m *AccessListAudit) GetFrequency() *types.Duration {
	if m != nil {
		return m.Frequency
	}
	return nil
}

// AccessListRequires describes a requirement section for an access list. A user must
// meet the following criteria to obtain the specific access to the list.
type AccessListRequires struct {
	// roles are the user roles that must be present for the user to obtain access.
	Roles []string `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
	// traits are the traits that must be present for the user to obtain access.
	Traits               []*v11.Trait `protobuf:"bytes,2,rep,name=traits,proto3" json:"traits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AccessListRequires) Reset()         { *m = AccessListRequires{} }
func (m *AccessListRequires) String() string { return proto.CompactTextString(m) }
func (*AccessListRequires) ProtoMessage()    {}
func (*AccessListRequires) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbe449dcb815a15c, []int{4}
}
func (m *AccessListRequires) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessListRequires) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessListRequires.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessListRequires) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessListRequires.Merge(m, src)
}
func (m *AccessListRequires) XXX_Size() int {
	return m.Size()
}
func (m *AccessListRequires) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessListRequires.DiscardUnknown(m)
}

var xxx_messageInfo_AccessListRequires proto.InternalMessageInfo

func (m *AccessListRequires) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *AccessListRequires) GetTraits() []*v11.Trait {
	if m != nil {
		return m.Traits
	}
	return nil
}

// AccessListGrants describes what access is granted by membership to the access list.
type AccessListGrants struct {
	// roles are the roles that are granted to users who are members of the access list.
	Roles []string `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
	// traits are the traits that are granted to users who are members of the access list.
	Traits               []*v11.Trait `protobuf:"bytes,2,rep,name=traits,proto3" json:"traits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AccessListGrants) Reset()         { *m = AccessListGrants{} }
func (m *AccessListGrants) String() string { return proto.CompactTextString(m) }
func (*AccessListGrants) ProtoMessage()    {}
func (*AccessListGrants) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbe449dcb815a15c, []int{5}
}
func (m *AccessListGrants) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessListGrants) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessListGrants.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessListGrants) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessListGrants.Merge(m, src)
}
func (m *AccessListGrants) XXX_Size() int {
	return m.Size()
}
func (m *AccessListGrants) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessListGrants.DiscardUnknown(m)
}

var xxx_messageInfo_AccessListGrants proto.InternalMessageInfo

func (m *AccessListGrants) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *AccessListGrants) GetTraits() []*v11.Trait {
	if m != nil {
		return m.Traits
	}
	return nil
}

// AccessListMember describes a member of an access list.
type AccessListMember struct {
	// name is the name of the member of the access list.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// joined is when the user joined the access list.
	Joined *types.Timestamp `protobuf:"bytes,2,opt,name=joined,proto3" json:"joined,omitempty"`
	// expires is when the user's membership to the access list expires.
	Expires *types.Timestamp `protobuf:"bytes,3,opt,name=expires,proto3" json:"expires,omitempty"`
	// reason is the reason this user was added to the access list.
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// added_by is the user that added this user to the access list.
	AddedBy              string   `protobuf:"bytes,5,opt,name=added_by,json=addedBy,proto3" json:"added_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessListMember) Reset()         { *m = AccessListMember{} }
func (m *AccessListMember) String() string { return proto.CompactTextString(m) }
func (*AccessListMember) ProtoMessage()    {}
func (*AccessListMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbe449dcb815a15c, []int{6}
}
func (m *AccessListMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessListMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessListMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessListMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessListMember.Merge(m, src)
}
func (m *AccessListMember) XXX_Size() int {
	return m.Size()
}
func (m *AccessListMember) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessListMember.DiscardUnknown(m)
}

var xxx_messageInfo_AccessListMember proto.InternalMessageInfo

func (m *AccessListMember) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AccessListMember) GetJoined() *types.Timestamp {
	if m != nil {
		return m.Joined
	}
	return nil
}

func (m *AccessListMember) GetExpires() *types.Timestamp {
	if m != nil {
		return m.Expires
	}
	return nil
}

func (m *AccessListMember) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *AccessListMember) GetAddedBy() string {
	if m != nil {
		return m.AddedBy
	}
	return ""
}

func init() {
	proto.RegisterType((*AccessList)(nil), "teleport.accesslist.v1.AccessList")
	proto.RegisterType((*AccessListSpec)(nil), "teleport.accesslist.v1.AccessListSpec")
	proto.RegisterType((*AccessListOwner)(nil), "teleport.accesslist.v1.AccessListOwner")
	proto.RegisterType((*AccessListAudit)(nil), "teleport.accesslist.v1.AccessListAudit")
	proto.RegisterType((*AccessListRequires)(nil), "teleport.accesslist.v1.AccessListRequires")
	proto.RegisterType((*AccessListGrants)(nil), "teleport.accesslist.v1.AccessListGrants")
	proto.RegisterType((*AccessListMember)(nil), "teleport.accesslist.v1.AccessListMember")
}

func init() {
	proto.RegisterFile("teleport/accesslist/v1/accesslist.proto", fileDescriptor_cbe449dcb815a15c)
}

var fileDescriptor_cbe449dcb815a15c = []byte{
	// 604 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xd1, 0x6a, 0xd4, 0x4c,
	0x14, 0x26, 0xdd, 0x36, 0xfb, 0xef, 0x29, 0xfc, 0xea, 0x28, 0x25, 0x2d, 0xb8, 0x2e, 0xb9, 0xb0,
	0x8b, 0x17, 0x89, 0x5b, 0x05, 0xa1, 0x22, 0xda, 0x22, 0x54, 0x44, 0x11, 0xc6, 0x22, 0x58, 0x85,
	0x32, 0x9b, 0x9c, 0xa6, 0x23, 0x9b, 0x4c, 0x9c, 0x99, 0x44, 0x7b, 0xef, 0x9b, 0x79, 0xe3, 0xa5,
	0x8f, 0x20, 0x7d, 0x02, 0x1f, 0x41, 0x32, 0x99, 0x6c, 0xb6, 0xdb, 0x85, 0xad, 0xe0, 0xdd, 0x9c,
	0x99, 0xef, 0xfb, 0xe6, 0xcc, 0x37, 0xe7, 0x1c, 0xd8, 0xd6, 0x38, 0xc1, 0x5c, 0x48, 0x1d, 0xb2,
	0x28, 0x42, 0xa5, 0x26, 0x5c, 0xe9, 0xb0, 0x1c, 0xcd, 0x44, 0x41, 0x2e, 0x85, 0x16, 0x64, 0xa3,
	0x01, 0x06, 0x33, 0x47, 0xe5, 0x68, 0xab, 0x9f, 0x08, 0x91, 0x4c, 0x30, 0x34, 0xa8, 0x71, 0x71,
	0x12, 0xc6, 0x85, 0x64, 0x9a, 0x8b, 0xac, 0xe6, 0x6d, 0xdd, 0x99, 0x3f, 0xd7, 0x3c, 0x45, 0xa5,
	0x59, 0x9a, 0x5b, 0x40, 0x9b, 0xc1, 0x29, 0xb2, 0x18, 0x65, 0x75, 0xbb, 0x44, 0x25, 0x0a, 0x19,
	0x61, 0xbd, 0x63, 0x81, 0xb7, 0xa7, 0x40, 0x2d, 0x19, 0x37, 0x59, 0x9a, 0x45, 0x7d, 0xec, 0x7f,
	0x73, 0x00, 0xf6, 0x4c, 0x6a, 0xaf, 0xb8, 0xd2, 0x64, 0x17, 0xdc, 0x9a, 0xed, 0x39, 0x03, 0x67,
	0xb8, 0xbe, 0xe3, 0x07, 0xd3, 0x07, 0x58, 0xd5, 0x72, 0x14, 0x50, 0x7b, 0xcf, 0x0b, 0xb3, 0x43,
	0x2d, 0x83, 0xec, 0xc2, 0xaa, 0xca, 0x31, 0xf2, 0x56, 0x0c, 0xf3, 0x6e, 0xb0, 0xf8, 0xe9, 0x41,
	0x7b, 0xdb, 0xdb, 0x1c, 0x23, 0x6a, 0x38, 0xfe, 0xef, 0x0e, 0xfc, 0x7f, 0xf1, 0x80, 0x0c, 0x60,
	0x3d, 0x46, 0x15, 0x49, 0x9e, 0x57, 0xbe, 0x98, 0x7c, 0x7a, 0x74, 0x76, 0x8b, 0x3c, 0x05, 0x57,
	0x7c, 0xc9, 0x50, 0x2a, 0x6f, 0x65, 0xd0, 0x19, 0xae, 0xef, 0x6c, 0x2f, 0xbf, 0xf2, 0x4d, 0x85,
	0xa7, 0x96, 0x46, 0x9e, 0xc0, 0x1a, 0x2b, 0x62, 0xae, 0xbd, 0x8e, 0x49, 0xf9, 0x0a, 0xfc, 0xbd,
	0x0a, 0x4e, 0x6b, 0x16, 0xf9, 0x00, 0x37, 0x53, 0x4c, 0xc7, 0x28, 0xd5, 0x29, 0xcf, 0x8f, 0x25,
	0x7e, 0x2e, 0xb8, 0x44, 0xe5, 0xad, 0x1a, 0xb1, 0x7b, 0xcb, 0xc5, 0xa8, 0x65, 0x50, 0xd2, 0xca,
	0x34, 0x7b, 0xe4, 0x3d, 0x90, 0x3a, 0xcb, 0x0b, 0xda, 0x6b, 0x7f, 0xad, 0x7d, 0x63, 0xaa, 0x32,
	0x95, 0x7e, 0x06, 0x6e, 0x22, 0x59, 0xa6, 0x95, 0xe7, 0x1a, 0xb9, 0xe1, 0x72, 0xb9, 0x03, 0x83,
	0xa7, 0x96, 0x47, 0xf6, 0xa1, 0x6b, 0x53, 0xf6, 0xba, 0xc6, 0xfa, 0x2b, 0x48, 0xbc, 0x36, 0x04,
	0xda, 0x10, 0xfd, 0x03, 0xb8, 0x36, 0xf7, 0x2f, 0x84, 0xc0, 0x6a, 0xc6, 0x52, 0xb4, 0x7f, 0x6d,
	0xd6, 0xf3, 0x65, 0xb0, 0x72, 0xa9, 0x0c, 0xfc, 0x97, 0xb3, 0x42, 0xe6, 0x83, 0xc8, 0x23, 0xe8,
	0x9d, 0x54, 0x9e, 0x61, 0x16, 0x9d, 0xd9, 0x4a, 0xde, 0x0c, 0xea, 0x96, 0x0a, 0x9a, 0x96, 0x0a,
	0x9e, 0xdb, 0x96, 0xa3, 0x2d, 0xd6, 0xff, 0x08, 0xe4, 0xb2, 0x87, 0xe4, 0x16, 0xac, 0x49, 0x31,
	0x41, 0xe5, 0x39, 0x83, 0xce, 0xb0, 0x47, 0xeb, 0x80, 0xdc, 0x07, 0xd7, 0x74, 0x52, 0x53, 0x7e,
	0x5e, 0xeb, 0x41, 0xdd, 0x61, 0xe5, 0x28, 0x38, 0xac, 0x16, 0xd4, 0xe2, 0xfc, 0x23, 0xb8, 0x3e,
	0x6f, 0xe9, 0x3f, 0xd3, 0xfe, 0xee, 0xcc, 0x8a, 0xd7, 0x66, 0x2f, 0x34, 0x74, 0x07, 0xdc, 0x4f,
	0x82, 0x67, 0x18, 0xdb, 0x46, 0xdd, 0xba, 0x64, 0xcc, 0x61, 0x33, 0x6b, 0xa8, 0x45, 0x92, 0x87,
	0xd0, 0xc5, 0xaf, 0xb9, 0xa9, 0xc0, 0xce, 0x52, 0x52, 0x03, 0x25, 0x1b, 0xe0, 0x4a, 0x64, 0x4a,
	0x64, 0xa6, 0x25, 0x7a, 0xd4, 0x46, 0x64, 0x13, 0xfe, 0x63, 0x71, 0x8c, 0xf1, 0xf1, 0xf8, 0xcc,
	0x14, 0x74, 0x8f, 0x76, 0x4d, 0xbc, 0x7f, 0xb6, 0x1f, 0xff, 0x38, 0xef, 0x3b, 0x3f, 0xcf, 0xfb,
	0xce, 0xaf, 0xf3, 0xbe, 0x73, 0xf4, 0x2e, 0xe1, 0xfa, 0xb4, 0x18, 0x07, 0x91, 0x48, 0xc3, 0x44,
	0xb2, 0x92, 0x6b, 0xf3, 0x61, 0x6c, 0x12, 0xb6, 0xf3, 0x37, 0xe7, 0x61, 0x82, 0x59, 0x3d, 0x28,
	0xc3, 0x44, 0x84, 0x8b, 0x27, 0xf3, 0xe3, 0x36, 0x2a, 0x47, 0x63, 0xd7, 0xa0, 0x1f, 0xfc, 0x09,
	0x00, 0x00, 0xff, 0xff, 0x78, 0x5a, 0x15, 0xe8, 0xc7, 0x05, 0x00, 0x00,
}

func (m *AccessList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccesslist(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccesslist(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessListSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessListSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessListSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccesslist(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Grants != nil {
		{
			size, err := m.Grants.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccesslist(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.OwnershipRequires != nil {
		{
			size, err := m.OwnershipRequires.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccesslist(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MembershipRequires != nil {
		{
			size, err := m.MembershipRequires.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccesslist(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Audit != nil {
		{
			size, err := m.Audit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccesslist(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owners) > 0 {
		for iNdEx := len(m.Owners) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Owners[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccesslist(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAccesslist(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessListOwner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessListOwner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessListOwner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAccesslist(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAccesslist(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessListAudit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessListAudit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessListAudit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Frequency != nil {
		{
			size, err := m.Frequency.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccesslist(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessListRequires) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessListRequires) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessListRequires) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Traits) > 0 {
		for iNdEx := len(m.Traits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Traits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccesslist(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintAccesslist(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccessListGrants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessListGrants) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessListGrants) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Traits) > 0 {
		for iNdEx := len(m.Traits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Traits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAccesslist(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintAccesslist(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccessListMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessListMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessListMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AddedBy) > 0 {
		i -= len(m.AddedBy)
		copy(dAtA[i:], m.AddedBy)
		i = encodeVarintAccesslist(dAtA, i, uint64(len(m.AddedBy)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintAccesslist(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if m.Expires != nil {
		{
			size, err := m.Expires.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccesslist(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Joined != nil {
		{
			size, err := m.Joined.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAccesslist(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAccesslist(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAccesslist(dAtA []byte, offset int, v uint64) int {
	offset -= sovAccesslist(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AccessList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessListSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if len(m.Owners) > 0 {
		for _, e := range m.Owners {
			l = e.Size()
			n += 1 + l + sovAccesslist(uint64(l))
		}
	}
	if m.Audit != nil {
		l = m.Audit.Size()
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if m.MembershipRequires != nil {
		l = m.MembershipRequires.Size()
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if m.OwnershipRequires != nil {
		l = m.OwnershipRequires.Size()
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if m.Grants != nil {
		l = m.Grants.Size()
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovAccesslist(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessListOwner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAccesslist(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessListAudit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Frequency != nil {
		l = m.Frequency.Size()
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessListRequires) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAccesslist(uint64(l))
		}
	}
	if len(m.Traits) > 0 {
		for _, e := range m.Traits {
			l = e.Size()
			n += 1 + l + sovAccesslist(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessListGrants) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAccesslist(uint64(l))
		}
	}
	if len(m.Traits) > 0 {
		for _, e := range m.Traits {
			l = e.Size()
			n += 1 + l + sovAccesslist(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessListMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if m.Joined != nil {
		l = m.Joined.Size()
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if m.Expires != nil {
		l = m.Expires.Size()
		n += 1 + l + sovAccesslist(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAccesslist(uint64(l))
	}
	l = len(m.AddedBy)
	if l > 0 {
		n += 1 + l + sovAccesslist(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAccesslist(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAccesslist(x uint64) (n int) {
	return sovAccesslist(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AccessList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslist
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &v1.ResourceHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &AccessListSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslist(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccesslist
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessListSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslist
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessListSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessListSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owners", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owners = append(m.Owners, &AccessListOwner{})
			if err := m.Owners[len(m.Owners)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Audit == nil {
				m.Audit = &AccessListAudit{}
			}
			if err := m.Audit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MembershipRequires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MembershipRequires == nil {
				m.MembershipRequires = &AccessListRequires{}
			}
			if err := m.MembershipRequires.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnershipRequires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnershipRequires == nil {
				m.OwnershipRequires = &AccessListRequires{}
			}
			if err := m.OwnershipRequires.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Grants == nil {
				m.Grants = &AccessListGrants{}
			}
			if err := m.Grants.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &AccessListMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslist(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccesslist
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessListOwner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslist
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessListOwner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessListOwner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslist(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccesslist
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessListAudit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslist
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessListAudit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessListAudit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Frequency == nil {
				m.Frequency = &types.Duration{}
			}
			if err := m.Frequency.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslist(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccesslist
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessListRequires) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslist
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessListRequires: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessListRequires: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traits = append(m.Traits, &v11.Trait{})
			if err := m.Traits[len(m.Traits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslist(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccesslist
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessListGrants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslist
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessListGrants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessListGrants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traits = append(m.Traits, &v11.Trait{})
			if err := m.Traits[len(m.Traits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslist(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccesslist
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessListMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccesslist
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessListMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessListMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Joined", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Joined == nil {
				m.Joined = &types.Timestamp{}
			}
			if err := m.Joined.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expires == nil {
				m.Expires = &types.Timestamp{}
			}
			if err := m.Expires.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccesslist
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccesslist
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccesslist(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAccesslist
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccesslist(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccesslist
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccesslist
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAccesslist
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAccesslist
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAccesslist
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAccesslist        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccesslist          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAccesslist = fmt.Errorf("proto: unexpected end of group")
)
