// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: teleport/kube/v1/kube_service.proto

package v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gravitational/teleport/api/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ListKubernetesResourcesRequest defines a request to retrieve resources paginated. Only
// one type of resource can be retrieved per request.
type ListKubernetesResourcesRequest struct {
	// ResourceType is the Kubernetes resource that is going to be retrieved.
	ResourceType string `protobuf:"bytes,1,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
	// Limit is the maximum amount of resources to retrieve.
	Limit int32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	// StartKey is used to start listing resources from a specific spot. It
	// should be set to the previous NextKey value if using pagination, or
	// left empty.
	StartKey string `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// Labels is a label-based matcher if non-empty.
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// PredicateExpression defines boolean conditions that will be matched against the resource.
	PredicateExpression string `protobuf:"bytes,5,opt,name=predicate_expression,json=predicateExpression,proto3" json:"predicate_expression,omitempty"`
	// SearchKeywords is a list of search keywords to match against resource field values.
	SearchKeywords []string `protobuf:"bytes,6,rep,name=search_keywords,json=searchKeywords,proto3" json:"search_keywords,omitempty"`
	// SortBy describes which resource field and which direction to sort by.
	SortBy *types.SortBy `protobuf:"bytes,7,opt,name=sort_by,json=sortBy,proto3" json:"sort_by,omitempty"`
	// NeedTotalCount indicates whether or not the caller also wants the total number of resources
	// after filtering.
	NeedTotalCount bool `protobuf:"varint,8,opt,name=need_total_count,json=needTotalCount,proto3" json:"need_total_count,omitempty"`
	// UseSearchAsRoles indicates that the response should include all resources
	// the caller is able to request access to using search_as_roles
	UseSearchAsRoles bool `protobuf:"varint,9,opt,name=use_search_as_roles,json=useSearchAsRoles,proto3" json:"use_search_as_roles,omitempty"`
	// UsePreviewAsRoles indicates that the response should include all resources
	// the caller would be able to access with their preview_as_roles
	UsePreviewAsRoles bool `protobuf:"varint,11,opt,name=use_preview_as_roles,json=usePreviewAsRoles,proto3" json:"use_preview_as_roles,omitempty"`
	// TeleportCluster is the Teleport Cluster name to route the request to.
	TeleportCluster string `protobuf:"bytes,12,opt,name=teleport_cluster,json=teleportCluster,proto3" json:"teleport_cluster,omitempty"`
	// Cluster is the Kubernetes Cluster to request the resources.
	KubernetesCluster string `protobuf:"bytes,13,opt,name=kubernetes_cluster,json=kubernetesCluster,proto3" json:"kubernetes_cluster,omitempty"`
	// Namespace is the Kubernetes namespace where the resources must be located.
	// To search on every Kubernetes Namespace, do not define the value.
	KubernetesNamespace  string   `protobuf:"bytes,14,opt,name=kubernetes_namespace,json=kubernetesNamespace,proto3" json:"kubernetes_namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListKubernetesResourcesRequest) Reset()         { *m = ListKubernetesResourcesRequest{} }
func (m *ListKubernetesResourcesRequest) String() string { return proto.CompactTextString(m) }
func (*ListKubernetesResourcesRequest) ProtoMessage()    {}
func (*ListKubernetesResourcesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_771e82fdb8b62186, []int{0}
}
func (m *ListKubernetesResourcesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKubernetesResourcesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListKubernetesResourcesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListKubernetesResourcesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKubernetesResourcesRequest.Merge(m, src)
}
func (m *ListKubernetesResourcesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListKubernetesResourcesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKubernetesResourcesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListKubernetesResourcesRequest proto.InternalMessageInfo

func (m *ListKubernetesResourcesRequest) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *ListKubernetesResourcesRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListKubernetesResourcesRequest) GetStartKey() string {
	if m != nil {
		return m.StartKey
	}
	return ""
}

func (m *ListKubernetesResourcesRequest) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ListKubernetesResourcesRequest) GetPredicateExpression() string {
	if m != nil {
		return m.PredicateExpression
	}
	return ""
}

func (m *ListKubernetesResourcesRequest) GetSearchKeywords() []string {
	if m != nil {
		return m.SearchKeywords
	}
	return nil
}

func (m *ListKubernetesResourcesRequest) GetSortBy() *types.SortBy {
	if m != nil {
		return m.SortBy
	}
	return nil
}

func (m *ListKubernetesResourcesRequest) GetNeedTotalCount() bool {
	if m != nil {
		return m.NeedTotalCount
	}
	return false
}

func (m *ListKubernetesResourcesRequest) GetUseSearchAsRoles() bool {
	if m != nil {
		return m.UseSearchAsRoles
	}
	return false
}

func (m *ListKubernetesResourcesRequest) GetUsePreviewAsRoles() bool {
	if m != nil {
		return m.UsePreviewAsRoles
	}
	return false
}

func (m *ListKubernetesResourcesRequest) GetTeleportCluster() string {
	if m != nil {
		return m.TeleportCluster
	}
	return ""
}

func (m *ListKubernetesResourcesRequest) GetKubernetesCluster() string {
	if m != nil {
		return m.KubernetesCluster
	}
	return ""
}

func (m *ListKubernetesResourcesRequest) GetKubernetesNamespace() string {
	if m != nil {
		return m.KubernetesNamespace
	}
	return ""
}

// ListKubernetesResourcesResponse is the response of ListKubernetesResources method.
type ListKubernetesResourcesResponse struct {
	// Resources is a list of resource.
	Resources []*types.KubernetesResourceV1 `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty"`
	// NextKey is the next Key to use as StartKey in a ListResourcesRequest to
	// continue retrieving pages of resource. If NextKey is empty, there are no
	// more pages.
	NextKey string `protobuf:"bytes,2,opt,name=next_key,json=nextKey,proto3" json:"next_key,omitempty"`
	// TotalCount is the total number of resources available after filter, if any.
	TotalCount           int32    `protobuf:"varint,3,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListKubernetesResourcesResponse) Reset()         { *m = ListKubernetesResourcesResponse{} }
func (m *ListKubernetesResourcesResponse) String() string { return proto.CompactTextString(m) }
func (*ListKubernetesResourcesResponse) ProtoMessage()    {}
func (*ListKubernetesResourcesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_771e82fdb8b62186, []int{1}
}
func (m *ListKubernetesResourcesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKubernetesResourcesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListKubernetesResourcesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListKubernetesResourcesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKubernetesResourcesResponse.Merge(m, src)
}
func (m *ListKubernetesResourcesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListKubernetesResourcesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKubernetesResourcesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListKubernetesResourcesResponse proto.InternalMessageInfo

func (m *ListKubernetesResourcesResponse) GetResources() []*types.KubernetesResourceV1 {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ListKubernetesResourcesResponse) GetNextKey() string {
	if m != nil {
		return m.NextKey
	}
	return ""
}

func (m *ListKubernetesResourcesResponse) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func init() {
	proto.RegisterType((*ListKubernetesResourcesRequest)(nil), "teleport.kube.v1.ListKubernetesResourcesRequest")
	proto.RegisterMapType((map[string]string)(nil), "teleport.kube.v1.ListKubernetesResourcesRequest.LabelsEntry")
	proto.RegisterType((*ListKubernetesResourcesResponse)(nil), "teleport.kube.v1.ListKubernetesResourcesResponse")
}

func init() {
	proto.RegisterFile("teleport/kube/v1/kube_service.proto", fileDescriptor_771e82fdb8b62186)
}

var fileDescriptor_771e82fdb8b62186 = []byte{
	// 613 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcb, 0x4e, 0xdb, 0x4c,
	0x14, 0x96, 0xc9, 0x9f, 0x90, 0x9c, 0x70, 0x09, 0x43, 0xa4, 0xdf, 0x05, 0x29, 0xa4, 0x20, 0xb5,
	0xee, 0x02, 0xbb, 0xa1, 0x9b, 0x52, 0x75, 0x53, 0x10, 0x2b, 0x50, 0xd5, 0x1a, 0xd4, 0x45, 0x37,
	0xd6, 0xc4, 0x1c, 0x05, 0x0b, 0xe3, 0x71, 0xe7, 0x8c, 0x03, 0xde, 0xf4, 0x0d, 0xba, 0xef, 0x03,
	0xf4, 0x61, 0xba, 0xec, 0x23, 0x54, 0x3c, 0x49, 0x35, 0x33, 0xb1, 0x83, 0xa8, 0xa8, 0xc4, 0x26,
	0x33, 0xf3, 0x5d, 0x66, 0x26, 0xe7, 0x7c, 0x1e, 0xd8, 0x51, 0x98, 0x62, 0x2e, 0xa4, 0x0a, 0x2e,
	0x8b, 0x31, 0x06, 0xd3, 0x91, 0x19, 0x23, 0x42, 0x39, 0x4d, 0x62, 0xf4, 0x73, 0x29, 0x94, 0x60,
	0xbd, 0x4a, 0xe4, 0x6b, 0xd2, 0x9f, 0x8e, 0x36, 0x9e, 0xd6, 0xb6, 0x14, 0x27, 0x3c, 0x2e, 0x03,
	0x55, 0xe6, 0x48, 0xf6, 0xd7, 0x9a, 0xb6, 0x7f, 0x34, 0x61, 0x70, 0x92, 0x90, 0x3a, 0x2e, 0xc6,
	0x28, 0x33, 0x54, 0x48, 0x21, 0x92, 0x28, 0x64, 0xac, 0x27, 0x5f, 0x0a, 0x24, 0xc5, 0x76, 0x60,
	0x59, 0xce, 0xb0, 0x48, 0x5b, 0x5d, 0x67, 0xe8, 0x78, 0x9d, 0x70, 0xa9, 0x02, 0xcf, 0xca, 0x1c,
	0x59, 0x1f, 0x9a, 0x69, 0x72, 0x95, 0x28, 0x77, 0x61, 0xe8, 0x78, 0xcd, 0xd0, 0x2e, 0xd8, 0x26,
	0x74, 0x48, 0x71, 0xa9, 0xa2, 0x4b, 0x2c, 0xdd, 0x86, 0xb1, 0xb5, 0x0d, 0x70, 0x8c, 0x25, 0x3b,
	0x83, 0x56, 0xca, 0xc7, 0x98, 0x92, 0xfb, 0xdf, 0xb0, 0xe1, 0x75, 0xf7, 0xde, 0xfa, 0xf7, 0xff,
	0x80, 0xff, 0xef, 0x9b, 0xf9, 0x27, 0xc6, 0x7e, 0x94, 0x29, 0x59, 0x86, 0xb3, 0xbd, 0xd8, 0x08,
	0xfa, 0xb9, 0xc4, 0xf3, 0x24, 0xe6, 0x0a, 0x23, 0xbc, 0xc9, 0x25, 0x12, 0x25, 0x22, 0x73, 0x9b,
	0xe6, 0xf4, 0xf5, 0x9a, 0x3b, 0xaa, 0x29, 0xf6, 0x1c, 0x56, 0x09, 0xb9, 0x8c, 0x2f, 0xf4, 0x35,
	0xaf, 0x85, 0x3c, 0x27, 0xb7, 0x35, 0x6c, 0x78, 0x9d, 0x70, 0xc5, 0xc2, 0xc7, 0x33, 0x94, 0x3d,
	0x83, 0x45, 0x12, 0x52, 0x45, 0xe3, 0xd2, 0x5d, 0x1c, 0x3a, 0x5e, 0x77, 0x6f, 0xd9, 0xb7, 0xb5,
	0x3c, 0x15, 0x52, 0x1d, 0x94, 0x61, 0x8b, 0xcc, 0xc8, 0x3c, 0xe8, 0x65, 0x88, 0xe7, 0x91, 0x12,
	0x8a, 0xa7, 0x51, 0x2c, 0x8a, 0x4c, 0xb9, 0xed, 0xa1, 0xe3, 0xb5, 0xc3, 0x15, 0x8d, 0x9f, 0x69,
	0xf8, 0x50, 0xa3, 0x6c, 0x17, 0xd6, 0x0b, 0xd2, 0x8d, 0x34, 0xc7, 0x73, 0x8a, 0xa4, 0x48, 0x91,
	0xdc, 0x8e, 0x11, 0xf7, 0x0a, 0xc2, 0x53, 0xc3, 0xbc, 0xa3, 0x50, 0xe3, 0x2c, 0x80, 0xbe, 0x96,
	0xe7, 0x12, 0xa7, 0x09, 0x5e, 0xcf, 0xf5, 0x5d, 0xa3, 0x5f, 0x2b, 0x08, 0x3f, 0x58, 0xaa, 0x32,
	0xbc, 0x80, 0x3a, 0x15, 0x51, 0x9c, 0x16, 0xa4, 0x50, 0xba, 0x4b, 0xa6, 0x12, 0xab, 0x15, 0x7e,
	0x68, 0x61, 0xb6, 0x0b, 0xec, 0xb2, 0x2e, 0x75, 0x2d, 0x5e, 0x36, 0xe2, 0xb5, 0x39, 0x53, 0xc9,
	0x47, 0xd0, 0xbf, 0x23, 0xcf, 0xf8, 0x15, 0x52, 0xce, 0x63, 0x74, 0x57, 0x6c, 0x9d, 0xe7, 0xdc,
	0xfb, 0x8a, 0xda, 0xd8, 0x87, 0xee, 0x9d, 0x8e, 0xb1, 0x1e, 0x34, 0x74, 0x2c, 0x6c, 0x9a, 0xf4,
	0x54, 0x87, 0x68, 0xca, 0xd3, 0x02, 0x4d, 0x88, 0x3a, 0xa1, 0x5d, 0xbc, 0x59, 0x78, 0xed, 0x6c,
	0x7f, 0x77, 0x60, 0xeb, 0xc1, 0x30, 0x50, 0x2e, 0x32, 0x42, 0xb6, 0x0f, 0x9d, 0x2a, 0x92, 0xe4,
	0x3a, 0x26, 0x52, 0x9b, 0xb3, 0xfe, 0xfc, 0x6d, 0xfb, 0x34, 0x0a, 0xe7, 0x6a, 0xf6, 0x04, 0xda,
	0x19, 0xde, 0xd8, 0x98, 0xda, 0xb3, 0x17, 0xf5, 0x5a, 0xa7, 0x74, 0x0b, 0xba, 0x77, 0xdb, 0xd8,
	0x30, 0xf1, 0x06, 0x55, 0xb7, 0x70, 0xef, 0x9b, 0x03, 0x5d, 0xbd, 0xff, 0xa9, 0xfd, 0x18, 0xd9,
	0x57, 0xf8, 0xff, 0x81, 0x9b, 0xb2, 0x97, 0x8f, 0x4d, 0xf8, 0xc6, 0xe8, 0x11, 0x0e, 0x5b, 0x86,
	0x83, 0x8f, 0x3f, 0x6f, 0x07, 0xce, 0xaf, 0xdb, 0x81, 0xf3, 0xfb, 0x76, 0xe0, 0x7c, 0x3e, 0x9c,
	0x24, 0xea, 0xa2, 0x18, 0xfb, 0xb1, 0xb8, 0x0a, 0x26, 0x92, 0x4f, 0x13, 0xc5, 0x55, 0x22, 0x32,
	0x9e, 0x06, 0xf5, 0xdb, 0xc0, 0xf3, 0x24, 0x98, 0x60, 0x16, 0x98, 0x07, 0x21, 0x98, 0x88, 0xe0,
	0xfe, 0x63, 0x33, 0x6e, 0x19, 0xea, 0xd5, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2d, 0x9a, 0x0b,
	0x9f, 0x87, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// KubeServiceClient is the client API for KubeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KubeServiceClient interface {
	// ListKubernetesResources lists the Kubernetes resources without leaking details.
	ListKubernetesResources(ctx context.Context, in *ListKubernetesResourcesRequest, opts ...grpc.CallOption) (*ListKubernetesResourcesResponse, error)
}

type kubeServiceClient struct {
	cc *grpc.ClientConn
}

func NewKubeServiceClient(cc *grpc.ClientConn) KubeServiceClient {
	return &kubeServiceClient{cc}
}

func (c *kubeServiceClient) ListKubernetesResources(ctx context.Context, in *ListKubernetesResourcesRequest, opts ...grpc.CallOption) (*ListKubernetesResourcesResponse, error) {
	out := new(ListKubernetesResourcesResponse)
	err := c.cc.Invoke(ctx, "/teleport.kube.v1.KubeService/ListKubernetesResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KubeServiceServer is the server API for KubeService service.
type KubeServiceServer interface {
	// ListKubernetesResources lists the Kubernetes resources without leaking details.
	ListKubernetesResources(context.Context, *ListKubernetesResourcesRequest) (*ListKubernetesResourcesResponse, error)
}

// UnimplementedKubeServiceServer can be embedded to have forward compatible implementations.
type UnimplementedKubeServiceServer struct {
}

func (*UnimplementedKubeServiceServer) ListKubernetesResources(ctx context.Context, req *ListKubernetesResourcesRequest) (*ListKubernetesResourcesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKubernetesResources not implemented")
}

func RegisterKubeServiceServer(s *grpc.Server, srv KubeServiceServer) {
	s.RegisterService(&_KubeService_serviceDesc, srv)
}

func _KubeService_ListKubernetesResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKubernetesResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeServiceServer).ListKubernetesResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/teleport.kube.v1.KubeService/ListKubernetesResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeServiceServer).ListKubernetesResources(ctx, req.(*ListKubernetesResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _KubeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "teleport.kube.v1.KubeService",
	HandlerType: (*KubeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListKubernetesResources",
			Handler:    _KubeService_ListKubernetesResources_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "teleport/kube/v1/kube_service.proto",
}

func (m *ListKubernetesResourcesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKubernetesResourcesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKubernetesResourcesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KubernetesNamespace) > 0 {
		i -= len(m.KubernetesNamespace)
		copy(dAtA[i:], m.KubernetesNamespace)
		i = encodeVarintKubeService(dAtA, i, uint64(len(m.KubernetesNamespace)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.KubernetesCluster) > 0 {
		i -= len(m.KubernetesCluster)
		copy(dAtA[i:], m.KubernetesCluster)
		i = encodeVarintKubeService(dAtA, i, uint64(len(m.KubernetesCluster)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.TeleportCluster) > 0 {
		i -= len(m.TeleportCluster)
		copy(dAtA[i:], m.TeleportCluster)
		i = encodeVarintKubeService(dAtA, i, uint64(len(m.TeleportCluster)))
		i--
		dAtA[i] = 0x62
	}
	if m.UsePreviewAsRoles {
		i--
		if m.UsePreviewAsRoles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.UseSearchAsRoles {
		i--
		if m.UseSearchAsRoles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.NeedTotalCount {
		i--
		if m.NeedTotalCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.SortBy != nil {
		{
			size, err := m.SortBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKubeService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SearchKeywords) > 0 {
		for iNdEx := len(m.SearchKeywords) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchKeywords[iNdEx])
			copy(dAtA[i:], m.SearchKeywords[iNdEx])
			i = encodeVarintKubeService(dAtA, i, uint64(len(m.SearchKeywords[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PredicateExpression) > 0 {
		i -= len(m.PredicateExpression)
		copy(dAtA[i:], m.PredicateExpression)
		i = encodeVarintKubeService(dAtA, i, uint64(len(m.PredicateExpression)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintKubeService(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintKubeService(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintKubeService(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintKubeService(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Limit != 0 {
		i = encodeVarintKubeService(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintKubeService(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListKubernetesResourcesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKubernetesResourcesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKubernetesResourcesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalCount != 0 {
		i = encodeVarintKubeService(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.NextKey) > 0 {
		i -= len(m.NextKey)
		copy(dAtA[i:], m.NextKey)
		i = encodeVarintKubeService(dAtA, i, uint64(len(m.NextKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintKubeService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintKubeService(dAtA []byte, offset int, v uint64) int {
	offset -= sovKubeService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ListKubernetesResourcesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovKubeService(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovKubeService(uint64(m.Limit))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKubeService(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubeService(uint64(len(k))) + 1 + len(v) + sovKubeService(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubeService(uint64(mapEntrySize))
		}
	}
	l = len(m.PredicateExpression)
	if l > 0 {
		n += 1 + l + sovKubeService(uint64(l))
	}
	if len(m.SearchKeywords) > 0 {
		for _, s := range m.SearchKeywords {
			l = len(s)
			n += 1 + l + sovKubeService(uint64(l))
		}
	}
	if m.SortBy != nil {
		l = m.SortBy.Size()
		n += 1 + l + sovKubeService(uint64(l))
	}
	if m.NeedTotalCount {
		n += 2
	}
	if m.UseSearchAsRoles {
		n += 2
	}
	if m.UsePreviewAsRoles {
		n += 2
	}
	l = len(m.TeleportCluster)
	if l > 0 {
		n += 1 + l + sovKubeService(uint64(l))
	}
	l = len(m.KubernetesCluster)
	if l > 0 {
		n += 1 + l + sovKubeService(uint64(l))
	}
	l = len(m.KubernetesNamespace)
	if l > 0 {
		n += 1 + l + sovKubeService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListKubernetesResourcesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.Size()
			n += 1 + l + sovKubeService(uint64(l))
		}
	}
	l = len(m.NextKey)
	if l > 0 {
		n += 1 + l + sovKubeService(uint64(l))
	}
	if m.TotalCount != 0 {
		n += 1 + sovKubeService(uint64(m.TotalCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovKubeService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozKubeService(x uint64) (n int) {
	return sovKubeService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ListKubernetesResourcesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubeService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKubernetesResourcesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKubernetesResourcesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubeService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubeService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubeService
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthKubeService
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubeService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubeService
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthKubeService
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubeService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthKubeService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchKeywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchKeywords = append(m.SearchKeywords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SortBy == nil {
				m.SortBy = &types.SortBy{}
			}
			if err := m.SortBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedTotalCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedTotalCount = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSearchAsRoles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSearchAsRoles = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePreviewAsRoles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePreviewAsRoles = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeleportCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeleportCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubeService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKubeService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListKubernetesResourcesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubeService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKubernetesResourcesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKubernetesResourcesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &types.KubernetesResourceV1{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubeService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKubeService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubeService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKubeService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKubeService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKubeService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKubeService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthKubeService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupKubeService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthKubeService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthKubeService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKubeService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupKubeService = fmt.Errorf("proto: unexpected end of group")
)
