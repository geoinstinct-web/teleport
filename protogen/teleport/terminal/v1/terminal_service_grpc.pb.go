// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TerminalServiceClient is the client API for TerminalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TerminalServiceClient interface {
	// POST /clusters
	CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*Cluster, error)
	// GET /clusters
	ListClusters(ctx context.Context, in *ListClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error)
	// TODO(codingllama): Names may change!
	// POST /clusters/{cluster_id}/loginChallenges
	CreateClusterLoginChallenge(ctx context.Context, in *CreateClusterLoginChallengeRequest, opts ...grpc.CallOption) (*ClusterLoginChallenge, error)
	// POST /clusters/{cluster_id}/loginChallenges/{challenge_id}:solve
	SolveClusterLoginChallenge(ctx context.Context, in *SolveClusterLoginChallengeRequest, opts ...grpc.CallOption) (*SolveClusterLoginChallengeResponse, error)
	// GET /databases
	// Requires login challenge to be solved beforehand.
	ListDatabases(ctx context.Context, in *ListDatabasesRequest, opts ...grpc.CallOption) (*ListDatabasesResponse, error)
	// POST /gateways
	CreateGateway(ctx context.Context, in *CreateGatewayRequest, opts ...grpc.CallOption) (*Gateway, error)
	// GET /gateways
	ListGateways(ctx context.Context, in *ListGatewaysRequest, opts ...grpc.CallOption) (*ListGatewaysResponse, error)
	// DELETE /gateways/{id}
	DeleteGateway(ctx context.Context, in *DeleteGatewayRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Streams input/output using a gateway.
	// Requires the gateway to be created beforehand.
	// This has no REST counterpart.
	StreamGateway(ctx context.Context, opts ...grpc.CallOption) (TerminalService_StreamGatewayClient, error)
	// GET /nodes
	// Per Teleport nomenclature, a Node is an SSH-capable node.
	// Requires login challenge to be solved beforehand.
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error)
}

type terminalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTerminalServiceClient(cc grpc.ClientConnInterface) TerminalServiceClient {
	return &terminalServiceClient{cc}
}

func (c *terminalServiceClient) CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*Cluster, error) {
	out := new(Cluster)
	err := c.cc.Invoke(ctx, "/teleport.terminal.v1.TerminalService/CreateCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ListClusters(ctx context.Context, in *ListClustersRequest, opts ...grpc.CallOption) (*ListClustersResponse, error) {
	out := new(ListClustersResponse)
	err := c.cc.Invoke(ctx, "/teleport.terminal.v1.TerminalService/ListClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) CreateClusterLoginChallenge(ctx context.Context, in *CreateClusterLoginChallengeRequest, opts ...grpc.CallOption) (*ClusterLoginChallenge, error) {
	out := new(ClusterLoginChallenge)
	err := c.cc.Invoke(ctx, "/teleport.terminal.v1.TerminalService/CreateClusterLoginChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) SolveClusterLoginChallenge(ctx context.Context, in *SolveClusterLoginChallengeRequest, opts ...grpc.CallOption) (*SolveClusterLoginChallengeResponse, error) {
	out := new(SolveClusterLoginChallengeResponse)
	err := c.cc.Invoke(ctx, "/teleport.terminal.v1.TerminalService/SolveClusterLoginChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ListDatabases(ctx context.Context, in *ListDatabasesRequest, opts ...grpc.CallOption) (*ListDatabasesResponse, error) {
	out := new(ListDatabasesResponse)
	err := c.cc.Invoke(ctx, "/teleport.terminal.v1.TerminalService/ListDatabases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) CreateGateway(ctx context.Context, in *CreateGatewayRequest, opts ...grpc.CallOption) (*Gateway, error) {
	out := new(Gateway)
	err := c.cc.Invoke(ctx, "/teleport.terminal.v1.TerminalService/CreateGateway", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) ListGateways(ctx context.Context, in *ListGatewaysRequest, opts ...grpc.CallOption) (*ListGatewaysResponse, error) {
	out := new(ListGatewaysResponse)
	err := c.cc.Invoke(ctx, "/teleport.terminal.v1.TerminalService/ListGateways", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) DeleteGateway(ctx context.Context, in *DeleteGatewayRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/teleport.terminal.v1.TerminalService/DeleteGateway", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *terminalServiceClient) StreamGateway(ctx context.Context, opts ...grpc.CallOption) (TerminalService_StreamGatewayClient, error) {
	stream, err := c.cc.NewStream(ctx, &TerminalService_ServiceDesc.Streams[0], "/teleport.terminal.v1.TerminalService/StreamGateway", opts...)
	if err != nil {
		return nil, err
	}
	x := &terminalServiceStreamGatewayClient{stream}
	return x, nil
}

type TerminalService_StreamGatewayClient interface {
	Send(*StreamGatewayRequest) error
	Recv() (*StreamGatewayResponse, error)
	grpc.ClientStream
}

type terminalServiceStreamGatewayClient struct {
	grpc.ClientStream
}

func (x *terminalServiceStreamGatewayClient) Send(m *StreamGatewayRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *terminalServiceStreamGatewayClient) Recv() (*StreamGatewayResponse, error) {
	m := new(StreamGatewayResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *terminalServiceClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error) {
	out := new(ListNodesResponse)
	err := c.cc.Invoke(ctx, "/teleport.terminal.v1.TerminalService/ListNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TerminalServiceServer is the server API for TerminalService service.
// All implementations must embed UnimplementedTerminalServiceServer
// for forward compatibility
type TerminalServiceServer interface {
	// POST /clusters
	CreateCluster(context.Context, *CreateClusterRequest) (*Cluster, error)
	// GET /clusters
	ListClusters(context.Context, *ListClustersRequest) (*ListClustersResponse, error)
	// TODO(codingllama): Names may change!
	// POST /clusters/{cluster_id}/loginChallenges
	CreateClusterLoginChallenge(context.Context, *CreateClusterLoginChallengeRequest) (*ClusterLoginChallenge, error)
	// POST /clusters/{cluster_id}/loginChallenges/{challenge_id}:solve
	SolveClusterLoginChallenge(context.Context, *SolveClusterLoginChallengeRequest) (*SolveClusterLoginChallengeResponse, error)
	// GET /databases
	// Requires login challenge to be solved beforehand.
	ListDatabases(context.Context, *ListDatabasesRequest) (*ListDatabasesResponse, error)
	// POST /gateways
	CreateGateway(context.Context, *CreateGatewayRequest) (*Gateway, error)
	// GET /gateways
	ListGateways(context.Context, *ListGatewaysRequest) (*ListGatewaysResponse, error)
	// DELETE /gateways/{id}
	DeleteGateway(context.Context, *DeleteGatewayRequest) (*emptypb.Empty, error)
	// Streams input/output using a gateway.
	// Requires the gateway to be created beforehand.
	// This has no REST counterpart.
	StreamGateway(TerminalService_StreamGatewayServer) error
	// GET /nodes
	// Per Teleport nomenclature, a Node is an SSH-capable node.
	// Requires login challenge to be solved beforehand.
	ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error)
	mustEmbedUnimplementedTerminalServiceServer()
}

// UnimplementedTerminalServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTerminalServiceServer struct {
}

func (UnimplementedTerminalServiceServer) CreateCluster(context.Context, *CreateClusterRequest) (*Cluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCluster not implemented")
}
func (UnimplementedTerminalServiceServer) ListClusters(context.Context, *ListClustersRequest) (*ListClustersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClusters not implemented")
}
func (UnimplementedTerminalServiceServer) CreateClusterLoginChallenge(context.Context, *CreateClusterLoginChallengeRequest) (*ClusterLoginChallenge, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateClusterLoginChallenge not implemented")
}
func (UnimplementedTerminalServiceServer) SolveClusterLoginChallenge(context.Context, *SolveClusterLoginChallengeRequest) (*SolveClusterLoginChallengeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SolveClusterLoginChallenge not implemented")
}
func (UnimplementedTerminalServiceServer) ListDatabases(context.Context, *ListDatabasesRequest) (*ListDatabasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDatabases not implemented")
}
func (UnimplementedTerminalServiceServer) CreateGateway(context.Context, *CreateGatewayRequest) (*Gateway, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGateway not implemented")
}
func (UnimplementedTerminalServiceServer) ListGateways(context.Context, *ListGatewaysRequest) (*ListGatewaysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGateways not implemented")
}
func (UnimplementedTerminalServiceServer) DeleteGateway(context.Context, *DeleteGatewayRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGateway not implemented")
}
func (UnimplementedTerminalServiceServer) StreamGateway(TerminalService_StreamGatewayServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamGateway not implemented")
}
func (UnimplementedTerminalServiceServer) ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedTerminalServiceServer) mustEmbedUnimplementedTerminalServiceServer() {}

// UnsafeTerminalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TerminalServiceServer will
// result in compilation errors.
type UnsafeTerminalServiceServer interface {
	mustEmbedUnimplementedTerminalServiceServer()
}

func RegisterTerminalServiceServer(s grpc.ServiceRegistrar, srv TerminalServiceServer) {
	s.RegisterService(&TerminalService_ServiceDesc, srv)
}

func _TerminalService_CreateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).CreateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/teleport.terminal.v1.TerminalService/CreateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).CreateCluster(ctx, req.(*CreateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ListClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/teleport.terminal.v1.TerminalService/ListClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListClusters(ctx, req.(*ListClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_CreateClusterLoginChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterLoginChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).CreateClusterLoginChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/teleport.terminal.v1.TerminalService/CreateClusterLoginChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).CreateClusterLoginChallenge(ctx, req.(*CreateClusterLoginChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_SolveClusterLoginChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SolveClusterLoginChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).SolveClusterLoginChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/teleport.terminal.v1.TerminalService/SolveClusterLoginChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).SolveClusterLoginChallenge(ctx, req.(*SolveClusterLoginChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ListDatabases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDatabasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListDatabases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/teleport.terminal.v1.TerminalService/ListDatabases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListDatabases(ctx, req.(*ListDatabasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_CreateGateway_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).CreateGateway(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/teleport.terminal.v1.TerminalService/CreateGateway",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).CreateGateway(ctx, req.(*CreateGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_ListGateways_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGatewaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListGateways(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/teleport.terminal.v1.TerminalService/ListGateways",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListGateways(ctx, req.(*ListGatewaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_DeleteGateway_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).DeleteGateway(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/teleport.terminal.v1.TerminalService/DeleteGateway",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).DeleteGateway(ctx, req.(*DeleteGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TerminalService_StreamGateway_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TerminalServiceServer).StreamGateway(&terminalServiceStreamGatewayServer{stream})
}

type TerminalService_StreamGatewayServer interface {
	Send(*StreamGatewayResponse) error
	Recv() (*StreamGatewayRequest, error)
	grpc.ServerStream
}

type terminalServiceStreamGatewayServer struct {
	grpc.ServerStream
}

func (x *terminalServiceStreamGatewayServer) Send(m *StreamGatewayResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *terminalServiceStreamGatewayServer) Recv() (*StreamGatewayRequest, error) {
	m := new(StreamGatewayRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TerminalService_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TerminalServiceServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/teleport.terminal.v1.TerminalService/ListNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TerminalServiceServer).ListNodes(ctx, req.(*ListNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TerminalService_ServiceDesc is the grpc.ServiceDesc for TerminalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TerminalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "teleport.terminal.v1.TerminalService",
	HandlerType: (*TerminalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCluster",
			Handler:    _TerminalService_CreateCluster_Handler,
		},
		{
			MethodName: "ListClusters",
			Handler:    _TerminalService_ListClusters_Handler,
		},
		{
			MethodName: "CreateClusterLoginChallenge",
			Handler:    _TerminalService_CreateClusterLoginChallenge_Handler,
		},
		{
			MethodName: "SolveClusterLoginChallenge",
			Handler:    _TerminalService_SolveClusterLoginChallenge_Handler,
		},
		{
			MethodName: "ListDatabases",
			Handler:    _TerminalService_ListDatabases_Handler,
		},
		{
			MethodName: "CreateGateway",
			Handler:    _TerminalService_CreateGateway_Handler,
		},
		{
			MethodName: "ListGateways",
			Handler:    _TerminalService_ListGateways_Handler,
		},
		{
			MethodName: "DeleteGateway",
			Handler:    _TerminalService_DeleteGateway_Handler,
		},
		{
			MethodName: "ListNodes",
			Handler:    _TerminalService_ListNodes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamGateway",
			Handler:       _TerminalService_StreamGateway_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "teleport/terminal/v1/terminal_service.proto",
}
